/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/avsc/etc/browser/avsc-services.js":
/*!********************************************************!*\
  !*** ./node_modules/avsc/etc/browser/avsc-services.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint browserify: true */\n\n\n\n/**\n * Optional entry point for browser builds.\n *\n * To use it: `require('avsc/etc/browser/avsc-services')`.\n */\n\nvar avroTypes = __webpack_require__(/*! ./avsc-types */ \"./node_modules/avsc/etc/browser/avsc-types.js\"),\n    services = __webpack_require__(/*! ../../lib/services */ \"./node_modules/avsc/lib/services.js\"),\n    specs = __webpack_require__(/*! ../../lib/specs */ \"./node_modules/avsc/lib/specs.js\"),\n    utils = __webpack_require__(/*! ../../lib/utils */ \"./node_modules/avsc/lib/utils.js\");\n\n\n/** Slightly enhanced parsing, supporting IDL declarations. */\nfunction parse(any, opts) {\n  var schemaOrProtocol = specs.read(any);\n  return schemaOrProtocol.protocol ?\n    services.Service.forProtocol(schemaOrProtocol, opts) :\n    avroTypes.Type.forSchema(schemaOrProtocol, opts);\n}\n\n\nmodule.exports = {\n  Service: services.Service,\n  assembleProtocol: specs.assembleProtocol,\n  discoverProtocol: services.discoverProtocol,\n  parse: parse,\n  readProtocol: specs.readProtocol,\n  readSchema: specs.readSchema,\n};\n\nutils.copyOwnProperties(avroTypes, module.exports);\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/avsc-services.js?");

/***/ }),

/***/ "./node_modules/avsc/etc/browser/avsc-types.js":
/*!*****************************************************!*\
  !*** ./node_modules/avsc/etc/browser/avsc-types.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint browserify: true */\n\n\n\n/**\n * Optional entry point for browser builds.\n *\n * To use it: `require('avsc/etc/browser/avsc-types')`.\n */\n\nvar types = __webpack_require__(/*! ../../lib/types */ \"./node_modules/avsc/lib/types.js\");\n\n\n/** Basic parse method, only supporting JSON parsing. */\nfunction parse(any, opts) {\n  var schema;\n  if (typeof any == 'string') {\n    try {\n      schema = JSON.parse(any);\n    } catch (err) {\n      schema = any;\n    }\n  } else {\n    schema = any;\n  }\n  return types.Type.forSchema(schema, opts);\n}\n\n\nmodule.exports = {\n  Type: types.Type,\n  parse: parse,\n  types: types.builtins,\n  // Deprecated exports (not using `util.deprecate` since it causes stack\n  // overflow errors in the browser).\n  combine: types.Type.forTypes,\n  infer: types.Type.forValue\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/avsc-types.js?");

/***/ }),

/***/ "./node_modules/avsc/etc/browser/avsc.js":
/*!***********************************************!*\
  !*** ./node_modules/avsc/etc/browser/avsc.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint browser: true, node: true */\n\n\n\n/**\n * Main browserify entry point.\n *\n * This version of the entry point adds a couple browser-specific utilities to\n * read and write blobs.\n */\n\nvar avroServices = __webpack_require__(/*! ./avsc-services */ \"./node_modules/avsc/etc/browser/avsc-services.js\"),\n    containers = __webpack_require__(/*! ../../lib/containers */ \"./node_modules/avsc/lib/containers.js\"),\n    utils = __webpack_require__(/*! ../../lib/utils */ \"./node_modules/avsc/lib/utils.js\"),\n    stream = __webpack_require__(/*! stream */ \"?1dbe\"),\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\n\n/** Transform stream which lazily reads a blob's contents. */\nfunction BlobReader(blob, opts) {\n  stream.Readable.call(this);\n  opts = opts || {};\n\n  this._batchSize = opts.batchSize || 65536;\n  this._blob = blob;\n  this._pos = 0;\n}\nutil.inherits(BlobReader, stream.Readable);\n\nBlobReader.prototype._read = function () {\n  var pos = this._pos;\n  if (pos >= this._blob.size) {\n    this.push(null);\n    return;\n  }\n\n  this._pos += this._batchSize;\n  var blob = this._blob.slice(pos, this._pos, this._blob.type);\n  var reader = new FileReader();\n  var self = this;\n  reader.addEventListener('loadend', function cb(evt) {\n    reader.removeEventListener('loadend', cb, false);\n    if (evt.error) {\n      self.emit('error', evt.error);\n    } else {\n      self.push(utils.bufferFrom(reader.result));\n    }\n  }, false);\n  reader.readAsArrayBuffer(blob);\n};\n\n/** Transform stream which builds a blob from all data written to it. */\nfunction BlobWriter() {\n  stream.Transform.call(this, {readableObjectMode: true});\n  this._bufs = [];\n}\nutil.inherits(BlobWriter, stream.Transform);\n\nBlobWriter.prototype._transform = function (buf, encoding, cb) {\n  this._bufs.push(buf);\n  cb();\n};\n\nBlobWriter.prototype._flush = function (cb) {\n  this.push(new Blob(this._bufs, {type: 'application/octet-binary'}));\n  cb();\n};\n\n/** Read an Avro-container stored as a blob. */\nfunction createBlobDecoder(blob, opts) {\n  return new BlobReader(blob).pipe(new containers.streams.BlockDecoder(opts));\n}\n\n/**\n * Store Avro values into an Avro-container blob.\n *\n * The returned stream will emit a single value, the blob, when ended.\n */\nfunction createBlobEncoder(schema, opts) {\n  var encoder = new containers.streams.BlockEncoder(schema, opts);\n  var builder = new BlobWriter();\n  encoder.pipe(builder);\n  return new stream.Duplex({\n    objectMode: true,\n    read: function () {\n      // Not the fastest implementation, but it will only be called at most\n      // once (since the builder only ever emits a single value) so it'll do.\n      // It's also likely impractical to create very large blobs.\n      var val = builder.read();\n      if (val) {\n        done(val);\n      } else {\n        builder.once('readable', done);\n      }\n      var self = this;\n      function done(val) {\n        self.push(val || builder.read());\n        self.push(null);\n      }\n    },\n    write: function (val, encoding, cb) {\n      return encoder.write(val, encoding, cb);\n    }\n  }).on('finish', function () { encoder.end(); });\n}\n\n\nmodule.exports = {\n  createBlobDecoder: createBlobDecoder,\n  createBlobEncoder: createBlobEncoder,\n  streams: containers.streams\n};\n\nutils.copyOwnProperties(avroServices, module.exports);\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/avsc.js?");

/***/ }),

/***/ "./node_modules/avsc/etc/browser/lib/crypto.js":
/*!*****************************************************!*\
  !*** ./node_modules/avsc/etc/browser/lib/crypto.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* jshint browserify: true */\n\n\n\n/**\n * Shim to enable schema fingerprint computation.\n *\n * MD5 implementation originally from [1], used with permission from the\n * author, and lightly edited.\n *\n * [1] http://www.myersdaily.org/joseph/javascript/md5-text.html\n *\n */\n\nfunction createHash(algorithm) {\n  if (algorithm !== 'md5') {\n    throw new Error('only md5 is supported in the browser');\n  }\n  return new Hash();\n}\n\nfunction Hash() { this.data = undefined; }\nHash.prototype.end = function (data) { this.data = data; };\nHash.prototype.read = function () { return md5(this.data); };\n\nfunction md5cycle(x, k) {\n  var a = x[0], b = x[1], c = x[2], d = x[3];\n\n  a = ff(a, b, c, d, k[0], 7, -680876936);\n  d = ff(d, a, b, c, k[1], 12, -389564586);\n  c = ff(c, d, a, b, k[2], 17,  606105819);\n  b = ff(b, c, d, a, k[3], 22, -1044525330);\n  a = ff(a, b, c, d, k[4], 7, -176418897);\n  d = ff(d, a, b, c, k[5], 12,  1200080426);\n  c = ff(c, d, a, b, k[6], 17, -1473231341);\n  b = ff(b, c, d, a, k[7], 22, -45705983);\n  a = ff(a, b, c, d, k[8], 7,  1770035416);\n  d = ff(d, a, b, c, k[9], 12, -1958414417);\n  c = ff(c, d, a, b, k[10], 17, -42063);\n  b = ff(b, c, d, a, k[11], 22, -1990404162);\n  a = ff(a, b, c, d, k[12], 7,  1804603682);\n  d = ff(d, a, b, c, k[13], 12, -40341101);\n  c = ff(c, d, a, b, k[14], 17, -1502002290);\n  b = ff(b, c, d, a, k[15], 22,  1236535329);\n\n  a = gg(a, b, c, d, k[1], 5, -165796510);\n  d = gg(d, a, b, c, k[6], 9, -1069501632);\n  c = gg(c, d, a, b, k[11], 14,  643717713);\n  b = gg(b, c, d, a, k[0], 20, -373897302);\n  a = gg(a, b, c, d, k[5], 5, -701558691);\n  d = gg(d, a, b, c, k[10], 9,  38016083);\n  c = gg(c, d, a, b, k[15], 14, -660478335);\n  b = gg(b, c, d, a, k[4], 20, -405537848);\n  a = gg(a, b, c, d, k[9], 5,  568446438);\n  d = gg(d, a, b, c, k[14], 9, -1019803690);\n  c = gg(c, d, a, b, k[3], 14, -187363961);\n  b = gg(b, c, d, a, k[8], 20,  1163531501);\n  a = gg(a, b, c, d, k[13], 5, -1444681467);\n  d = gg(d, a, b, c, k[2], 9, -51403784);\n  c = gg(c, d, a, b, k[7], 14,  1735328473);\n  b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n  a = hh(a, b, c, d, k[5], 4, -378558);\n  d = hh(d, a, b, c, k[8], 11, -2022574463);\n  c = hh(c, d, a, b, k[11], 16,  1839030562);\n  b = hh(b, c, d, a, k[14], 23, -35309556);\n  a = hh(a, b, c, d, k[1], 4, -1530992060);\n  d = hh(d, a, b, c, k[4], 11,  1272893353);\n  c = hh(c, d, a, b, k[7], 16, -155497632);\n  b = hh(b, c, d, a, k[10], 23, -1094730640);\n  a = hh(a, b, c, d, k[13], 4,  681279174);\n  d = hh(d, a, b, c, k[0], 11, -358537222);\n  c = hh(c, d, a, b, k[3], 16, -722521979);\n  b = hh(b, c, d, a, k[6], 23,  76029189);\n  a = hh(a, b, c, d, k[9], 4, -640364487);\n  d = hh(d, a, b, c, k[12], 11, -421815835);\n  c = hh(c, d, a, b, k[15], 16,  530742520);\n  b = hh(b, c, d, a, k[2], 23, -995338651);\n\n  a = ii(a, b, c, d, k[0], 6, -198630844);\n  d = ii(d, a, b, c, k[7], 10,  1126891415);\n  c = ii(c, d, a, b, k[14], 15, -1416354905);\n  b = ii(b, c, d, a, k[5], 21, -57434055);\n  a = ii(a, b, c, d, k[12], 6,  1700485571);\n  d = ii(d, a, b, c, k[3], 10, -1894986606);\n  c = ii(c, d, a, b, k[10], 15, -1051523);\n  b = ii(b, c, d, a, k[1], 21, -2054922799);\n  a = ii(a, b, c, d, k[8], 6,  1873313359);\n  d = ii(d, a, b, c, k[15], 10, -30611744);\n  c = ii(c, d, a, b, k[6], 15, -1560198380);\n  b = ii(b, c, d, a, k[13], 21,  1309151649);\n  a = ii(a, b, c, d, k[4], 6, -145523070);\n  d = ii(d, a, b, c, k[11], 10, -1120210379);\n  c = ii(c, d, a, b, k[2], 15,  718787259);\n  b = ii(b, c, d, a, k[9], 21, -343485551);\n\n  x[0] = add32(a, x[0]);\n  x[1] = add32(b, x[1]);\n  x[2] = add32(c, x[2]);\n  x[3] = add32(d, x[3]);\n}\n\nfunction cmn(q, a, b, x, s, t) {\n  a = add32(add32(a, q), add32(x, t));\n  return add32((a << s) | (a >>> (32 - s)), b);\n}\n\nfunction ff(a, b, c, d, x, s, t) {\n  return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n}\n\nfunction gg(a, b, c, d, x, s, t) {\n  return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n}\n\nfunction hh(a, b, c, d, x, s, t) {\n  return cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction ii(a, b, c, d, x, s, t) {\n  return cmn(c ^ (b | (~d)), a, b, x, s, t);\n}\n\nfunction md51(s) {\n  var n = s.length,\n  state = [1732584193, -271733879, -1732584194, 271733878], i;\n  for (i=64; i<=s.length; i+=64) {\n    md5cycle(state, md5blk(s.substring(i-64, i)));\n  }\n\n  s = s.substring(i-64);\n  var tail = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];\n  for (i=0; i<s.length; i++) {\n    tail[i>>2] |= s.charCodeAt(i) << ((i%4) << 3);\n  }\n  tail[i>>2] |= 0x80 << ((i%4) << 3);\n  if (i > 55) {\n    md5cycle(state, tail);\n    for (i=0; i<16; i++) {\n      tail[i] = 0;\n    }\n  }\n  tail[14] = n*8;\n  md5cycle(state, tail);\n  return state;\n}\n\nfunction md5blk(s) {\n  var md5blks = [], i;\n  for (i=0; i<64; i+=4) {\n    md5blks[i>>2] = s.charCodeAt(i) +\n      (s.charCodeAt(i+1) << 8) +\n      (s.charCodeAt(i+2) << 16) +\n      (s.charCodeAt(i+3) << 24);\n  }\n  return md5blks;\n}\n\nfunction md5(s) {\n  var arr = md51(s);\n  var buf = Buffer.alloc ? Buffer.alloc(16) : new Buffer(16);\n  var i;\n  for (i = 0; i < 4; i++) {\n    buf.writeIntLE(arr[i], i * 4, 4);\n  }\n  return buf;\n}\n\nfunction add32(a, b) {\n  return (a + b) & 0xFFFFFFFF;\n}\n\nmodule.exports = {\n  createHash: createHash\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/lib/crypto.js?");

/***/ }),

/***/ "./node_modules/avsc/etc/browser/lib/files.js":
/*!****************************************************!*\
  !*** ./node_modules/avsc/etc/browser/lib/files.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/* jshint node: true */\n\n\n\n/** Shim without file-system operations. */\n\nfunction createError() { return new Error('unsupported in the browser'); }\n\nfunction createImportHook() {\n  return function (fpath, kind, cb) { cb(createError()); };\n}\n\nfunction createSyncImportHook() {\n  return function () { throw createError(); };\n}\n\n\nmodule.exports = {\n  createImportHook: createImportHook,\n  createSyncImportHook: createSyncImportHook,\n  existsSync: function () { return false; },\n  readFileSync: function () { throw createError(); }\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/lib/files.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/containers.js":
/*!*********************************************!*\
  !*** ./node_modules/avsc/lib/containers.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n/* jshint node: true */\n\n// TODO: Add streams which prefix each record with its length.\n\n\n\n/**\n * This module defines custom streams to write and read Avro files.\n *\n * In particular, the `Block{En,De}coder` streams are able to deal with Avro\n * container files. None of the streams below depend on the filesystem however,\n * this way they can also be used in the browser (for example to parse HTTP\n * responses).\n */\n\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\n    stream = __webpack_require__(/*! stream */ \"?5399\"),\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\"),\n    zlib = __webpack_require__(/*! zlib */ \"?6f86\");\n\n\nvar OPTS = {namespace: 'org.apache.avro.file'};\n\nvar LONG_TYPE = types.Type.forSchema('long', OPTS);\n\nvar MAP_BYTES_TYPE = types.Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\n\nvar HEADER_TYPE = types.Type.forSchema({\n  name: 'Header',\n  type: 'record',\n  fields : [\n    {name: 'magic', type: {type: 'fixed', name: 'Magic', size: 4}},\n    {name: 'meta', type: MAP_BYTES_TYPE},\n    {name: 'sync', type: {type: 'fixed', name: 'Sync', size: 16}}\n  ]\n}, OPTS);\n\nvar BLOCK_TYPE = types.Type.forSchema({\n  name: 'Block',\n  type: 'record',\n  fields : [\n    {name: 'count', type: 'long'},\n    {name: 'data', type: 'bytes'},\n    {name: 'sync', type: 'Sync'}\n  ]\n}, OPTS);\n\n// First 4 bytes of an Avro object container file.\nvar MAGIC_BYTES = utils.bufferFrom('Obj\\x01');\n\n// Convenience.\nvar f = util.format;\nvar Tap = utils.Tap;\n\n\n/** Duplex stream for decoding fragments. */\nfunction RawDecoder(schema, opts) {\n  opts = opts || {};\n\n  var noDecode = !!opts.noDecode;\n  stream.Duplex.call(this, {\n    readableObjectMode: !noDecode,\n    allowHalfOpen: false\n  });\n\n  this._type = types.Type.forSchema(schema);\n  this._tap = new Tap(utils.newBuffer(0));\n  this._writeCb = null;\n  this._needPush = false;\n  this._readValue = createReader(noDecode, this._type);\n  this._finished = false;\n\n  this.on('finish', function () {\n    this._finished = true;\n    this._read();\n  });\n}\nutil.inherits(RawDecoder, stream.Duplex);\n\nRawDecoder.prototype._write = function (chunk, encoding, cb) {\n  // Store the write callback and call it when we are done decoding all records\n  // in this chunk. If we call it right away, we risk loading the entire input\n  // in memory. We only need to store the latest callback since the stream API\n  // guarantees that `_write` won't be called again until we call the previous.\n  this._writeCb = cb;\n\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n  if (this._needPush) {\n    this._needPush = false;\n    this._read();\n  }\n};\n\nRawDecoder.prototype._read = function () {\n  this._needPush = false;\n\n  var tap = this._tap;\n  var pos = tap.pos;\n  var val = this._readValue(tap);\n  if (tap.isValid()) {\n    this.push(val);\n  } else if (!this._finished) {\n    tap.pos = pos;\n    this._needPush = true;\n    if (this._writeCb) {\n      // This should only ever be false on the first read, and only if it\n      // happens before the first write.\n      this._writeCb();\n    }\n  } else {\n    this.push(null);\n  }\n};\n\n\n/** Duplex stream for decoding object container files. */\nfunction BlockDecoder(opts) {\n  opts = opts || {};\n\n  var noDecode = !!opts.noDecode;\n  stream.Duplex.call(this, {\n    allowHalfOpen: true, // For async decompressors.\n    readableObjectMode: !noDecode\n  });\n\n  this._rType = opts.readerSchema !== undefined ?\n    types.Type.forSchema(opts.readerSchema) :\n    undefined;\n  this._wType = null;\n  this._codecs = opts.codecs;\n  this._codec = undefined;\n  this._parseHook = opts.parseHook;\n  this._tap = new Tap(utils.newBuffer(0));\n  this._blockTap = new Tap(utils.newBuffer(0));\n  this._syncMarker = null;\n  this._readValue = null;\n  this._noDecode = noDecode;\n  this._queue = new utils.OrderedQueue();\n  this._decompress = null; // Decompression function.\n  this._index = 0; // Next block index.\n  this._remaining = undefined; // In the current block.\n  this._needPush = false;\n  this._finished = false;\n\n  this.on('finish', function () {\n    this._finished = true;\n    if (this._needPush) {\n      this._read();\n    }\n  });\n}\nutil.inherits(BlockDecoder, stream.Duplex);\n\nBlockDecoder.defaultCodecs = function () {\n  return {\n    'null': function (buf, cb) { cb(null, buf); },\n    'deflate': zlib.inflateRaw\n  };\n};\n\nBlockDecoder.getDefaultCodecs = BlockDecoder.defaultCodecs;\n\nBlockDecoder.prototype._decodeHeader = function () {\n  var tap = this._tap;\n  if (tap.buf.length < MAGIC_BYTES.length) {\n    // Wait until more data arrives.\n    return false;\n  }\n\n  if (!MAGIC_BYTES.equals(tap.buf.slice(0, MAGIC_BYTES.length))) {\n    this.emit('error', new Error('invalid magic bytes'));\n    return false;\n  }\n\n  var header = HEADER_TYPE._read(tap);\n  if (!tap.isValid()) {\n    return false;\n  }\n\n  this._codec = (header.meta['avro.codec'] || 'null').toString();\n  var codecs = this._codecs || BlockDecoder.getDefaultCodecs();\n  this._decompress = codecs[this._codec];\n  if (!this._decompress) {\n    this.emit('error', new Error(f('unknown codec: %s', this._codec)));\n    return;\n  }\n\n  try {\n    var schema = JSON.parse(header.meta['avro.schema'].toString());\n    if (this._parseHook) {\n      schema = this._parseHook(schema);\n    }\n    this._wType = types.Type.forSchema(schema);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n\n  try {\n    this._readValue = createReader(this._noDecode, this._wType, this._rType);\n  } catch (err) {\n    this.emit('error', err);\n    return;\n  }\n\n  this._syncMarker = header.sync;\n  this.emit('metadata', this._wType, this._codec, header);\n  return true;\n};\n\nBlockDecoder.prototype._write = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf, chunk]);\n  tap.pos = 0;\n\n  if (!this._decodeHeader()) {\n    process.nextTick(cb);\n    return;\n  }\n\n  // We got the header, switch to block decoding mode. Also, call it directly\n  // in case we already have all the data (in which case `_write` wouldn't get\n  // called anymore).\n  this._write = this._writeChunk;\n  this._write(utils.newBuffer(0), encoding, cb);\n};\n\nBlockDecoder.prototype._writeChunk = function (chunk, encoding, cb) {\n  var tap = this._tap;\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\n  tap.pos = 0;\n\n  var nBlocks = 1;\n  var block;\n  while ((block = tryReadBlock(tap))) {\n    if (!this._syncMarker.equals(block.sync)) {\n      this.emit('error', new Error('invalid sync marker'));\n      return;\n    }\n    nBlocks++;\n    this._decompress(\n      block.data,\n      this._createBlockCallback(block.data.length, block.count, chunkCb)\n    );\n  }\n  chunkCb();\n\n  function chunkCb() {\n    if (!--nBlocks) {\n      cb();\n    }\n  }\n};\n\nBlockDecoder.prototype._createBlockCallback = function (size, count, cb) {\n  var self = this;\n  var index = this._index++;\n\n  return function (cause, data) {\n    if (cause) {\n      var err = new Error(f('%s codec decompression error', self._codec));\n      err.cause = cause;\n      self.emit('error', err);\n      cb();\n    } else {\n      self.emit('block', new BlockInfo(count, data.length, size));\n      self._queue.push(new BlockData(index, data, cb, count));\n      if (self._needPush) {\n        self._read();\n      }\n    }\n  };\n};\n\nBlockDecoder.prototype._read = function () {\n  this._needPush = false;\n\n  var tap = this._blockTap;\n  if (!this._remaining) {\n    var data = this._queue.pop();\n    if (!data || !data.count) {\n      if (this._finished) {\n        this.push(null);\n      } else {\n        this._needPush = true;\n      }\n      if (data) {\n        data.cb();\n      }\n      return; // Wait for more data.\n    }\n    data.cb();\n    this._remaining = data.count;\n    tap.buf = data.buf;\n    tap.pos = 0;\n  }\n\n  this._remaining--;\n  var val;\n  try {\n    val = this._readValue(tap);\n    if (!tap.isValid()) {\n      throw new Error('truncated block');\n    }\n  } catch (err) {\n    this._remaining = 0;\n    this.emit('error', err); // Corrupt data.\n    return;\n  }\n  this.push(val);\n};\n\n\n/** Duplex stream for encoding. */\nfunction RawEncoder(schema, opts) {\n  opts = opts || {};\n\n  stream.Transform.call(this, {\n    writableObjectMode: true,\n    allowHalfOpen: false\n  });\n\n  this._type = types.Type.forSchema(schema);\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('typeError', err, val, this._type);\n    }\n  };\n  this._tap = new Tap(utils.newBuffer(opts.batchSize || 65536));\n\n  this.on('typeError', function (err) { this.emit('error', err); });\n}\nutil.inherits(RawEncoder, stream.Transform);\n\nRawEncoder.prototype._transform = function (val, encoding, cb) {\n  var tap = this._tap;\n  var buf = tap.buf;\n  var pos = tap.pos;\n\n  this._writeValue(tap, val);\n  if (!tap.isValid()) {\n    if (pos) {\n      // Emit any valid data.\n      this.push(copyBuffer(tap.buf, 0, pos));\n    }\n    var len = tap.pos - pos;\n    if (len > buf.length) {\n      // Not enough space for last written object, need to resize.\n      tap.buf = utils.newBuffer(2 * len);\n    }\n    tap.pos = 0;\n    this._writeValue(tap, val); // Rewrite last failed write.\n  }\n\n  cb();\n};\n\nRawEncoder.prototype._flush = function (cb) {\n  var tap = this._tap;\n  var pos = tap.pos;\n  if (pos) {\n    // This should only ever be false if nothing is written to the stream.\n    this.push(tap.buf.slice(0, pos));\n  }\n  cb();\n};\n\n\n/**\n * Duplex stream to write object container files.\n *\n * @param schema\n * @param opts {Object}\n *\n *  + `blockSize`, uncompressed.\n *  + `codec`\n *  + `codecs`\n *  + `metadata``\n *  + `noCheck`\n *  + `omitHeader`, useful to append to an existing block file.\n */\nfunction BlockEncoder(schema, opts) {\n  opts = opts || {};\n\n  stream.Duplex.call(this, {\n    allowHalfOpen: true, // To support async compressors.\n    writableObjectMode: true\n  });\n\n  var type;\n  if (types.Type.isType(schema)) {\n    type = schema;\n    schema = undefined;\n  } else {\n    // Keep full schema to be able to write it to the header later.\n    type = types.Type.forSchema(schema);\n  }\n\n  this._schema = schema;\n  this._type = type;\n  this._writeValue = function (tap, val) {\n    try {\n      this._type._write(tap, val);\n    } catch (err) {\n      this.emit('typeError', err, val, this._type);\n      return false;\n    }\n    return true;\n  };\n  this._blockSize = opts.blockSize || 65536;\n  this._tap = new Tap(utils.newBuffer(this._blockSize));\n  this._codecs = opts.codecs;\n  this._codec = opts.codec || 'null';\n  this._blockCount = 0;\n  this._syncMarker = opts.syncMarker || new utils.Lcg().nextBuffer(16);\n  this._queue = new utils.OrderedQueue();\n  this._pending = 0;\n  this._finished = false;\n  this._needHeader = false;\n  this._needPush = false;\n\n  this._metadata = opts.metadata || {};\n  if (!MAP_BYTES_TYPE.isValid(this._metadata)) {\n    throw new Error('invalid metadata');\n  }\n\n  var codec = this._codec;\n  this._compress = (this._codecs || BlockEncoder.getDefaultCodecs())[codec];\n  if (!this._compress) {\n    throw new Error(f('unsupported codec: %s', codec));\n  }\n\n  if (opts.omitHeader !== undefined) { // Legacy option.\n    opts.writeHeader = opts.omitHeader ? 'never' : 'auto';\n  }\n  switch (opts.writeHeader) {\n    case false:\n    case 'never':\n      break;\n    case undefined: // Backwards-compatibility (eager default would be better).\n    case 'auto':\n      this._needHeader = true;\n      break;\n    default:\n      this._writeHeader();\n  }\n\n  this.on('finish', function () {\n    this._finished = true;\n    if (this._blockCount) {\n      this._flushChunk();\n    } else if (this._finished && this._needPush) {\n      // We don't need to check `_isPending` since `_blockCount` is always\n      // positive after the first flush.\n      this.push(null);\n    }\n  });\n\n  this.on('typeError', function (err) { this.emit('error', err); });\n}\nutil.inherits(BlockEncoder, stream.Duplex);\n\nBlockEncoder.defaultCodecs = function () {\n  return {\n    'null': function (buf, cb) { cb(null, buf); },\n    'deflate': zlib.deflateRaw\n  };\n};\n\nBlockEncoder.getDefaultCodecs = BlockEncoder.defaultCodecs;\n\nBlockEncoder.prototype._writeHeader = function () {\n  var schema = JSON.stringify(\n    this._schema ? this._schema : this._type.getSchema({exportAttrs: true})\n  );\n  var meta = utils.copyOwnProperties(\n    this._metadata,\n    {'avro.schema': utils.bufferFrom(schema), 'avro.codec': utils.bufferFrom(this._codec)},\n    true // Overwrite.\n  );\n  var Header = HEADER_TYPE.getRecordConstructor();\n  var header = new Header(MAGIC_BYTES, meta, this._syncMarker);\n  this.push(header.toBuffer());\n};\n\nBlockEncoder.prototype._write = function (val, encoding, cb) {\n  if (this._needHeader) {\n    this._writeHeader();\n    this._needHeader = false;\n  }\n\n  var tap = this._tap;\n  var pos = tap.pos;\n  var flushing = false;\n\n  if (this._writeValue(tap, val)) {\n    if (!tap.isValid()) {\n      if (pos) {\n        this._flushChunk(pos, cb);\n        flushing = true;\n      }\n      var len = tap.pos - pos;\n      if (len > this._blockSize) {\n        // Not enough space for last written object, need to resize.\n        this._blockSize = len * 2;\n      }\n      tap.buf = utils.newBuffer(this._blockSize);\n      tap.pos = 0;\n      this._writeValue(tap, val); // Rewrite last failed write.\n    }\n    this._blockCount++;\n  } else {\n    tap.pos = pos;\n  }\n\n  if (!flushing) {\n    cb();\n  }\n};\n\nBlockEncoder.prototype._flushChunk = function (pos, cb) {\n  var tap = this._tap;\n  pos = pos || tap.pos;\n  this._compress(tap.buf.slice(0, pos), this._createBlockCallback(pos, cb));\n  this._blockCount = 0;\n};\n\nBlockEncoder.prototype._read = function () {\n  var self = this;\n  var data = this._queue.pop();\n  if (!data) {\n    if (this._finished && !this._pending) {\n      process.nextTick(function () { self.push(null); });\n    } else {\n      this._needPush = true;\n    }\n    return;\n  }\n\n  this.push(LONG_TYPE.toBuffer(data.count, true));\n  this.push(LONG_TYPE.toBuffer(data.buf.length, true));\n  this.push(data.buf);\n  this.push(this._syncMarker);\n\n  if (!this._finished) {\n    data.cb();\n  }\n};\n\nBlockEncoder.prototype._createBlockCallback = function (size, cb) {\n  var self = this;\n  var index = this._index++;\n  var count = this._blockCount;\n  this._pending++;\n\n  return function (cause, data) {\n    if (cause) {\n      var err = new Error(f('%s codec compression error', self._codec));\n      err.cause = cause;\n      self.emit('error', err);\n      return;\n    }\n    self._pending--;\n    self.emit('block', new BlockInfo(count, size, data.length));\n    self._queue.push(new BlockData(index, data, cb, count));\n    if (self._needPush) {\n      self._needPush = false;\n      self._read();\n    }\n  };\n};\n\n\n// Helpers.\n\n/** Summary information about a block. */\nfunction BlockInfo(count, raw, compressed) {\n  this.valueCount = count;\n  this.rawDataLength = raw;\n  this.compressedDataLength = compressed;\n}\n\n/**\n * An indexed block.\n *\n * This can be used to preserve block order since compression and decompression\n * can cause some some blocks to be returned out of order.\n */\nfunction BlockData(index, buf, cb, count) {\n  this.index = index;\n  this.buf = buf;\n  this.cb = cb;\n  this.count = count | 0;\n}\n\n/** Maybe get a block. */\nfunction tryReadBlock(tap) {\n  var pos = tap.pos;\n  var block = BLOCK_TYPE._read(tap);\n  if (!tap.isValid()) {\n    tap.pos = pos;\n    return null;\n  }\n  return block;\n}\n\n/** Create bytes consumer, either reading or skipping records. */\nfunction createReader(noDecode, writerType, readerType) {\n  if (noDecode) {\n    return (function (skipper) {\n      return function (tap) {\n        var pos = tap.pos;\n        skipper(tap);\n        return tap.buf.slice(pos, tap.pos);\n      };\n    })(writerType._skip);\n  } else if (readerType) {\n    var resolver = readerType.createResolver(writerType);\n    return function (tap) { return resolver._read(tap); };\n  } else {\n    return function (tap) { return writerType._read(tap); };\n  }\n}\n\n/** Copy a buffer. This avoids creating a slice of the original buffer. */\nfunction copyBuffer(buf, pos, len) {\n  var copy = utils.newBuffer(len);\n  buf.copy(copy, 0, pos, pos + len);\n  return copy;\n}\n\n\nmodule.exports = {\n  BLOCK_TYPE: BLOCK_TYPE, // For tests.\n  HEADER_TYPE: HEADER_TYPE, // Idem.\n  MAGIC_BYTES: MAGIC_BYTES, // Idem.\n  streams: {\n    BlockDecoder: BlockDecoder,\n    BlockEncoder: BlockEncoder,\n    RawDecoder: RawDecoder,\n    RawEncoder: RawEncoder\n  }\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/containers.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/services.js":
/*!*******************************************!*\
  !*** ./node_modules/avsc/lib/services.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* jshint node: true */\n\n// TODO: Add broadcast option to client `_emitMessage`, accessible for one-way\n// messages.\n// TODO: Add `server.mount` method to allow combining servers. The API is as\n// follows: a mounted server's (i.e. the method's argument) handlers have lower\n// precedence than the original server (i.e. `this`); the mounted server's\n// middlewares are only invoked for its handlers.\n// TODO: Change `objectMode` client and server channel option to `encoding`\n// (accepting `'netty'`, `'standard'`, and `null` or `undefined`). Perhaps also\n// expose encoders (API TBD).\n\n\n\n/** This module implements Avro's IPC/RPC logic. */\n\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\n    events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\"),\n    stream = __webpack_require__(/*! stream */ \"?5399\"),\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\n\n// A few convenience imports.\nvar Tap = utils.Tap;\nvar Type = types.Type;\nvar debug = util.debuglog('avsc:services');\nvar f = util.format;\n\n// Various useful types. We instantiate options once, to share the registry.\nvar OPTS = {namespace: 'org.apache.avro.ipc'};\n\nvar BOOLEAN_TYPE = Type.forSchema('boolean', OPTS);\n\nvar MAP_BYTES_TYPE = Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\n\nvar STRING_TYPE = Type.forSchema('string', OPTS);\n\nvar HANDSHAKE_REQUEST_TYPE = Type.forSchema({\n  name: 'HandshakeRequest',\n  type: 'record',\n  fields: [\n    {name: 'clientHash', type: {name: 'MD5', type: 'fixed', size: 16}},\n    {name: 'clientProtocol', type: ['null', 'string'], 'default': null},\n    {name: 'serverHash', type: 'MD5'},\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\n  ]\n}, OPTS);\n\nvar HANDSHAKE_RESPONSE_TYPE = Type.forSchema({\n  name: 'HandshakeResponse',\n  type: 'record',\n  fields: [\n    {\n      name: 'match',\n      type: {\n        name: 'HandshakeMatch',\n        type: 'enum',\n        symbols: ['BOTH', 'CLIENT', 'NONE']\n      }\n    },\n    {name: 'serverProtocol', type: ['null', 'string'], 'default': null},\n    {name: 'serverHash', type: ['null', 'MD5'], 'default': null},\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\n  ]\n}, OPTS);\n\n// Prefix used to differentiate between messages when sharing a stream. This\n// length should be smaller than 16. The remainder is used for disambiguating\n// between concurrent messages (the current value, 16, therefore supports ~64k\n// concurrent messages).\nvar PREFIX_LENGTH = 16;\n\n// Internal message, used to check protocol compatibility.\nvar PING_MESSAGE = new Message(\n  '', // Empty name (invalid for other \"normal\" messages).\n  Type.forSchema({name: 'PingRequest', type: 'record', fields: []}, OPTS),\n  Type.forSchema(['string'], OPTS),\n  Type.forSchema('null', OPTS)\n);\n\n/** An Avro message, containing its request, response, etc. */\nfunction Message(name, reqType, errType, resType, oneWay, doc) {\n  this.name = name;\n  if (!Type.isType(reqType, 'record')) {\n    throw new Error('invalid request type');\n  }\n  this.requestType = reqType;\n  if (\n    !Type.isType(errType, 'union') ||\n    !Type.isType(errType.getTypes()[0], 'string')\n  ) {\n    throw new Error('invalid error type');\n  }\n  this.errorType = errType;\n  if (oneWay) {\n    if (!Type.isType(resType, 'null') || errType.getTypes().length > 1) {\n      throw new Error('inapplicable one-way parameter');\n    }\n  }\n  this.responseType = resType;\n  this.oneWay = !!oneWay;\n  this.doc = doc !== undefined ? '' + doc : undefined;\n  Object.freeze(this);\n}\n\nMessage.forSchema = function (name, schema, opts) {\n  opts = opts || {};\n  if (!utils.isValidName(name)) {\n    throw new Error(f('invalid message name: %s', name));\n  }\n  // We use a record with a placeholder name here (the user might have set\n  // `noAnonymousTypes`, so we can't use an anonymous one). We remove it from\n  // the registry afterwards to avoid exposing it outside.\n  if (!Array.isArray(schema.request)) {\n    throw new Error(f('invalid message request: %s', name));\n  }\n  var recordName = f('%s.%sRequest', OPTS.namespace, utils.capitalize(name));\n  var reqType = Type.forSchema({\n    name: recordName,\n    type: 'record',\n    namespace: opts.namespace || '', // Don't leak request namespace.\n    fields: schema.request\n  }, opts);\n  delete opts.registry[recordName];\n  if (!schema.response) {\n    throw new Error(f('invalid message response: %s', name));\n  }\n  var resType = Type.forSchema(schema.response, opts);\n  if (schema.errors !== undefined && !Array.isArray(schema.errors)) {\n    throw new Error(f('invalid message errors: %s', name));\n  }\n  var errType = Type.forSchema(['string'].concat(schema.errors || []), opts);\n  var oneWay = !!schema['one-way'];\n  return new Message(name, reqType, errType, resType, oneWay, schema.doc);\n};\n\nMessage.prototype.schema = Type.prototype.getSchema;\n\nMessage.prototype._attrs = function (opts) {\n  var reqSchema = this.requestType._attrs(opts);\n  var schema = {\n    request: reqSchema.fields,\n    response: this.responseType._attrs(opts)\n  };\n  var msgDoc = this.doc;\n  if (msgDoc !== undefined) {\n    schema.doc = msgDoc;\n  }\n  var errSchema = this.errorType._attrs(opts);\n  if (errSchema.length > 1) {\n    schema.errors = errSchema.slice(1);\n  }\n  if (this.oneWay) {\n    schema['one-way'] = true;\n  }\n  return schema;\n};\n\n// Deprecated.\n\nutils.addDeprecatedGetters(\n  Message,\n  ['name', 'errorType', 'requestType', 'responseType']\n);\n\nMessage.prototype.isOneWay = util.deprecate(\n  function () { return this.oneWay; },\n  'use `.oneWay` directly instead of `.isOneWay()`'\n);\n\n/**\n * An Avro RPC service.\n *\n * This constructor shouldn't be called directly, but via the\n * `Service.forProtocol` method. This function performs little logic to better\n * support efficient copy.\n */\nfunction Service(name, messages, types, ptcl, server) {\n  if (typeof name != 'string') {\n    // Let's be helpful in case this class is instantiated directly.\n    return Service.forProtocol(name, messages);\n  }\n\n  this.name = name;\n  this._messagesByName = messages || {};\n  this.messages = Object.freeze(utils.objectValues(this._messagesByName));\n\n  this._typesByName = types || {};\n  this.types = Object.freeze(utils.objectValues(this._typesByName));\n\n  this.protocol = ptcl;\n  // We cache a string rather than a buffer to not retain an entire slab.\n  this._hashStr = utils.getHash(JSON.stringify(ptcl)).toString('binary');\n  this.doc = ptcl.doc ? '' + ptcl.doc : undefined;\n\n  // We add a server to each protocol for backwards-compatibility (to allow the\n  // use of `protocol.on`). This covers all cases except the use of the\n  // `strictErrors` option, which requires moving to the new API.\n  this._server = server || this.createServer({silent: true});\n  Object.freeze(this);\n}\n\nService.Client = Client;\n\nService.Server = Server;\n\nService.compatible = function (clientSvc, serverSvc) {\n  try {\n    createReaders(clientSvc, serverSvc);\n  } catch (err) {\n    return false;\n  }\n  return true;\n};\n\nService.forProtocol = function (ptcl, opts) {\n  opts = opts || {};\n\n  var name = ptcl.protocol;\n  if (!name) {\n    throw new Error('missing protocol name');\n  }\n  if (ptcl.namespace !== undefined) {\n    opts.namespace = ptcl.namespace;\n  } else {\n    var match = /^(.*)\\.[^.]+$/.exec(name);\n    if (match) {\n      opts.namespace = match[1];\n    }\n  }\n  name = utils.qualify(name, opts.namespace);\n\n  if (ptcl.types) {\n    ptcl.types.forEach(function (obj) { Type.forSchema(obj, opts); });\n  }\n  var msgs;\n  if (ptcl.messages) {\n    msgs = {};\n    Object.keys(ptcl.messages).forEach(function (key) {\n      msgs[key] = Message.forSchema(key, ptcl.messages[key], opts);\n    });\n  }\n\n  return new Service(name, msgs, opts.registry, ptcl);\n};\n\nService.isService = function (any) {\n  // Not fool-proof but likely sufficient.\n  return !!any && any.hasOwnProperty('_hashStr');\n};\n\nService.prototype.createClient = function (opts) {\n  var client = new Client(this, opts);\n  process.nextTick(function () {\n    // We delay this processing such that we can attach handlers to the client\n    // before any channels get created.\n    if (opts && opts.server) {\n      // Convenience in-memory client. This can be useful to make requests\n      // relatively efficiently to an in-process server. Note that it is still\n      // is less efficient than direct method calls (because of the\n      // serialization, which does provide \"type-safety\" though).\n      var obj = {objectMode: true};\n      var pts = [new stream.PassThrough(obj), new stream.PassThrough(obj)];\n      opts.server.createChannel({readable: pts[0], writable: pts[1]}, obj);\n      client.createChannel({readable: pts[1], writable: pts[0]}, obj);\n    } else if (opts && opts.transport) {\n      // Convenience functionality for the common single channel use-case: we\n      // add a single channel using default options to the client.\n      client.createChannel(opts.transport);\n    }\n  });\n  return client;\n};\n\nService.prototype.createServer = function (opts) {\n  return new Server(this, opts);\n};\n\nObject.defineProperty(Service.prototype, 'hash', {\n  enumerable: true,\n  get: function () { return utils.bufferFrom(this._hashStr, 'binary'); }\n});\n\nService.prototype.message = function (name) {\n  return this._messagesByName[name];\n};\n\nService.prototype.type = function (name) {\n  return this._typesByName[name];\n};\n\nService.prototype.inspect = function () {\n  return f('<Service %j>', this.name);\n};\n\n// Deprecated methods.\n\nutils.addDeprecatedGetters(\n  Service,\n  ['message', 'messages', 'name', 'type', 'types']\n);\n\nService.prototype.createEmitter = util.deprecate(\n  function (transport, opts) {\n    opts = opts || {};\n    var client = this.createClient({\n      cache: opts.cache,\n      buffering: false,\n      strictTypes: opts.strictErrors,\n      timeout: opts.timeout\n    });\n    var channel = client.createChannel(transport, opts);\n    forwardErrors(client, channel);\n    return channel;\n  },\n  'use `.createClient()` instead of `.createEmitter()`'\n);\n\nService.prototype.createListener = util.deprecate(\n  function (transport, opts) {\n    if (opts && opts.strictErrors) {\n      throw new Error('use `.createServer()` to support strict errors');\n    }\n    return this._server.createChannel(transport, opts);\n  },\n  'use `.createServer().createChannel()` instead of `.createListener()`'\n);\n\nService.prototype.emit = util.deprecate(\n  function (name, req, channel, cb) {\n    if (!channel || !this.equals(channel.client._svc$)) {\n      throw new Error('invalid emitter');\n    }\n\n    var client = channel.client;\n    // In case the method is overridden.\n    Client.prototype.emitMessage.call(client, name, req, cb && cb.bind(this));\n    return channel.getPending();\n  },\n  'create a client via `.createClient()` to emit messages instead of `.emit()`'\n);\n\nService.prototype.equals = util.deprecate(\n  function (any) {\n    return (\n      Service.isService(any) &&\n      this.getFingerprint().equals(any.getFingerprint())\n    );\n  },\n  'equality testing is deprecated, compare the `.protocol`s instead'\n);\n\nService.prototype.getFingerprint = util.deprecate(\n  function (algorithm) {\n    return utils.getHash(JSON.stringify(this.protocol), algorithm);\n  },\n  'use `.hash` instead of `.getFingerprint()`'\n);\n\nService.prototype.getSchema = util.deprecate(\n  Type.prototype.getSchema,\n  'use `.protocol` instead of `.getSchema()`'\n);\n\nService.prototype.on = util.deprecate(\n  function (name, handler) {\n    var self = this; // This protocol.\n    this._server.onMessage(name, function (req, cb) {\n      return handler.call(self, req, this.channel, cb);\n    });\n    return this;\n  },\n  'use `.createServer().onMessage()` instead of `.on()`'\n);\n\nService.prototype.subprotocol = util.deprecate(\n  function () {\n    var parent = this._server;\n    var opts = {strictTypes: parent._strict, cache: parent._cache};\n    var server = new Server(parent.service, opts);\n    server._handlers = Object.create(parent._handlers);\n    return new Service(\n      this.name,\n      this._messagesByName,\n      this._typesByName,\n      this.protocol,\n      server\n    );\n  },\n  '`.subprotocol()` will be removed in 5.1'\n);\n\nService.prototype._attrs = function (opts) {\n  var ptcl = {protocol: this.name};\n\n  var types = [];\n  this.types.forEach(function (t) {\n    if (t.getName() === undefined) {\n      // Don't include any unnamed types (e.g. primitives).\n      return;\n    }\n    var typeSchema = t._attrs(opts);\n    if (typeof typeSchema != 'string') {\n      // Some of the named types might already have been defined in a\n      // previous type, in this case we don't include its reference.\n      types.push(typeSchema);\n    }\n  });\n  if (types.length) {\n    ptcl.types = types;\n  }\n\n  var msgNames = Object.keys(this._messagesByName);\n  if (msgNames.length) {\n    ptcl.messages = {};\n    msgNames.forEach(function (name) {\n      ptcl.messages[name] = this._messagesByName[name]._attrs(opts);\n    }, this);\n  }\n\n  if (opts && opts.exportAttrs && this.doc !== undefined) {\n    ptcl.doc = this.doc;\n  }\n  return ptcl;\n};\n\n/** Function to retrieve a remote service's protocol. */\nfunction discoverProtocol(transport, opts, cb) {\n  if (cb === undefined && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n\n  var svc = new Service({protocol: 'Empty'}, OPTS);\n  var ptclStr;\n  svc.createClient({timeout: opts && opts.timeout})\n    .createChannel(transport, {\n      scope: opts && opts.scope,\n      endWritable: typeof transport == 'function' // Stateless transports only.\n    }).once('handshake', function (hreq, hres) {\n        ptclStr = hres.serverProtocol;\n        this.destroy(true);\n      })\n      .once('eot', function (pending, err) {\n        // Stateless transports will throw an interrupted error when the\n        // channel is destroyed, we ignore it here.\n        if (err && !/interrupted/.test(err)) {\n          cb(err); // Likely timeout.\n        } else {\n          cb(null, JSON.parse(ptclStr));\n        }\n      });\n}\n\n/** Load-balanced message sender. */\nfunction Client(svc, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  // We have to suffix all client properties to be safe, since the message\n  // names aren't prefixed with clients (unlike servers).\n  this._svc$ = svc;\n  this._channels$ = []; // Active channels.\n  this._fns$ = []; // Middleware functions.\n\n  this._buffering$ = !!opts.buffering;\n  this._cache$ = opts.cache || {}; // For backwards compatibility.\n  this._policy$ = opts.channelPolicy;\n  this._strict$ = !!opts.strictTypes;\n  this._timeout$ = utils.getOption(opts, 'timeout', 10000);\n\n  if (opts.remoteProtocols) {\n    insertRemoteProtocols(this._cache$, opts.remoteProtocols, svc, true);\n  }\n\n  this._svc$.messages.forEach(function (msg) {\n    this[msg.name] = this._createMessageHandler$(msg);\n  }, this);\n}\nutil.inherits(Client, events.EventEmitter);\n\nClient.prototype.activeChannels = function () {\n  return this._channels$.slice();\n};\n\nClient.prototype.createChannel = function (transport, opts) {\n  var objectMode = opts && opts.objectMode;\n  var channel;\n  if (typeof transport == 'function') {\n    var writableFactory;\n    if (objectMode) {\n      writableFactory = transport;\n    } else {\n      // We provide a default standard-compliant codec. This should support\n      // most use-cases (for example when speaking to the official Java and\n      // Python implementations over HTTP, or when this library is used for\n      // both the emitting and listening sides).\n      writableFactory = function (cb) {\n        var encoder = new FrameEncoder();\n        var writable = transport(function (err, readable) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          // Since the decoder isn't exposed (so can't have an error handler\n          // attached, we forward any errors to the client). Since errors would\n          // only get thrown when the decoder flushes (if there is trailing\n          // data), at which point the source will have ended, there is no need\n          // to add re-piping logic (destination errors trigger an unpipe).\n          var decoder = new FrameDecoder()\n            .once('error', function (err) { channel.destroy(err); });\n          cb(null, readable.pipe(decoder));\n        });\n        if (writable) {\n          encoder.pipe(writable);\n          return encoder;\n        }\n      };\n    }\n    channel = new StatelessClientChannel(this, writableFactory, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    if (!objectMode) {\n      // To ease communication with Java servers, we provide a default codec\n      // compatible with Java servers' `NettyTransportCodec`'s implementation.\n      var decoder = new NettyDecoder();\n      readable = readable.pipe(decoder);\n      var encoder = new NettyEncoder();\n      encoder.pipe(writable);\n      writable = encoder;\n    }\n    channel = new StatefulClientChannel(this, readable, writable, opts);\n    if (!objectMode) {\n      // Since we never expose the automatically created encoder and decoder,\n      // we release them ourselves here when the channel ends. (Unlike for\n      // stateless channels, it is conceivable for the underlying stream to be\n      // reused afterwards).\n      channel.once('eot', function () {\n        readable.unpipe(decoder);\n        encoder.unpipe(writable);\n      });\n      // We also forward any (trailing data) error.\n      decoder.once('error', function (err) { channel.destroy(err); });\n    }\n  }\n  var channels = this._channels$;\n  channels.push(channel);\n  channel.once('_drain', function () {\n    // Remove the channel from the list of active ones.\n    channels.splice(channels.indexOf(this), 1);\n  });\n  // We restrict buffering to startup, otherwise we risk silently hiding errors\n  // (especially since channel timeouts don't apply yet).\n  this._buffering$ = false;\n  this.emit('channel', channel);\n  return channel;\n};\n\nClient.prototype.destroyChannels = function (opts) {\n  this._channels$.forEach(function (channel) {\n    channel.destroy(opts && opts.noWait);\n  });\n};\n\nClient.prototype.emitMessage = function (name, req, opts, cb) {\n  var msg = getExistingMessage(this._svc$, name);\n  var wreq = new WrappedRequest(msg, {}, req);\n  this._emitMessage$(wreq, opts, cb);\n};\n\nClient.prototype.remoteProtocols = function () {\n  return getRemoteProtocols(this._cache$, true);\n};\n\nObject.defineProperty(Client.prototype, 'service', {\n  enumerable: true,\n  get: function () { return this._svc$; }\n});\n\nClient.prototype.use = function (/* fn ... */) {\n  var i, l, fn;\n  for (i = 0, l = arguments.length; i < l; i++) {\n    fn = arguments[i];\n    this._fns$.push(fn.length < 3 ? fn(this) : fn);\n  }\n  return this;\n};\n\nClient.prototype._emitMessage$ = function (wreq, opts, cb) {\n  // Common logic between `client.emitMessage` and the \"named\" message methods.\n  if (!cb && typeof opts === 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  var self = this;\n  var channels = this._channels$;\n  var numChannels = channels.length;\n  if (!numChannels) {\n    if (this._buffering$) {\n      debug('no active client channels, buffering call');\n      this.once('channel', function () {\n        this._emitMessage$(wreq, opts, cb);\n      });\n    } else {\n      var err = new Error('no active channels');\n      process.nextTick(function () {\n        if (cb) {\n          cb.call(new CallContext(wreq._msg), err);\n        } else {\n          self.emit('error', err);\n        }\n      });\n    }\n    return;\n  }\n\n  opts = opts || {};\n  if (opts.timeout === undefined) {\n    opts.timeout = this._timeout$;\n  }\n\n  var channel;\n  if (numChannels === 1) {\n    // Common case, optimized away.\n    channel = channels[0];\n  } else if (this._policy$) {\n    channel = this._policy$(this._channels$.slice());\n    if (!channel) {\n      debug('policy returned no channel, skipping call');\n      return;\n    }\n  } else {\n    // Random selection, cheap and likely good enough for most use-cases.\n    channel = channels[Math.floor(Math.random() * numChannels)];\n  }\n\n  channel._emit(wreq, opts, function (err, wres) {\n    var ctx = this; // Call context.\n    var errType = ctx.message.errorType;\n    if (err) {\n      // System error, likely the message wasn't sent (or an error occurred\n      // while decoding the response).\n      if (self._strict$) {\n        err = errType.clone(err.message, {wrapUnions: true});\n      }\n      done(err);\n      return;\n    }\n    if (!wres) {\n      // This is a one way message.\n      done();\n      return;\n    }\n    // Message transmission succeeded, we transmit the message data; massaging\n    // any error strings into actual `Error` objects in non-strict mode.\n    err = wres.error;\n    if (!self._strict$) {\n      // Try to coerce an eventual error into more idiomatic JavaScript types:\n      // `undefined` becomes `null` and a remote string \"system\" error is\n      // wrapped inside an actual `Error` object.\n      if (err === undefined) {\n        err = null;\n      } else {\n        if (Type.isType(errType, 'union:unwrapped')) {\n          if (typeof err == 'string') {\n            err = new Error(err);\n          }\n        } else if (err && err.string && typeof err.string == 'string') {\n          err = new Error(err.string);\n        }\n      }\n    }\n    done(err, wres.response);\n\n    function done(err, res) {\n      if (cb) {\n        cb.call(ctx, err, res);\n      } else if (err) {\n        self.emit('error', err);\n      }\n    }\n  });\n};\n\nClient.prototype._createMessageHandler$ = function (msg) {\n  // jshint -W054\n  var fields = msg.requestType.getFields();\n  var names = fields.map(function (f) { return f.getName(); });\n  var body = 'return function ' + msg.name + '(';\n  if (names.length) {\n    body += names.join(', ') + ', ';\n  }\n  body += 'opts, cb) {\\n';\n  body += '  var req = {';\n  body += names.map(function (n) { return n + ': ' + n; }).join(', ');\n  body += '};\\n';\n  body += '  return this.emitMessage(\\'' + msg.name + '\\', req, opts, cb);\\n';\n  body += '};';\n  return (new Function(body))();\n};\n\n/** Message receiver. */\nfunction Server(svc, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.service = svc;\n  this._handlers = {};\n  this._fns = []; // Middleware functions.\n  this._channels = {}; // Active channels.\n  this._nextChannelId = 1;\n\n  this._cache = opts.cache || {}; // Deprecated.\n  this._defaultHandler = opts.defaultHandler;\n  this._sysErrFormatter = opts.systemErrorFormatter;\n  this._silent = !!opts.silent;\n  this._strict = !!opts.strictTypes;\n\n  if (opts.remoteProtocols) {\n    insertRemoteProtocols(this._cache, opts.remoteProtocols, svc, false);\n  }\n\n  svc.messages.forEach(function (msg) {\n    var name = msg.name;\n    if (!opts.noCapitalize) {\n      name = utils.capitalize(name);\n    }\n    this['on' + name] = this._createMessageHandler(msg);\n  }, this);\n}\nutil.inherits(Server, events.EventEmitter);\n\nServer.prototype.activeChannels = function () {\n  return utils.objectValues(this._channels);\n};\n\nServer.prototype.createChannel = function (transport, opts) {\n  var objectMode = opts && opts.objectMode;\n  var channel;\n  if (typeof transport == 'function') {\n    var readableFactory;\n    if (objectMode) {\n      readableFactory = transport;\n    } else {\n      readableFactory = function (cb) {\n        var decoder = new FrameDecoder()\n          .once('error', function (err) { channel.destroy(err); });\n        return transport(function (err, writable) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          var encoder = new FrameEncoder();\n          encoder.pipe(writable);\n          cb(null, encoder);\n        }).pipe(decoder);\n      };\n    }\n    channel = new StatelessServerChannel(this, readableFactory, opts);\n  } else {\n    var readable, writable;\n    if (isStream(transport)) {\n      readable = writable = transport;\n    } else {\n      readable = transport.readable;\n      writable = transport.writable;\n    }\n    if (!objectMode) {\n      var decoder = new NettyDecoder();\n      readable = readable.pipe(decoder);\n      var encoder = new NettyEncoder();\n      encoder.pipe(writable);\n      writable = encoder;\n    }\n    channel = new StatefulServerChannel(this, readable, writable, opts);\n    if (!objectMode) {\n      // Similar to client channels, since we never expose the encoder and\n      // decoder, we must release them ourselves here.\n      channel.once('eot', function () {\n        readable.unpipe(decoder);\n        encoder.unpipe(writable);\n      });\n      decoder.once('error', function (err) { channel.destroy(err); });\n    }\n  }\n\n  if (!this.listeners('error').length) {\n    this.on('error', this._onError);\n  }\n  var channelId = this._nextChannelId++;\n  var channels = this._channels;\n  channels[channelId] = channel\n    .once('eot', function () { delete channels[channelId]; });\n  this.emit('channel', channel);\n  return channel;\n};\n\nServer.prototype.onMessage = function (name, handler) {\n  getExistingMessage(this.service, name); // Check message existence.\n  this._handlers[name] = handler;\n  return this;\n};\n\nServer.prototype.remoteProtocols = function () {\n  return getRemoteProtocols(this._cache, false);\n};\n\nServer.prototype.use = function (/* fn ... */) {\n  var i, l, fn;\n  for (i = 0, l = arguments.length; i < l; i++) {\n    fn = arguments[i];\n    this._fns.push(fn.length < 3 ? fn(this) : fn);\n  }\n  return this;\n};\n\nServer.prototype._createMessageHandler = function (msg) {\n  // jshint -W054\n  var name = msg.name;\n  var fields = msg.requestType.fields;\n  var numArgs = fields.length;\n  var args = fields.length ?\n    ', ' + fields.map(function (f) { return 'req.' + f.name; }).join(', ') :\n    '';\n  // We are careful to not lose the initial handler's number of arguments (or\n  // more specifically whether it would have access to the callback or not).\n  // This is useful to implement \"smart promisification\" logic downstream.\n  var body = 'return function (handler) {\\n';\n  body += '  if (handler.length > ' + numArgs + ') {\\n';\n  body += '    return this.onMessage(\\'' + name + '\\', function (req, cb) {\\n';\n  body += '      return handler.call(this' + args + ', cb);\\n';\n  body += '    });\\n';\n  body += '  } else {\\n';\n  body += '    return this.onMessage(\\'' + name + '\\', function (req) {\\n';\n  body += '      return handler.call(this' + args + ');\\n';\n  body += '    });\\n';\n  body += '  }\\n';\n  body += '};\\n';\n  return (new Function(body))();\n};\n\nServer.prototype._onError = function (err) {\n  /* istanbul ignore if */\n  if (!this._silent && err.rpcCode !== 'UNKNOWN_PROTOCOL') {\n    console.error();\n    if (err.rpcCode) {\n      console.error(err.rpcCode);\n      console.error(err.cause);\n    } else {\n      console.error('INTERNAL_SERVER_ERROR');\n      console.error(err);\n    }\n  }\n};\n\n/** Base message emitter class. See below for the two available variants. */\nfunction ClientChannel(client, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.client = client;\n  this.timeout = utils.getOption(opts, 'timeout', client._timeout$);\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._prefix = normalizedPrefix(opts.scope);\n\n  var cache = client._cache$;\n  var clientSvc = client._svc$;\n  var hash = opts.serverHash;\n  if (!hash) {\n    hash = clientSvc.hash;\n  }\n  var adapter = cache[hash];\n  if (!adapter) {\n    // This might happen even if the server hash option was set if the cache\n    // doesn't contain the corresponding adapter. In this case we fall back to\n    // the client's protocol (as mandated by the spec).\n    hash = clientSvc.hash;\n    adapter = cache[hash] = new Adapter(clientSvc, clientSvc, hash);\n  }\n  this._adapter = adapter;\n\n  this._registry = new Registry(this, PREFIX_LENGTH);\n  this.pending = 0;\n  this.destroyed = false;\n  this.draining = false;\n  this.once('_eot', function (pending, err) {\n    // Since this listener is only run once, we will only forward an error if\n    // it is present during the initial `destroy` call, which is OK.\n    debug('client channel EOT');\n    this.destroyed = true;\n    this.emit('eot', pending, err);\n  });\n}\nutil.inherits(ClientChannel, events.EventEmitter);\n\nClientChannel.prototype.destroy = function (noWait) {\n  debug('destroying client channel');\n  if (!this.draining) {\n    this.draining = true;\n    this.emit('_drain');\n  }\n  var registry = this._registry;\n  var pending = this.pending;\n  if (noWait) {\n    registry.clear();\n  }\n  if (noWait || !pending) {\n    if (isError(noWait)) {\n      debug('fatal client channel error: %s', noWait);\n      this.emit('_eot', pending, noWait);\n    } else {\n      this.emit('_eot', pending);\n    }\n  } else {\n    debug('client channel entering drain mode (%s pending)', pending);\n  }\n};\n\nClientChannel.prototype.ping = function (timeout, cb) {\n  if (!cb && typeof timeout == 'function') {\n    cb = timeout;\n    timeout = undefined;\n  }\n  var self = this;\n  var wreq = new WrappedRequest(PING_MESSAGE);\n  this._emit(wreq, {timeout: timeout}, function (err) {\n    if (cb) {\n      cb.call(self, err);\n    } else if (err) {\n      self.destroy(err);\n    }\n  });\n};\n\nClientChannel.prototype._createHandshakeRequest = function (adapter, noSvc) {\n  var svc = this.client._svc$;\n  return {\n    clientHash: svc.hash,\n    clientProtocol: noSvc ? null : JSON.stringify(svc.protocol),\n    serverHash: adapter._hash\n  };\n};\n\nClientChannel.prototype._emit = function (wreq, opts, cb) {\n  var msg = wreq._msg;\n  var wres = msg.oneWay ? undefined : new WrappedResponse(msg, {});\n  var ctx = new CallContext(msg, this);\n  var self = this;\n  this.pending++;\n  process.nextTick(function () {\n    if (!msg.name) {\n      // Ping request, bypass middleware.\n      onTransition(wreq, wres, onCompletion);\n    } else {\n      self.emit('outgoingCall', ctx, opts);\n      var fns = self.client._fns$;\n      debug('starting client middleware chain (%s middleware)', fns.length);\n      chainMiddleware({\n        fns: fns,\n        ctx: ctx,\n        wreq: wreq,\n        wres: wres,\n        onTransition: onTransition,\n        onCompletion: onCompletion,\n        onError: onError\n      });\n    }\n  });\n\n  function onTransition(wreq, wres, prev) {\n    // Serialize the message.\n    var err, reqBuf;\n    if (self.destroyed) {\n      err = new Error('channel destroyed');\n    } else {\n      try {\n        reqBuf = wreq.toBuffer();\n      } catch (cause) {\n        err = serializationError(\n          f('invalid %j request', msg.name),\n          wreq,\n          [\n            {name: 'headers', type: MAP_BYTES_TYPE},\n            {name: 'request', type: msg.requestType}\n          ]\n        );\n      }\n    }\n    if (err) {\n      prev(err);\n      return;\n    }\n\n    // Generate the response callback.\n    var timeout = (opts && opts.timeout !== undefined) ?\n      opts.timeout :\n      self.timeout;\n    var id = self._registry.add(timeout, function (err, resBuf, adapter) {\n      if (!err && !msg.oneWay) {\n        try {\n          adapter._decodeResponse(resBuf, wres, msg);\n        } catch (cause) {\n          err = cause;\n        }\n      }\n      prev(err);\n    });\n    id |= self._prefix;\n\n    debug('sending message %s', id);\n    self._send(id, reqBuf, !!msg && msg.oneWay);\n  }\n\n  function onCompletion(err) {\n    self.pending--;\n    cb.call(ctx, err, wres);\n    if (self.draining && !self.destroyed && !self.pending) {\n      self.destroy();\n    }\n  }\n\n  function onError(err) {\n    // This will happen if a middleware callback is called multiple times. We\n    // forward the error to the client rather than emit it on the channel since\n    // middleware are a client-level abstraction, so better handled there.\n    self.client.emit('error', err, self);\n  }\n};\n\nClientChannel.prototype._getAdapter = function (hres) {\n  var hash = hres.serverHash;\n  var cache = this.client._cache$;\n  var adapter = cache[hash];\n  if (adapter) {\n    return adapter;\n  }\n  var ptcl = JSON.parse(hres.serverProtocol);\n  var serverSvc = Service.forProtocol(ptcl);\n  adapter = new Adapter(this.client._svc$, serverSvc, hash, true);\n  return cache[hash] = adapter;\n};\n\nClientChannel.prototype._matchesPrefix = function (id) {\n  return matchesPrefix(id, this._prefix);\n};\n\nClientChannel.prototype._send = utils.abstractFunction;\n\n// Deprecated.\n\nutils.addDeprecatedGetters(ClientChannel, ['pending', 'timeout']);\n\nClientChannel.prototype.getCache = util.deprecate(\n  function () { return this.client._cache$; },\n  'use `.remoteProtocols()` instead of `.getCache()`'\n);\n\nClientChannel.prototype.getProtocol = util.deprecate(\n  function () {\n    return this.client._svc$;\n  },\n  'use `.service` instead or `.getProtocol()`'\n);\n\nClientChannel.prototype.isDestroyed = util.deprecate(\n  function () { return this.destroyed; },\n  'use `.destroyed` instead of `.isDestroyed`'\n);\n\n/**\n * Factory-based client channel.\n *\n * This channel doesn't keep a persistent connection to the server and requires\n * prepending a handshake to each message emitted. Usage examples include\n * talking to an HTTP server (where the factory returns an HTTP request).\n *\n * Since each message will use its own writable/readable stream pair, the\n * advantage of this channel is that it is able to keep track of which response\n * corresponds to each request without relying on transport ordering. In\n * particular, this means these channels are compatible with any server\n * implementation.\n */\nfunction StatelessClientChannel(client, writableFactory, opts) {\n  ClientChannel.call(this, client, opts);\n  this._writableFactory = writableFactory;\n\n  if (!opts || !opts.noPing) {\n    // Ping the server to check whether the remote protocol is compatible.\n    // If not, this will throw an error on the channel.\n    debug('emitting ping request');\n    this.ping();\n  }\n}\nutil.inherits(StatelessClientChannel, ClientChannel);\n\nStatelessClientChannel.prototype._send = function (id, reqBuf) {\n  var cb = this._registry.get(id);\n  var adapter = this._adapter;\n  var self = this;\n  process.nextTick(emit);\n  return true;\n\n  function emit(retry) {\n    if (self.destroyed) {\n      // The request's callback will already have been called.\n      return;\n    }\n\n    var hreq = self._createHandshakeRequest(adapter, !retry);\n\n    var writable = self._writableFactory.call(self, function (err, readable) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      readable.on('data', function (obj) {\n        debug('received response %s', obj.id);\n        // We don't check that the prefix matches since the ID likely hasn't\n        // been propagated to the response (see default stateless codec).\n        var buf = Buffer.concat(obj.payload);\n        try {\n          var parts = readHead(HANDSHAKE_RESPONSE_TYPE, buf);\n          var hres = parts.head;\n          if (hres.serverHash) {\n            adapter = self._getAdapter(hres);\n          }\n        } catch (cause) {\n          cb(cause);\n          return;\n        }\n        var match = hres.match;\n        debug('handshake match: %s', match);\n        self.emit('handshake', hreq, hres);\n        if (match === 'NONE') {\n          // Try again, including the full protocol this time.\n          process.nextTick(function() { emit(true); });\n        } else {\n          // Change the default adapter.\n          self._adapter = adapter;\n          cb(null, parts.tail, adapter);\n        }\n      });\n    });\n    if (!writable) {\n      cb(new Error('invalid writable stream'));\n      return;\n    }\n    writable.write({\n      id: id,\n      payload: [HANDSHAKE_REQUEST_TYPE.toBuffer(hreq), reqBuf]\n    });\n    if (self._endWritable) {\n      writable.end();\n    }\n  }\n};\n\n/**\n * Multiplexing client channel.\n *\n * These channels reuse the same streams (both readable and writable) for all\n * messages. This avoids a lot of overhead (e.g. creating new connections,\n * re-issuing handshakes) but requires the underlying transport to support\n * forwarding message IDs.\n */\nfunction StatefulClientChannel(client, readable, writable, opts) {\n  ClientChannel.call(this, client, opts);\n  this._readable = readable;\n  this._writable = writable;\n  this._connected = !!(opts && opts.noPing);\n  this._readable.on('end', onEnd);\n  this._writable.on('finish', onFinish);\n\n  var self = this;\n  var timer = null;\n  this.once('eot', function () {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    if (!self._connected) {\n      // Clear any buffered calls (they are guaranteed to error out when\n      // reaching the transition phase).\n      self.emit('_ready');\n    }\n    // Remove references to this channel to avoid potential memory leaks.\n    this._writable.removeListener('finish', onFinish);\n    if (this._endWritable) {\n      debug('ending transport');\n      this._writable.end();\n    }\n    this._readable\n      .removeListener('data', onPing)\n      .removeListener('data', onMessage)\n      .removeListener('end', onEnd);\n  });\n\n  var hreq; // For handshake events.\n  if (this._connected) {\n    this._readable.on('data', onMessage);\n  } else {\n    this._readable.on('data', onPing);\n    process.nextTick(ping);\n    if (self.timeout) {\n      timer = setTimeout(function () {\n        self.destroy(new Error('timeout'));\n      }, self.timeout);\n    }\n  }\n\n  function ping(retry) {\n    if (self.destroyed) {\n      return;\n    }\n    hreq = self._createHandshakeRequest(self._adapter, !retry);\n    var payload = [\n      HANDSHAKE_REQUEST_TYPE.toBuffer(hreq),\n      utils.bufferFrom([0, 0]) // No header, no data (empty message name).\n    ];\n    // We can use a static ID here since we are guaranteed that this message is\n    // the only one on the channel (for this scope at least).\n    self._writable.write({id: self._prefix, payload: payload});\n  }\n\n  function onPing(obj) {\n    if (!self._matchesPrefix(obj.id)) {\n      debug('discarding unscoped response %s (still connecting)', obj.id);\n      return;\n    }\n    var buf = Buffer.concat(obj.payload);\n    try {\n      var hres = readHead(HANDSHAKE_RESPONSE_TYPE, buf).head;\n      if (hres.serverHash) {\n        self._adapter = self._getAdapter(hres);\n      }\n    } catch (cause) {\n      // This isn't a recoverable error.\n      self.destroy(cause);\n      return;\n    }\n    var match = hres.match;\n    debug('handshake match: %s', match);\n    self.emit('handshake', hreq, hres);\n    if (match === 'NONE') {\n      process.nextTick(function () { ping(true); });\n    } else {\n      debug('successfully connected');\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      self._readable.removeListener('data', onPing).on('data', onMessage);\n      self._connected = true;\n      self.emit('_ready');\n      hreq = null; // Release reference.\n    }\n  }\n\n  // Callback used after a connection has been established.\n  function onMessage(obj) {\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      debug('discarding unscoped message %s', id);\n      return;\n    }\n    var cb = self._registry.get(id);\n    if (cb) {\n      process.nextTick(function () {\n        debug('received message %s', id);\n        // Ensure that the initial callback gets called asynchronously, even\n        // for completely synchronous transports (otherwise the number of\n        // pending requests will sometimes be inconsistent between stateful and\n        // stateless transports).\n        cb(null, Buffer.concat(obj.payload), self._adapter);\n      });\n    }\n  }\n\n  function onEnd() { self.destroy(true); }\n  function onFinish() { self.destroy(); }\n}\nutil.inherits(StatefulClientChannel, ClientChannel);\n\nStatefulClientChannel.prototype._emit = function () {\n  // Override this method to allow calling `_emit` even before the channel is\n  // connected. Note that we don't perform this logic in `_send` since we want\n  // to guarantee that `'handshake'` events are emitted before any\n  // `'outgoingCall'` events.\n  if (this._connected || this.draining) {\n    ClientChannel.prototype._emit.apply(this, arguments);\n  } else {\n    debug('queuing request');\n    var args = [];\n    var i, l;\n    for (i = 0, l = arguments.length; i < l; i++) {\n      args.push(arguments[i]);\n    }\n    this.once('_ready', function () { this._emit.apply(this, args); });\n  }\n};\n\nStatefulClientChannel.prototype._send = function (id, reqBuf, oneWay) {\n  if (oneWay) {\n    var self = this;\n    // Clear the callback, passing in an empty header.\n    process.nextTick(function () {\n      self._registry.get(id)(null, utils.bufferFrom([0, 0, 0]), self._adapter);\n    });\n  }\n  return this._writable.write({id: id, payload: [reqBuf]});\n};\n\n/** The server-side emitter equivalent. */\nfunction ServerChannel(server, opts) {\n  opts = opts || {};\n  events.EventEmitter.call(this);\n\n  this.server = server;\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\n  this._prefix = normalizedPrefix(opts.scope);\n\n  var cache = server._cache;\n  var svc = server.service;\n  var hash = svc.hash;\n  if (!cache[hash]) {\n    // Add the channel's protocol to the cache if it isn't already there. This\n    // will save a handshake the first time on channels with the same protocol.\n    cache[hash] = new Adapter(svc, svc, hash);\n  }\n  this._adapter = null;\n\n  this.destroyed = false;\n  this.draining = false;\n  this.pending = 0;\n  this.once('_eot', function (pending, err) {\n    debug('server channel EOT');\n    this.emit('eot', pending, err);\n  });\n}\nutil.inherits(ServerChannel, events.EventEmitter);\n\nServerChannel.prototype.destroy = function (noWait) {\n  if (!this.draining) {\n    this.draining = true;\n    this.emit('_drain');\n  }\n  if (noWait || !this.pending) {\n    this.destroyed = true;\n    if (isError(noWait)) {\n      debug('fatal server channel error: %s', noWait);\n      this.emit('_eot', this.pending, noWait);\n    } else {\n      this.emit('_eot', this.pending);\n    }\n  }\n};\n\nServerChannel.prototype._createHandshakeResponse = function (err, hreq) {\n  var svc = this.server.service;\n  var buf = svc.hash;\n  var serverMatch = hreq && hreq.serverHash.equals(buf);\n  return {\n    match: err ? 'NONE' : (serverMatch ? 'BOTH' : 'CLIENT'),\n    serverProtocol: serverMatch ? null : JSON.stringify(svc.protocol),\n    serverHash: serverMatch ? null : buf\n  };\n};\n\nServerChannel.prototype._getAdapter = function (hreq) {\n  var hash = hreq.clientHash;\n  var adapter = this.server._cache[hash];\n  if (adapter) {\n    return adapter;\n  }\n  if (!hreq.clientProtocol) {\n    throw toRpcError('UNKNOWN_PROTOCOL');\n  }\n  var ptcl = JSON.parse(hreq.clientProtocol);\n  var clientSvc = Service.forProtocol(ptcl);\n  adapter = new Adapter(clientSvc, this.server.service, hash, true);\n  return this.server._cache[hash] = adapter;\n};\n\nServerChannel.prototype._matchesPrefix = function (id) {\n  return matchesPrefix(id, this._prefix);\n};\n\nServerChannel.prototype._receive = function (reqBuf, adapter, cb) {\n  var self = this;\n  var wreq;\n  try {\n    wreq = adapter._decodeRequest(reqBuf);\n  } catch (cause) {\n    cb(self._encodeSystemError(toRpcError('INVALID_REQUEST', cause)));\n    return;\n  }\n\n  var msg = wreq._msg;\n  var wres = new WrappedResponse(msg, {});\n  if (!msg.name) {\n    // Ping message, we don't invoke middleware logic in this case.\n    wres.response = null;\n    cb(wres.toBuffer(), false);\n    return;\n  }\n\n  var ctx = new CallContext(msg, this);\n  self.emit('incomingCall', ctx);\n  var fns = this.server._fns;\n  debug('starting server middleware chain (%s middleware)', fns.length);\n  self.pending++;\n  chainMiddleware({\n    fns: fns,\n    ctx: ctx,\n    wreq: wreq,\n    wres: wres,\n    onTransition: onTransition,\n    onCompletion: onCompletion,\n    onError: onError\n  });\n\n  function onTransition(wreq, wres, prev) {\n    var handler = self.server._handlers[msg.name];\n    if (!handler) {\n      // The underlying service hasn't implemented a handler.\n      var defaultHandler = self.server._defaultHandler;\n      if (defaultHandler) {\n        // We call the default handler with arguments similar (slightly\n        // simpler, there are no phases here) to middleware such that it can\n        // easily access the message name (useful to implement proxies).\n        defaultHandler.call(ctx, wreq, wres, prev);\n      } else {\n        var cause = new Error(f('no handler for %s', msg.name));\n        prev(toRpcError('NOT_IMPLEMENTED', cause));\n      }\n    } else {\n      var pending = !msg.oneWay;\n      try {\n        if (pending) {\n          handler.call(ctx, wreq.request, function (err, res) {\n            pending = false;\n            wres.error = err;\n            wres.response = res;\n            prev();\n          });\n        } else {\n          handler.call(ctx, wreq.request);\n          prev();\n        }\n      } catch (err) {\n        // We catch synchronous failures (same as express) and return the\n        // failure. Note that the server process can still crash if an error\n        // is thrown after the handler returns but before the response is\n        // sent (again, same as express). We are careful to only trigger the\n        // response callback once, emitting the errors afterwards instead.\n        if (pending) {\n          pending = false;\n          prev(err);\n        } else {\n          onError(err);\n        }\n      }\n    }\n  }\n\n  function onCompletion(err) {\n    self.pending--;\n    var server = self.server;\n    var resBuf;\n    if (!err) {\n      var resErr = wres.error;\n      var isStrict = server._strict;\n      if (!isStrict) {\n        if (isError(resErr)) {\n          // If the error type is wrapped, we must wrap the error too.\n          wres.error = msg.errorType.clone(resErr.message, {wrapUnions: true});\n        } else if (resErr === null) {\n          // We also allow `null`'s as error in this mode, converting them to\n          // the Avro-compatible `undefined`.\n          resErr = wres.error = undefined;\n        }\n        if (\n          resErr === undefined &&\n          wres.response === undefined &&\n          msg.responseType.isValid(null)\n        ) {\n          // Finally, for messages with `null` as acceptable response type, we\n          // allow `undefined`; converting them to `null`. This allows users to\n          // write a more natural `cb()` instead of `cb(null, null)`.\n          wres.response = null;\n        }\n      }\n      try {\n        resBuf = wres.toBuffer();\n      } catch (cause) {\n        // Note that we don't add an RPC code here such that the client\n        // receives the default `INTERNAL_SERVER_ERROR` one.\n        if (wres.error !== undefined) {\n          err = serializationError(\n            f('invalid %j error', msg.name), // Sic.\n            wres,\n            [\n              {name: 'headers', type: MAP_BYTES_TYPE},\n              {name: 'error', type: msg.errorType}\n            ]\n          );\n        } else {\n          err = serializationError(\n            f('invalid %j response', msg.name),\n            wres,\n            [\n              {name: 'headers', type: MAP_BYTES_TYPE},\n              {name: 'response', type: msg.responseType}\n            ]\n          );\n        }\n      }\n    }\n    if (!resBuf) {\n      // The headers are only available if the message isn't one-way.\n      resBuf = self._encodeSystemError(err, wres.headers);\n    } else if (resErr !== undefined) {\n      server.emit('error', toRpcError('APPLICATION_ERROR', resErr));\n    }\n    cb(resBuf, msg.oneWay);\n    if (self.draining && !self.pending) {\n      self.destroy();\n    }\n  }\n\n  function onError(err) {\n    // Similar to the client equivalent, we redirect this error to the server\n    // since middleware are defined at server-level.\n    self.server.emit('error', err, self);\n  }\n};\n\n// Deprecated.\n\nutils.addDeprecatedGetters(ServerChannel, ['pending']);\n\nServerChannel.prototype.getCache = util.deprecate(\n  function () { return this.server._cache; },\n  'use `.remoteProtocols()` instead of `.getCache()`'\n);\n\nServerChannel.prototype.getProtocol = util.deprecate(\n  function () {\n    return this.server.service;\n  },\n  'use `.service` instead of `.getProtocol()`'\n);\n\nServerChannel.prototype.isDestroyed = util.deprecate(\n  function () { return this.destroyed; },\n  'use `.destroyed` instead of `.isDestroyed`'\n);\n\n/**\n * Encode an error and optional header into a valid Avro response.\n *\n * @param err {Error} Error to encode.\n * @param header {Object} Optional response header.\n */\nServerChannel.prototype._encodeSystemError = function (err, header) {\n  var server = this.server;\n  server.emit('error', err, this);\n  var errStr;\n  if (server._sysErrFormatter) {\n    // Format the error into a string to send over the wire.\n    errStr = server._sysErrFormatter.call(this, err);\n  } else if (err.rpcCode) {\n    // By default, only forward the error's message when the RPC code is set\n    // (i.e. when this isn't an internal server error).\n    errStr = err.message;\n  }\n  var hdrBuf;\n  if (header) {\n    try {\n      // Propagate the header if possible.\n      hdrBuf = MAP_BYTES_TYPE.toBuffer(header);\n    } catch (cause) {\n      server.emit('error', cause, this);\n    }\n  }\n  return Buffer.concat([\n    hdrBuf || utils.bufferFrom([0]),\n    utils.bufferFrom([1, 0]), // Error flag and first union index.\n    STRING_TYPE.toBuffer(errStr || 'internal server error')\n  ]);\n};\n\n/**\n * Server channel for stateless transport.\n *\n * This channel expect a handshake to precede each message.\n */\nfunction StatelessServerChannel(server, readableFactory, opts) {\n  ServerChannel.call(this, server, opts);\n\n  this._writable = undefined;\n  var self = this;\n  var readable;\n\n  process.nextTick(function () {\n    // Delay listening to allow handlers to be attached even if the factory is\n    // purely synchronous.\n    readable = readableFactory.call(self, function (err, writable) {\n      process.nextTick(function () {\n        // We delay once more here in case this call is synchronous, to allow\n        // the readable to always be populated first.\n        if (err) {\n          onFinish(err);\n          return;\n        }\n        self._writable = writable.on('finish', onFinish);\n        self.emit('_writable');\n      });\n    }).on('data', onRequest).on('end', onEnd);\n  });\n\n\n  function onRequest(obj) {\n    var id = obj.id;\n    var buf = Buffer.concat(obj.payload);\n    var err;\n    try {\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\n      var hreq = parts.head;\n      var adapter = self._getAdapter(hreq);\n    } catch (cause) {\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\n    }\n\n    var hres = self._createHandshakeResponse(err, hreq);\n    self.emit('handshake', hreq, hres);\n    if (err) {\n      done(self._encodeSystemError(err));\n    } else {\n      self._receive(parts.tail, adapter, done);\n    }\n\n    function done(resBuf) {\n      if (!self.destroyed) {\n        if (!self._writable) {\n          self.once('_writable', function () { done(resBuf); });\n          return;\n        }\n        self._writable.write({\n          id: id,\n          payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\n        });\n      }\n      if (self._writable && self._endWritable) {\n        self._writable.end();\n      }\n    }\n  }\n\n  function onEnd() { self.destroy(); }\n\n  function onFinish(err) {\n    readable\n      .removeListener('data', onRequest)\n      .removeListener('end', onEnd);\n    self.destroy(err || true);\n  }\n}\nutil.inherits(StatelessServerChannel, ServerChannel);\n\n/**\n * Stateful transport listener.\n *\n * A handshake is done when the channel first receives a message, then all\n * messages are sent without.\n */\nfunction StatefulServerChannel(server, readable, writable, opts) {\n  ServerChannel.call(this, server, opts);\n  this._adapter = undefined;\n  this._writable = writable.on('finish', onFinish);\n  this._readable = readable.on('data', onHandshake).on('end', onEnd);\n\n  this\n    .once('_drain', function () {\n      // Stop listening to incoming events.\n      this._readable\n        .removeListener('data', onHandshake)\n        .removeListener('data', onRequest)\n        .removeListener('end', onEnd);\n    })\n    .once('eot', function () {\n      // Clean up any references to the channel on the underlying streams.\n      this._writable.removeListener('finish', onFinish);\n      if (this._endWritable) {\n        this._writable.end();\n      }\n    });\n\n  var self = this;\n\n  function onHandshake(obj) {\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      return;\n    }\n    var buf = Buffer.concat(obj.payload);\n    var err;\n    try {\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\n      var hreq = parts.head;\n      self._adapter = self._getAdapter(hreq);\n    } catch (cause) {\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\n    }\n    var hres = self._createHandshakeResponse(err, hreq);\n    self.emit('handshake', hreq, hres);\n    if (err) {\n      // Either the client's protocol was unknown or it isn't compatible.\n      done(self._encodeSystemError(err));\n    } else {\n      self._readable\n        .removeListener('data', onHandshake)\n        .on('data', onRequest);\n      self._receive(parts.tail, self._adapter, done);\n    }\n\n    function done(resBuf) {\n      if (self.destroyed) {\n        return;\n      }\n      self._writable.write({\n        id: id,\n        payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\n      });\n    }\n  }\n\n  function onRequest(obj) {\n    // These requests are not prefixed with handshakes.\n    var id = obj.id;\n    if (!self._matchesPrefix(id)) {\n      return;\n    }\n    var reqBuf = Buffer.concat(obj.payload);\n    self._receive(reqBuf, self._adapter, function (resBuf, oneWay) {\n      if (self.destroyed || oneWay) {\n        return;\n      }\n      self._writable.write({id: id, payload: [resBuf]});\n    });\n  }\n\n  function onEnd() { self.destroy(); }\n\n  function onFinish() { self.destroy(true); }\n}\nutil.inherits(StatefulServerChannel, ServerChannel);\n\n// Helpers.\n\n/** Enhanced request, used inside forward middleware functions. */\nfunction WrappedRequest(msg, hdrs, req) {\n  this._msg = msg;\n  this.headers = hdrs || {};\n  this.request = req || {};\n}\n\nWrappedRequest.prototype.toBuffer = function () {\n  var msg = this._msg;\n  return Buffer.concat([\n    MAP_BYTES_TYPE.toBuffer(this.headers),\n    STRING_TYPE.toBuffer(msg.name),\n    msg.requestType.toBuffer(this.request)\n  ]);\n};\n\n/** Enhanced response, used inside forward middleware functions. */\nfunction WrappedResponse(msg, hdr, err, res) {\n  this._msg = msg;\n  this.headers = hdr;\n  this.error = err;\n  this.response = res;\n}\n\nWrappedResponse.prototype.toBuffer = function () {\n  var hdr = MAP_BYTES_TYPE.toBuffer(this.headers);\n  var hasError = this.error !== undefined;\n  return Buffer.concat([\n    hdr,\n    BOOLEAN_TYPE.toBuffer(hasError),\n    hasError ?\n      this._msg.errorType.toBuffer(this.error) :\n      this._msg.responseType.toBuffer(this.response)\n  ]);\n};\n\n/**\n * Context for all middleware and handlers.\n *\n * It exposes a `locals` object which can be used to pass information between\n * each other during a given call.\n */\nfunction CallContext(msg, channel) {\n  this.channel = channel;\n  this.locals = {};\n  this.message = msg;\n  Object.freeze(this);\n}\n\n/**\n * Callback registry.\n *\n * Callbacks added must accept an error as first argument. This is used by\n * client channels to store pending calls. This class isn't exposed by the\n * public API.\n */\nfunction Registry(ctx, prefixLength) {\n  this._ctx = ctx; // Context for all callbacks.\n  this._mask = ~0 >>> (prefixLength | 0); // 16 bits by default.\n  this._id = 0; // Unique integer ID for each call.\n  this._n = 0; // Number of pending calls.\n  this._cbs = {};\n}\n\nRegistry.prototype.get = function (id) { return this._cbs[id & this._mask]; };\n\nRegistry.prototype.add = function (timeout, fn) {\n  this._id = (this._id + 1) & this._mask;\n\n  var self = this;\n  var id = this._id;\n  var timer;\n  if (timeout > 0) {\n    timer = setTimeout(function () { cb(new Error('timeout')); }, timeout);\n  }\n\n  this._cbs[id] = cb;\n  this._n++;\n  return id;\n\n  function cb() {\n    if (!self._cbs[id]) {\n      // The callback has already run.\n      return;\n    }\n    delete self._cbs[id];\n    self._n--;\n    if (timer) {\n      clearTimeout(timer);\n    }\n    fn.apply(self._ctx, arguments);\n  }\n};\n\nRegistry.prototype.clear = function () {\n  Object.keys(this._cbs).forEach(function (id) {\n    this._cbs[id](new Error('interrupted'));\n  }, this);\n};\n\n/**\n * Service resolution helper.\n *\n * It is used both by client and server channels, to respectively decode errors\n * and responses, or requests.\n */\nfunction Adapter(clientSvc, serverSvc, hash, isRemote) {\n  this._clientSvc = clientSvc;\n  this._serverSvc = serverSvc;\n  this._hash = hash; // Convenience to access it when creating handshakes.\n  this._isRemote = !!isRemote;\n  this._readers = createReaders(clientSvc, serverSvc);\n}\n\nAdapter.prototype._decodeRequest = function (buf) {\n  var tap = new Tap(buf);\n  var hdr = MAP_BYTES_TYPE._read(tap);\n  var name = STRING_TYPE._read(tap);\n  var msg, req;\n  if (name) {\n    msg = this._serverSvc.message(name);\n    req = this._readers[name + '?']._read(tap);\n  } else {\n    msg = PING_MESSAGE;\n  }\n  if (!tap.isValid()) {\n    throw new Error(f('truncated %s request', name || 'ping$'));\n  }\n  return new WrappedRequest(msg, hdr, req);\n};\n\nAdapter.prototype._decodeResponse = function (buf, wres, msg) {\n  var tap = new Tap(buf);\n  utils.copyOwnProperties(MAP_BYTES_TYPE._read(tap), wres.headers, true);\n  var isError = BOOLEAN_TYPE._read(tap);\n  var name = msg.name;\n  if (name) {\n    var reader = this._readers[name + (isError ? '*' : '!')];\n    msg = this._clientSvc.message(name);\n    if (isError) {\n      wres.error = reader._read(tap);\n    } else {\n      wres.response = reader._read(tap);\n    }\n    if (!tap.isValid()) {\n      throw new Error(f('truncated %s response', name));\n    }\n  } else {\n    msg = PING_MESSAGE;\n  }\n};\n\n/** Standard \"un-framing\" stream. */\nfunction FrameDecoder() {\n  stream.Transform.call(this, {readableObjectMode: true});\n  this._id = undefined;\n  this._buf = utils.newBuffer(0);\n  this._bufs = [];\n\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(FrameDecoder, stream.Transform);\n\nFrameDecoder.prototype._transform = function (buf, encoding, cb) {\n  buf = Buffer.concat([this._buf, buf]);\n  var frameLength;\n  while (\n    buf.length >= 4 &&\n    buf.length >= (frameLength = buf.readInt32BE(0)) + 4\n  ) {\n    if (frameLength) {\n      this._bufs.push(buf.slice(4, frameLength + 4));\n    } else {\n      var bufs = this._bufs;\n      this._bufs = [];\n      this.push({id: null, payload: bufs});\n    }\n    buf = buf.slice(frameLength + 4);\n  }\n  this._buf = buf;\n  cb();\n};\n\nFrameDecoder.prototype._flush = function (cb) {\n  if (this._buf.length || this._bufs.length) {\n    var bufs = this._bufs.slice();\n    bufs.unshift(this._buf);\n    var err = toRpcError('TRAILING_DATA');\n    // Attach the data to help debugging (e.g. if the encoded bytes contain a\n    // human-readable protocol like HTTP).\n    err.trailingData = Buffer.concat(bufs).toString();\n    this.emit('error', err);\n  }\n  cb();\n};\n\n/** Standard framing stream. */\nfunction FrameEncoder() {\n  stream.Transform.call(this, {writableObjectMode: true});\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(FrameEncoder, stream.Transform);\n\nFrameEncoder.prototype._transform = function (obj, encoding, cb) {\n  var bufs = obj.payload;\n  var i, l, buf;\n  for (i = 0, l = bufs.length; i < l; i++) {\n    buf = bufs[i];\n    this.push(intBuffer(buf.length));\n    this.push(buf);\n  }\n  this.push(intBuffer(0));\n  cb();\n};\n\n/** Netty-compatible decoding stream. */\nfunction NettyDecoder() {\n  stream.Transform.call(this, {readableObjectMode: true});\n  this._id = undefined;\n  this._frameCount = 0;\n  this._buf = utils.newBuffer(0);\n  this._bufs = [];\n\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(NettyDecoder, stream.Transform);\n\nNettyDecoder.prototype._transform = function (buf, encoding, cb) {\n  buf = Buffer.concat([this._buf, buf]);\n\n  while (true) {\n    if (this._id === undefined) {\n      if (buf.length < 8) {\n        this._buf = buf;\n        cb();\n        return;\n      }\n      this._id = buf.readInt32BE(0);\n      this._frameCount = buf.readInt32BE(4);\n      buf = buf.slice(8);\n    }\n\n    var frameLength;\n    while (\n      this._frameCount &&\n      buf.length >= 4 &&\n      buf.length >= (frameLength = buf.readInt32BE(0)) + 4\n    ) {\n      this._frameCount--;\n      this._bufs.push(buf.slice(4, frameLength + 4));\n      buf = buf.slice(frameLength + 4);\n    }\n\n    if (this._frameCount) {\n      this._buf = buf;\n      cb();\n      return;\n    } else {\n      var obj = {id: this._id, payload: this._bufs};\n      this._bufs = [];\n      this._id = undefined;\n      this.push(obj);\n    }\n  }\n};\n\nNettyDecoder.prototype._flush = FrameDecoder.prototype._flush;\n\n/** Netty-compatible encoding stream. */\nfunction NettyEncoder() {\n  stream.Transform.call(this, {writableObjectMode: true});\n  this.on('finish', function () { this.push(null); });\n}\nutil.inherits(NettyEncoder, stream.Transform);\n\nNettyEncoder.prototype._transform = function (obj, encoding, cb) {\n  var bufs = obj.payload;\n  var l = bufs.length;\n  var buf;\n  // Header: [ ID, number of frames ]\n  buf = utils.newBuffer(8);\n  buf.writeInt32BE(obj.id, 0);\n  buf.writeInt32BE(l, 4);\n  this.push(buf);\n  // Frames, each: [ length, bytes ]\n  var i;\n  for (i = 0; i < l; i++) {\n    buf = bufs[i];\n    this.push(intBuffer(buf.length));\n    this.push(buf);\n  }\n  cb();\n};\n\n/**\n * Returns a buffer containing an integer's big-endian representation.\n *\n * @param n {Number} Integer.\n */\nfunction intBuffer(n) {\n  var buf = utils.newBuffer(4);\n  buf.writeInt32BE(n);\n  return buf;\n}\n\n/**\n * Decode a type used as prefix inside a buffer.\n *\n * @param type {Type} The type of the prefix.\n * @param buf {Buffer} Encoded bytes.\n *\n * This function will return an object `{head, tail}` where head contains the\n * decoded value and tail the rest of the buffer. An error will be thrown if\n * the prefix cannot be decoded.\n */\nfunction readHead(type, buf) {\n  var tap = new Tap(buf);\n  var head = type._read(tap);\n  if (!tap.isValid()) {\n    throw new Error(f('truncated %j', type.schema()));\n  }\n  return {head: head, tail: tap.buf.slice(tap.pos)};\n}\n\n/**\n * Generate a decoder, optimizing the case where reader and writer are equal.\n *\n * @param rtype {Type} Reader's type.\n * @param wtype {Type} Writer's type.\n */\nfunction createReader(rtype, wtype) {\n  return rtype.equals(wtype) ? rtype : rtype.createResolver(wtype);\n}\n\n/**\n * Generate all readers for a given protocol combination.\n *\n * @param clientSvc {Service} Client service.\n * @param serverSvc {Service} Client service.\n */\nfunction createReaders(clientSvc, serverSvc) {\n  var obj = {};\n  clientSvc.messages.forEach(function (c) {\n    var n = c.name;\n    var s = serverSvc.message(n);\n    try {\n      if (!s) {\n        throw new Error(f('missing server message: %s', n));\n      }\n      if (s.oneWay !== c.oneWay) {\n        throw new Error(f('inconsistent one-way message: %s', n));\n      }\n      obj[n + '?'] = createReader(s.requestType, c.requestType);\n      obj[n + '*'] = createReader(c.errorType, s.errorType);\n      obj[n + '!'] = createReader(c.responseType, s.responseType);\n    } catch (cause) {\n      throw toRpcError('INCOMPATIBLE_PROTOCOL', cause);\n    }\n  });\n  return obj;\n}\n\n/**\n * Populate a cache from a list of protocols.\n *\n * @param cache {Object} Cache of adapters.\n * @param svc {Service} The local service (either client or server).\n * @param ptcls {Array} Array of protocols to insert.\n * @param isClient {Boolean} Whether the local service is a client's or\n * server's.\n */\nfunction insertRemoteProtocols(cache, ptcls, svc, isClient) {\n  Object.keys(ptcls).forEach(function (hash) {\n    var ptcl = ptcls[hash];\n    var clientSvc, serverSvc;\n    if (isClient) {\n      clientSvc = svc;\n      serverSvc = Service.forProtocol(ptcl);\n    } else {\n      clientSvc = Service.forProtocol(ptcl);\n      serverSvc = svc;\n    }\n    cache[hash] = new Adapter(clientSvc, serverSvc, hash, true);\n  });\n}\n\n/**\n * Extract remote protocols from a cache\n *\n * @param cache {Object} Cache of adapters.\n * @param isClient {Boolean} Whether the remote protocols extracted should be\n * the servers' or clients'.\n */\nfunction getRemoteProtocols(cache, isClient) {\n  var ptcls = {};\n  Object.keys(cache).forEach(function (hs) {\n    var adapter = cache[hs];\n    if (adapter._isRemote) {\n      var svc = isClient ? adapter._serverSvc : adapter._clientSvc;\n      ptcls[hs] = svc.protocol;\n    }\n  });\n  return ptcls;\n}\n\n/**\n * Check whether something is an `Error`.\n *\n * @param any {Object} Any object.\n */\nfunction isError(any) {\n  // Also not ideal, but avoids brittle `instanceof` checks.\n  return !!any && Object.prototype.toString.call(any) === '[object Error]';\n}\n\n/**\n * Forward any errors emitted on the source to the destination.\n *\n * @param src {EventEmitter} The initial source of error events.\n * @param dst {EventEmitter} The new target of the source's error events. The\n * original source will be provided as second argument (the error being the\n * first).\n *\n * As a convenience, the source will be returned.\n */\nfunction forwardErrors(src, dst) {\n  return src.on('error', function (err) {\n    dst.emit('error', err, src);\n  });\n}\n\n/**\n * Create an error.\n *\n * @param msg {String} Error message.\n * @param cause {Error} The cause of the error. It is available as `cause`\n * field on the outer error.\n */\nfunction toError(msg, cause) {\n  var err = new Error(msg);\n  err.cause = cause;\n  return err;\n}\n\n/**\n * Mark an error.\n *\n * @param rpcCode {String} Code representing the failure.\n * @param cause {Error} The cause of the error. It is available as `cause`\n * field on the outer error.\n *\n * This is used to keep the argument of channels' `'error'` event errors.\n */\nfunction toRpcError(rpcCode, cause) {\n  var err = toError(rpcCode.toLowerCase().replace(/_/g, ' '), cause);\n  err.rpcCode = (cause && cause.rpcCode) ? cause.rpcCode : rpcCode;\n  return err;\n}\n\n/**\n * Provide a helpful error to identify why serialization failed.\n *\n * @param err {Error} The error to decorate.\n * @param obj {...} The object containing fields to validated.\n * @param fields {Array} Information about the fields to validate.\n */\nfunction serializationError(msg, obj, fields) {\n  var details = [];\n  var i, l, field;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    field.type.isValid(obj[field.name], {errorHook: errorHook});\n  }\n  var detailsStr = details\n    .map(function (obj) {\n      return f('%s = %j but expected %s', obj.path, obj.value, obj.type);\n    })\n    .join(', ');\n  var err = new Error(f('%s (%s)', msg, detailsStr));\n  err.details = details;\n  return err;\n\n  function errorHook(parts, any, type) {\n    var strs = [];\n    var i, l, part;\n    for (i = 0, l = parts.length; i < l; i++) {\n      part = parts[i];\n      if (isNaN(part)) {\n        strs.push('.' + part);\n      } else {\n        strs.push('[' + part + ']');\n      }\n    }\n    details.push({\n      path: field.name + strs.join(''),\n      value: any,\n      type: type\n    });\n  }\n}\n\n/**\n * Compute a prefix of fixed length from a string.\n *\n * @param scope {String} Namespace to be hashed.\n */\nfunction normalizedPrefix(scope) {\n  return scope ?\n    utils.getHash(scope).readInt16BE(0) << (32 - PREFIX_LENGTH) :\n    0;\n}\n\n/**\n * Check whether an ID matches the prefix.\n *\n * @param id {Integer} Number to check.\n * @param prefix {Integer} Already shifted prefix.\n */\nfunction matchesPrefix(id, prefix) {\n  return ((id ^ prefix) >> (32 - PREFIX_LENGTH)) === 0;\n}\n\n/**\n * Check whether something is a stream.\n *\n * @param any {Object} Any object.\n */\nfunction isStream(any) {\n  // This is a hacky way of checking that the transport is a stream-like\n  // object. We unfortunately can't use `instanceof Stream` checks since\n  // some libraries (e.g. websocket-stream) return streams which don't\n  // inherit from it.\n  return !!(any && any.pipe);\n}\n\n/**\n * Get a message, asserting that it exists.\n *\n * @param svc {Service} The protocol to look into.\n * @param name {String} The message's name.\n */\nfunction getExistingMessage(svc, name) {\n  var msg = svc.message(name);\n  if (!msg) {\n    throw new Error(f('unknown message: %s', name));\n  }\n  return msg;\n}\n\n/**\n * Middleware logic.\n *\n * This is used both in clients and servers to intercept call handling (e.g. to\n * populate headers, do access control).\n *\n * @param params {Object} The following parameters:\n *  + fns {Array} Array of middleware functions.\n *  + ctx {Object} Context used to call the middleware functions, onTransition,\n *    and onCompletion.\n *  + wreq {WrappedRequest}\n *  + wres {WrappedResponse}\n *  + onTransition {Function} End of forward phase callback. It accepts an\n *    eventual error as single argument. This will be used for the backward\n *    phase. This function is guaranteed to be called at most once.\n *  + onCompletion {Function} Final handler, it takes an error as unique\n *    argument. This function is guaranteed to be only at most once.\n *  + onError {Function} Error handler, called if an intermediate callback is\n *    called multiple times.\n */\nfunction chainMiddleware(params) {\n  var args = [params.wreq, params.wres];\n  var cbs = [];\n  var cause; // Backpropagated error.\n  forward(0);\n\n  function forward(pos) {\n    var isDone = false;\n    if (pos < params.fns.length) {\n      params.fns[pos].apply(params.ctx, args.concat(function (err, cb) {\n        if (isDone) {\n          params.onError(toError('duplicate forward middleware call', err));\n          return;\n        }\n        isDone = true;\n        if (\n          err || (\n            params.wres && ( // Non one-way messages.\n              params.wres.error !== undefined ||\n              params.wres.response !== undefined\n            )\n          )\n        ) {\n          // Stop the forward phase, bypass the handler, and start the backward\n          // phase. Note that we ignore any callback argument in this case.\n          cause = err;\n          backward();\n          return;\n        }\n        if (cb) {\n          cbs.push(cb);\n        }\n        forward(++pos);\n      }));\n    } else {\n      // Done with the middleware forward functions, call the handler.\n      params.onTransition.apply(params.ctx, args.concat(function (err) {\n        if (isDone) {\n          params.onError(toError('duplicate handler call', err));\n          return;\n        }\n        isDone = true;\n        cause = err;\n        process.nextTick(backward);\n      }));\n    }\n  }\n\n  function backward() {\n    var cb = cbs.pop();\n    if (cb) {\n      var isDone = false;\n      cb.call(params.ctx, cause, function (err) {\n        if (isDone) {\n          params.onError(toError('duplicate backward middleware call', err));\n          return;\n        }\n        // Substitute the error.\n        cause = err;\n        isDone = true;\n        backward();\n      });\n    } else {\n      // Done with all middleware calls.\n      params.onCompletion.call(params.ctx, cause);\n    }\n  }\n}\n\n\nmodule.exports = {\n  Adapter: Adapter,\n  HANDSHAKE_REQUEST_TYPE: HANDSHAKE_REQUEST_TYPE,\n  HANDSHAKE_RESPONSE_TYPE: HANDSHAKE_RESPONSE_TYPE,\n  Message: Message,\n  Registry: Registry,\n  Service: Service,\n  discoverProtocol: discoverProtocol,\n  streams: {\n    FrameDecoder: FrameDecoder,\n    FrameEncoder: FrameEncoder,\n    NettyDecoder: NettyDecoder,\n    NettyEncoder: NettyEncoder\n  }\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/services.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/specs.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/specs.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\n\n// TODO: Add minimal templating.\n// TODO: Add option to prefix nested type declarations with the outer types'\n// names.\n\n\n\n/** IDL to protocol (services) and schema (types) parsing logic. */\n\nvar files = __webpack_require__(/*! ./files */ \"./node_modules/avsc/etc/browser/lib/files.js\"),\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\n    path = __webpack_require__(/*! path */ \"./node_modules/path/path.js\"),\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\n\nvar f = util.format;\n\n\n// Default type references defined by Avro.\nvar TYPE_REFS = {\n  date: {type: 'int', logicalType: 'date'},\n  decimal: {type: 'bytes', logicalType: 'decimal'},\n  time_ms: {type: 'long', logicalType: 'time-millis'},\n  timestamp_ms: {type: 'long', logicalType: 'timestamp-millis'}\n};\n\n\n/** Assemble an IDL file into a decoded protocol. */\nfunction assembleProtocol(fpath, opts, cb) {\n  if (!cb && typeof opts == 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  opts = opts || {};\n  if (!opts.importHook) {\n    opts.importHook = files.createImportHook();\n  }\n\n  importFile(fpath, function (err, protocol) {\n    if (err) {\n      cb(err);\n      return;\n    }\n    if (!protocol) {\n      cb(new Error('empty root import'));\n      return;\n    }\n    var schemas = protocol.types;\n    if (schemas) {\n      // Strip redundant namespaces from types before returning the protocol.\n      // Note that we keep empty (`''`) nested namespaces when the outer one is\n      // non-empty. This allows figuring out whether unqualified imported names\n      // should be qualified by the protocol's namespace: they should if their\n      // namespace is `undefined` and should not if it is empty.\n      var namespace = protocolNamespace(protocol) || '';\n      schemas.forEach(function (schema) {\n        if (schema.namespace === namespace) {\n          delete schema.namespace;\n        }\n      });\n    }\n    cb(null, protocol);\n  });\n\n  function importFile(fpath, cb) {\n    opts.importHook(fpath, 'idl', function (err, str) {\n      if (err) {\n        cb(err);\n        return;\n      }\n      if (str === undefined) {\n        // This signals an already imported file by the default import hooks.\n        // Implementors who wish to disallow duplicate imports should provide a\n        // custom hook which throws an error when a duplicate is detected.\n        cb();\n        return;\n      }\n      try {\n        var reader = new Reader(str, opts);\n        var obj = reader._readProtocol(str, opts);\n      } catch (err) {\n        err.path = fpath; // To help debug which file caused the error.\n        cb(err);\n        return;\n      }\n      fetchImports(obj.protocol, obj.imports, path.dirname(fpath), cb);\n    });\n  }\n\n  function fetchImports(protocol, imports, dpath, cb) {\n    var importedProtocols = [];\n    next();\n\n    function next() {\n      var info = imports.shift();\n      if (!info) {\n        // We are done with this file. We prepend all imported types to this\n        // file's and we can return the final result.\n        importedProtocols.reverse();\n        try {\n          importedProtocols.forEach(function (imported) {\n            mergeImport(protocol, imported);\n          });\n        } catch (err) {\n          cb(err);\n          return;\n        }\n        cb(null, protocol);\n        return;\n      }\n      var importPath = path.join(dpath, info.name);\n      if (info.kind === 'idl') {\n        importFile(importPath, function (err, imported) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          if (imported) {\n            importedProtocols.push(imported);\n          }\n          next();\n        });\n      } else {\n        // We are importing a protocol or schema file.\n        opts.importHook(importPath, info.kind, function (err, str) {\n          if (err) {\n            cb(err);\n            return;\n          }\n          switch (info.kind) {\n            case 'protocol':\n            case 'schema':\n              if (str === undefined) {\n                // Skip duplicate import (see related comment above).\n                next();\n                return;\n              }\n              try {\n                var obj = JSON.parse(str);\n              } catch (err) {\n                err.path = importPath;\n                cb(err);\n                return;\n              }\n              var imported = info.kind === 'schema' ? {types: [obj]} : obj;\n              importedProtocols.push(imported);\n              next();\n              return;\n            default:\n              cb(new Error(f('invalid import kind: %s', info.kind)));\n          }\n        });\n      }\n    }\n  }\n\n  function mergeImport(protocol, imported) {\n    // Merge first the types (where we don't need to check for duplicates\n    // since instantiating the service will take care of it), then the messages\n    // (where we need to, as duplicates will overwrite each other).\n    var schemas = imported.types || [];\n    schemas.reverse();\n    schemas.forEach(function (schema) {\n      if (!protocol.types) {\n        protocol.types = [];\n      }\n      // Ensure the imported protocol's namespace is inherited correctly (it\n      // might be different from the current one).\n      if (schema.namespace === undefined) {\n        schema.namespace = protocolNamespace(imported) || '';\n      }\n      protocol.types.unshift(schema);\n    });\n    Object.keys(imported.messages || {}).forEach(function (name) {\n      if (!protocol.messages) {\n        protocol.messages = {};\n      }\n      if (protocol.messages[name]) {\n        throw new Error(f('duplicate message: %s', name));\n      }\n      protocol.messages[name] = imported.messages[name];\n    });\n  }\n}\n\n// Parsing functions.\n\n/**\n * Convenience function to parse multiple inputs into protocols and schemas.\n *\n * It should cover most basic use-cases but has a few limitations:\n *\n * + It doesn't allow passing options to the parsing step.\n * + The protocol/type inference logic can be deceived.\n *\n * The parsing logic is as follows:\n *\n * + If `str` contains `path.sep` (on windows `\\`, otherwise `/`) and is a path\n *   to an existing file, it will first be read as JSON, then as an IDL\n *   specification if JSON parsing failed. If either succeeds, the result is\n *   returned, otherwise the next steps are run using the file's content\n *   instead of the input path.\n * + If `str` is a valid JSON string, it is parsed then returned.\n * + If `str` is a valid IDL protocol specification, it is parsed and returned\n *   if no imports are present (and an error is thrown if there are any\n *   imports).\n * + If `str` is a valid IDL type specification, it is parsed and returned.\n * + If neither of the above cases apply, `str` is returned.\n */\nfunction read(str) {\n  var schema;\n  if (typeof str == 'string' && ~str.indexOf(path.sep) && files.existsSync(str)) {\n    // Try interpreting `str` as path to a file contain a JSON schema or an IDL\n    // protocol. Note that we add the second check to skip primitive references\n    // (e.g. `\"int\"`, the most common use-case for `avro.parse`).\n    var contents = files.readFileSync(str, {encoding: 'utf8'});\n    try {\n      return JSON.parse(contents);\n    } catch (err) {\n      var opts = {importHook: files.createSyncImportHook()};\n      assembleProtocol(str, opts, function (err, protocolSchema) {\n        schema = err ? contents : protocolSchema;\n      });\n    }\n  } else {\n    schema = str;\n  }\n  if (typeof schema != 'string' || schema === 'null') {\n    // This last predicate is to allow `read('null')` to work similarly to\n    // `read('int')` and other primitives (null needs to be handled separately\n    // since it is also a valid JSON identifier).\n    return schema;\n  }\n  try {\n    return JSON.parse(schema);\n  } catch (err) {\n    try {\n      return Reader.readProtocol(schema);\n    } catch (err) {\n      try {\n        return Reader.readSchema(schema);\n      } catch (err) {\n        return schema;\n      }\n    }\n  }\n}\n\nfunction Reader(str, opts) {\n  opts = opts || {};\n\n  this._tk = new Tokenizer(str);\n  this._ackVoidMessages = !!opts.ackVoidMessages;\n  this._implicitTags = !opts.delimitedCollections;\n  this._typeRefs = opts.typeRefs || TYPE_REFS;\n}\n\nReader.readProtocol = function (str, opts) {\n  var reader = new Reader(str, opts);\n  var protocol = reader._readProtocol();\n  if (protocol.imports.length) {\n    // Imports can only be resolved when the IDL file is provided via its\n    // path, we fail rather than silently ignore imports.\n    throw new Error('unresolvable import');\n  }\n  return protocol.protocol;\n};\n\nReader.readSchema = function (str, opts) {\n  var reader = new Reader(str, opts);\n  var doc = reader._readJavadoc();\n  var schema = reader._readType(doc === undefined ? {} : {doc: doc}, true);\n  reader._tk.next({id: '(eof)'}); // Check that we have read everything.\n  return schema;\n};\n\nReader.prototype._readProtocol = function () {\n  var tk = this._tk;\n  var imports = [];\n  var types = [];\n  var messages = {};\n  var pos;\n\n  // Outer declarations (outside of the protocol block).\n  this._readImports(imports);\n  var protocolSchema = {};\n  var protocolJavadoc = this._readJavadoc();\n  if (protocolJavadoc !== undefined) {\n    protocolSchema.doc = protocolJavadoc;\n  }\n  this._readAnnotations(protocolSchema);\n  tk.next({val: 'protocol'});\n  if (!tk.next({val: '{', silent: true})) {\n    // Named protocol.\n    protocolSchema.protocol = tk.next({id: 'name'}).val;\n    tk.next({val: '{'});\n  }\n\n  // Inner declarations.\n  while (!tk.next({val: '}', silent: true})) {\n    if (!this._readImports(imports)) {\n      var javadoc = this._readJavadoc();\n      var typeSchema = this._readType({}, true);\n      var numImports = this._readImports(imports, true);\n      var message = undefined;\n      // We mark our position and try to parse a message from here.\n      pos = tk.pos;\n      if (!numImports && (message = this._readMessage(typeSchema))) {\n        // Note that if any imports were found, we cannot be parsing a message.\n        if (javadoc !== undefined && message.schema.doc === undefined) {\n          message.schema.doc = javadoc;\n        }\n        var oneWay = false;\n        if (\n          message.schema.response === 'void' ||\n          message.schema.response.type === 'void'\n        ) {\n          oneWay = !this._ackVoidMessages && !message.schema.errors;\n          if (message.schema.response === 'void') {\n            message.schema.response = 'null';\n          } else {\n            message.schema.response.type = 'null';\n          }\n        }\n        if (oneWay) {\n          message.schema['one-way'] = true;\n        }\n        if (messages[message.name]) {\n          // We have to do this check here otherwise the duplicate will be\n          // overwritten (and service instantiation won't be able to catch it).\n          throw new Error(f('duplicate message: %s', message.name));\n        }\n        messages[message.name] = message.schema;\n      } else {\n        // This was a standalone type definition.\n        if (javadoc) {\n          if (typeof typeSchema == 'string') {\n            typeSchema = {doc: javadoc, type: typeSchema};\n          } else if (typeSchema.doc === undefined) {\n            typeSchema.doc = javadoc;\n          }\n        }\n        types.push(typeSchema);\n        // We backtrack until just before the type's type name and swallow an\n        // eventual semi-colon (to make type declarations more consistent).\n        tk.pos = pos;\n        tk.next({val: ';', silent: true});\n      }\n      javadoc = undefined;\n    }\n  }\n  tk.next({id: '(eof)'});\n  if (types.length) {\n    protocolSchema.types = types;\n  }\n  if (Object.keys(messages).length) {\n    protocolSchema.messages = messages;\n  }\n  return {protocol: protocolSchema, imports: imports};\n};\n\nReader.prototype._readAnnotations = function (schema) {\n  var tk = this._tk;\n  while (tk.next({val: '@', silent: true})) {\n    // Annotations are allowed to have names which aren't valid Avro names,\n    // we must advance until we hit the first left parenthesis.\n    var parts = [];\n    while (!tk.next({val: '(', silent: true})) {\n      parts.push(tk.next().val);\n    }\n    schema[parts.join('')] = tk.next({id: 'json'}).val;\n    tk.next({val: ')'});\n  }\n};\n\nReader.prototype._readMessage = function (responseSchema) {\n  var tk = this._tk;\n  var schema = {request: [], response: responseSchema};\n  this._readAnnotations(schema);\n  var name = tk.next().val;\n  if (tk.next().val !== '(') {\n    // This isn't a message.\n    return;\n  }\n  if (!tk.next({val: ')', silent: true})) {\n    do {\n      schema.request.push(this._readField());\n    } while (!tk.next({val: ')', silent: true}) && tk.next({val: ','}));\n  }\n  var token = tk.next();\n  switch (token.val) {\n    case 'throws':\n      // It doesn't seem like the IDL is explicit about which syntax to used\n      // for multiple errors. We will assume a comma-separated list.\n      schema.errors = [];\n      do {\n        schema.errors.push(this._readType());\n      } while (!tk.next({val: ';', silent: true}) && tk.next({val: ','}));\n      break;\n    case 'oneway':\n      schema['one-way'] = true;\n      tk.next({val: ';'});\n      break;\n    case ';':\n      break;\n    default:\n      throw tk.error('invalid message suffix', token);\n  }\n  return {name: name, schema: schema};\n};\n\nReader.prototype._readJavadoc = function () {\n  var token = this._tk.next({id: 'javadoc', emitJavadoc: true, silent: true});\n  if (token) {\n    return token.val;\n  }\n};\n\nReader.prototype._readField = function () {\n  var tk = this._tk;\n  var javadoc = this._readJavadoc();\n  var schema = {type: this._readType()};\n  if (javadoc !== undefined && schema.doc === undefined) {\n    schema.doc = javadoc;\n  }\n  this._readAnnotations(schema);\n  schema.name = tk.next({id: 'name'}).val;\n  if (tk.next({val: '=', silent: true})) {\n    schema['default'] = tk.next({id: 'json'}).val;\n  }\n  return schema;\n};\n\nReader.prototype._readType = function (schema, top) {\n  schema = schema || {};\n  this._readAnnotations(schema);\n  schema.type = this._tk.next({id: 'name'}).val;\n  switch (schema.type) {\n    case 'record':\n    case 'error':\n      return this._readRecord(schema);\n    case 'fixed':\n      return this._readFixed(schema);\n    case 'enum':\n      return this._readEnum(schema, top);\n    case 'map':\n      return this._readMap(schema);\n    case 'array':\n      return this._readArray(schema);\n    case 'union':\n      if (Object.keys(schema).length > 1) {\n        throw new Error('union annotations are not supported');\n      }\n      return this._readUnion();\n    default:\n      // Reference.\n      var ref = this._typeRefs[schema.type];\n      if (ref) {\n        delete schema.type; // Always overwrite the type.\n        utils.copyOwnProperties(ref, schema);\n      }\n      return Object.keys(schema).length > 1 ? schema : schema.type;\n  }\n};\n\nReader.prototype._readFixed = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({val: '(', silent: true})) {\n    schema.name = tk.next({id: 'name'}).val;\n    tk.next({val: '('});\n  }\n  schema.size = parseInt(tk.next({id: 'number'}).val);\n  tk.next({val: ')'});\n  return schema;\n};\n\nReader.prototype._readMap = function (schema) {\n  var tk = this._tk;\n  // Brackets are unwieldy when declaring inline types. We allow for them to be\n  // omitted (but we keep the consistency that if the entry bracket is present,\n  // the exit one must be as well). Note that this is non-standard.\n  var silent = this._implicitTags;\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\n  schema.values = this._readType();\n  tk.next({val: '>', silent: implicitTags});\n  return schema;\n};\n\nReader.prototype._readArray = function (schema) {\n  var tk = this._tk;\n  var silent = this._implicitTags;\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\n  schema.items = this._readType();\n  tk.next({val: '>', silent: implicitTags});\n  return schema;\n};\n\nReader.prototype._readEnum = function (schema, top) {\n  var tk = this._tk;\n  if (!tk.next({val: '{', silent: true})) {\n    schema.name = tk.next({id: 'name'}).val;\n    tk.next({val: '{'});\n  }\n  schema.symbols = [];\n  do {\n    schema.symbols.push(tk.next().val);\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\n  // To avoid confusing syntax, reader enums (i.e. enums with a default value)\n  // can only be defined top-level.\n  if (top && tk.next({val: '=', silent: true})) {\n    schema.default = tk.next().val;\n    tk.next({val: ';'});\n  }\n  return schema;\n};\n\nReader.prototype._readUnion = function () {\n  var tk = this._tk;\n  var arr = [];\n  tk.next({val: '{'});\n  do {\n    arr.push(this._readType());\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\n  return arr;\n};\n\nReader.prototype._readRecord = function (schema) {\n  var tk = this._tk;\n  if (!tk.next({val: '{', silent: true})) {\n    schema.name = tk.next({id: 'name'}).val;\n    tk.next({val: '{'});\n  }\n  schema.fields = [];\n  while (!tk.next({val: '}', silent: true})) {\n    schema.fields.push(this._readField());\n    tk.next({val: ';'});\n  }\n  return schema;\n};\n\nReader.prototype._readImports = function (imports, maybeMessage) {\n  var tk = this._tk;\n  var numImports = 0;\n  var pos = tk.pos;\n  while (tk.next({val: 'import', silent: true})) {\n    if (!numImports && maybeMessage && tk.next({val: '(', silent: true})) {\n      // This will happen if a message is named import.\n      tk.pos = pos;\n      return;\n    }\n    var kind = tk.next({id: 'name'}).val;\n    var fname = JSON.parse(tk.next({id: 'string'}).val);\n    tk.next({val: ';'});\n    imports.push({kind: kind, name: fname});\n    numImports++;\n  }\n  return numImports;\n};\n\n// Helpers.\n\n/**\n * Simple class to split an input string into tokens.\n *\n * There are different types of tokens, characterized by their `id`:\n *\n * + `number` numbers.\n * + `name` references.\n * + `string` double-quoted.\n * + `operator`, anything else, always single character.\n * + `javadoc`, only emitted when `next` is called with `emitJavadoc` set.\n * + `json`, only emitted when `next` is called with `'json'` as `id` (the\n *   tokenizer doesn't have enough context to predict these).\n */\nfunction Tokenizer(str) {\n  this._str = str;\n  this.pos = 0;\n}\n\nTokenizer.prototype.next = function (opts) {\n  var token = {pos: this.pos, id: undefined, val: undefined};\n  var javadoc = this._skip(opts && opts.emitJavadoc);\n  if (javadoc) {\n    token.id = 'javadoc';\n    token.val = javadoc;\n  } else {\n    var pos = this.pos;\n    var str = this._str;\n    var c = str.charAt(pos);\n    if (!c) {\n      token.id = '(eof)';\n    } else {\n      if (opts && opts.id === 'json') {\n        token.id = 'json';\n        this.pos = this._endOfJson();\n      } else if (c === '\"') {\n        token.id = 'string';\n        this.pos = this._endOfString();\n      } else if (/[0-9]/.test(c)) {\n        token.id = 'number';\n        this.pos = this._endOf(/[0-9]/);\n      } else if (/[`A-Za-z_.]/.test(c)) {\n        token.id = 'name';\n        this.pos = this._endOf(/[`A-Za-z0-9_.]/);\n      } else {\n        token.id = 'operator';\n        this.pos = pos + 1;\n      }\n      token.val = str.slice(pos, this.pos);\n      if (token.id === 'json') {\n        // Let's be nice and give a more helpful error message when this occurs\n        // (JSON parsing errors wouldn't let us find the location otherwise).\n        try {\n          token.val = JSON.parse(token.val);\n        } catch (err) {\n          throw this.error('invalid JSON', token);\n        }\n      } else if (token.id === 'name') {\n        // Unescape names (our parser doesn't need them).\n        token.val = token.val.replace(/`/g, '');\n      }\n    }\n  }\n\n  var err;\n  if (opts && opts.id && opts.id !== token.id) {\n    err = this.error(f('expected ID %s', opts.id), token);\n  } else if (opts && opts.val && opts.val !== token.val) {\n    err = this.error(f('expected value %s', opts.val), token);\n  }\n  if (!err) {\n    return token;\n  } else if (opts && opts.silent) {\n    this.pos = token.pos; // Backtrack to start of token.\n    return undefined;\n  } else {\n    throw err;\n  }\n};\n\nTokenizer.prototype.error = function (reason, context) {\n  // Context must be either a token or a position.\n  var isToken = typeof context != 'number';\n  var pos = isToken ? context.pos : context;\n  var str = this._str;\n  var lineNum = 1;\n  var lineStart = 0;\n  var i;\n  for (i = 0; i < pos; i++) {\n    if (str.charAt(i) === '\\n') {\n      lineNum++;\n      lineStart = i;\n    }\n  }\n  var msg = isToken ? f('invalid token %j: %s', context, reason) : reason;\n  var err = new Error(msg);\n  err.token = isToken ? context : undefined;\n  err.lineNum = lineNum;\n  err.colNum = pos - lineStart;\n  return err;\n};\n\n/** Skip whitespace and comments. */\nTokenizer.prototype._skip = function (emitJavadoc) {\n  var str = this._str;\n  var isJavadoc = false;\n  var pos, c;\n\n  while ((c = str.charAt(this.pos)) && /\\s/.test(c)) {\n    this.pos++;\n  }\n  pos = this.pos;\n  if (c === '/') {\n    switch (str.charAt(this.pos + 1)) {\n    case '/':\n      this.pos += 2;\n      while ((c = str.charAt(this.pos)) && c !== '\\n') {\n        this.pos++;\n      }\n      return this._skip(emitJavadoc);\n    case '*':\n      this.pos += 2;\n      if (str.charAt(this.pos) === '*') {\n        isJavadoc = true;\n      }\n      while ((c = str.charAt(this.pos++))) {\n        if (c === '*' && str.charAt(this.pos) === '/') {\n          this.pos++;\n          if (isJavadoc && emitJavadoc) {\n            return extractJavadoc(str.slice(pos + 3, this.pos - 2));\n          }\n          return this._skip(emitJavadoc);\n        }\n      }\n      throw this.error('unterminated comment', pos);\n    }\n  }\n};\n\n/** Generic end of method. */\nTokenizer.prototype._endOf = function (pat) {\n  var pos = this.pos;\n  var str = this._str;\n  while (pat.test(str.charAt(pos))) {\n    pos++;\n  }\n  return pos;\n};\n\n/** Find end of a string. */\nTokenizer.prototype._endOfString = function () {\n  var pos = this.pos + 1; // Skip first double quote.\n  var str = this._str;\n  var c;\n  while ((c = str.charAt(pos))) {\n    if (c === '\"') {\n      // The spec doesn't explicitly say so, but IDLs likely only\n      // allow double quotes for strings (C- and Java-style).\n      return pos + 1;\n    }\n    if (c === '\\\\') {\n      pos += 2;\n    } else {\n      pos++;\n    }\n  }\n  throw this.error('unterminated string', pos - 1);\n};\n\n/** Find end of JSON object, throwing an error if the end is reached first. */\nTokenizer.prototype._endOfJson = function () {\n  var pos = utils.jsonEnd(this._str, this.pos);\n  if (pos < 0) {\n    throw this.error('invalid JSON', pos);\n  }\n  return pos;\n};\n\n/**\n * Extract Javadoc contents from the comment.\n *\n * The parsing done is very simple and simply removes the line prefixes and\n * leading / trailing empty lines. It's better to be conservative with\n * formatting rather than risk losing information.\n */\nfunction extractJavadoc(str) {\n  var lines = str\n    .replace(/^[ \\t]+|[ \\t]+$/g, '') // Trim whitespace.\n    .split('\\n').map(function (line, i) {\n      return i ? line.replace(/^\\s*\\*\\s?/, '') : line;\n    });\n  while (!lines[0]) {\n    lines.shift();\n  }\n  while (!lines[lines.length - 1]) {\n    lines.pop();\n  }\n  return lines.join('\\n');\n}\n\n/** Returns the namespace generated by a protocol. */\nfunction protocolNamespace(protocol) {\n  if (protocol.namespace) {\n    return protocol.namespace;\n  }\n  var match = /^(.*)\\.[^.]+$/.exec(protocol.protocol);\n  return match ? match[1] : undefined;\n}\n\n\nmodule.exports = {\n  Tokenizer: Tokenizer,\n  assembleProtocol: assembleProtocol,\n  read: read,\n  readProtocol: Reader.readProtocol,\n  readSchema: Reader.readSchema\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/specs.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/types.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/types.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* jshint node: true */\n\n// TODO: Make it easier to implement custom types. This will likely require\n// exposing the `Tap` object, perhaps under another name. Probably worth a\n// major release.\n// TODO: Allow configuring when to write the size when writing arrays and maps,\n// and customizing their block size.\n// TODO: Code-generate `compare` and `clone` record and union methods.\n\n\n\n/**\n * This module defines all Avro data types and their serialization logic.\n *\n */\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\n    buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"), // For `SlowBuffer`.\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\n\n// Convenience imports.\nvar Tap = utils.Tap;\nvar debug = util.debuglog('avsc:types');\nvar f = util.format;\n\n// All non-union concrete (i.e. non-logical) Avro types.\nvar TYPES = {\n  'array': ArrayType,\n  'boolean': BooleanType,\n  'bytes': BytesType,\n  'double': DoubleType,\n  'enum': EnumType,\n  'error': RecordType,\n  'fixed': FixedType,\n  'float': FloatType,\n  'int': IntType,\n  'long': LongType,\n  'map': MapType,\n  'null': NullType,\n  'record': RecordType,\n  'string': StringType\n};\n\n// Random generator.\nvar RANDOM = new utils.Lcg();\n\n// Encoding tap (shared for performance).\nvar TAP = new Tap(new buffer.SlowBuffer(1024));\n\n// Currently active logical type, used for name redirection.\nvar LOGICAL_TYPE = null;\n\n// Underlying types of logical types currently being instantiated. This is used\n// to be able to reference names (i.e. for branches) during instantiation.\nvar UNDERLYING_TYPES = [];\n\n/**\n * \"Abstract\" base Avro type.\n *\n * This class' constructor will register any named types to support recursive\n * schemas. All type values are represented in memory similarly to their JSON\n * representation, except for:\n *\n * + `bytes` and `fixed` which are represented as `Buffer`s.\n * + `union`s which will be \"unwrapped\" unless the `wrapUnions` option is set.\n *\n *  See individual subclasses for details.\n */\nfunction Type(schema, opts) {\n  var type;\n  if (LOGICAL_TYPE) {\n    type = LOGICAL_TYPE;\n    UNDERLYING_TYPES.push([LOGICAL_TYPE, this]);\n    LOGICAL_TYPE = null;\n  } else {\n    type = this;\n  }\n\n  // Lazily instantiated hash string. It will be generated the first time the\n  // type's default fingerprint is computed (for example when using `equals`).\n  // We use a mutable object since types are frozen after instantiation.\n  this._hash = new Hash();\n  this.name = undefined;\n  this.aliases = undefined;\n  this.doc = (schema && schema.doc) ? '' + schema.doc : undefined;\n\n  if (schema) {\n    // This is a complex (i.e. non-primitive) type.\n    var name = schema.name;\n    var namespace = schema.namespace === undefined ?\n      opts && opts.namespace :\n      schema.namespace;\n    if (name !== undefined) {\n      // This isn't an anonymous type.\n      name = maybeQualify(name, namespace);\n      if (isPrimitive(name)) {\n        // Avro doesn't allow redefining primitive names.\n        throw new Error(f('cannot rename primitive type: %j', name));\n      }\n      var registry = opts && opts.registry;\n      if (registry) {\n        if (registry[name] !== undefined) {\n          throw new Error(f('duplicate type name: %s', name));\n        }\n        registry[name] = type;\n      }\n    } else if (opts && opts.noAnonymousTypes) {\n      throw new Error(f('missing name property in schema: %j', schema));\n    }\n    this.name = name;\n    this.aliases = schema.aliases ?\n      schema.aliases.map(function (s) { return maybeQualify(s, namespace); }) :\n      [];\n  }\n}\n\nType.forSchema = function (schema, opts) {\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n\n  var UnionType = (function (wrapUnions) {\n    if (wrapUnions === true) {\n      wrapUnions = 'always';\n    } else if (wrapUnions === false) {\n      wrapUnions = 'never';\n    } else if (wrapUnions === undefined) {\n      wrapUnions = 'auto';\n    } else if (typeof wrapUnions == 'string') {\n      wrapUnions = wrapUnions.toLowerCase();\n    }\n    switch (wrapUnions) {\n      case 'always':\n        return WrappedUnionType;\n      case 'never':\n        return UnwrappedUnionType;\n      case 'auto':\n        return undefined; // Determined dynamically later on.\n      default:\n        throw new Error(f('invalid wrap unions option: %j', wrapUnions));\n    }\n  })(opts.wrapUnions);\n\n  if (schema === null) {\n    // Let's be helpful for this common error.\n    throw new Error('invalid type: null (did you mean \"null\"?)');\n  }\n\n  if (Type.isType(schema)) {\n    return schema;\n  }\n\n  var type;\n  if (opts.typeHook && (type = opts.typeHook(schema, opts))) {\n    if (!Type.isType(type)) {\n      throw new Error(f('invalid typehook return value: %j', type));\n    }\n    return type;\n  }\n\n  if (typeof schema == 'string') { // Type reference.\n    schema = maybeQualify(schema, opts.namespace);\n    type = opts.registry[schema];\n    if (type) {\n      // Type was already defined, return it.\n      return type;\n    }\n    if (isPrimitive(schema)) {\n      // Reference to a primitive type. These are also defined names by default\n      // so we create the appropriate type and it to the registry for future\n      // reference.\n      return opts.registry[schema] = Type.forSchema({type: schema}, opts);\n    }\n    throw new Error(f('undefined type name: %s', schema));\n  }\n\n  if (schema.logicalType && opts.logicalTypes && !LOGICAL_TYPE) {\n    var DerivedType = opts.logicalTypes[schema.logicalType];\n    if (DerivedType) {\n      var namespace = opts.namespace;\n      var registry = {};\n      Object.keys(opts.registry).forEach(function (key) {\n        registry[key] = opts.registry[key];\n      });\n      try {\n        debug('instantiating logical type for %s', schema.logicalType);\n        return new DerivedType(schema, opts);\n      } catch (err) {\n        debug('failed to instantiate logical type for %s', schema.logicalType);\n        if (opts.assertLogicalTypes) {\n          // The spec mandates that we fall through to the underlying type if\n          // the logical type is invalid. We provide this option to ease\n          // debugging.\n          throw err;\n        }\n        LOGICAL_TYPE = null;\n        opts.namespace = namespace;\n        opts.registry = registry;\n      }\n    }\n  }\n\n  if (Array.isArray(schema)) { // Union.\n    // We temporarily clear the logical type since we instantiate the branch's\n    // types before the underlying union's type (necessary to decide whether the\n    // union is ambiguous or not).\n    var logicalType = LOGICAL_TYPE;\n    LOGICAL_TYPE = null;\n    var types = schema.map(function (obj) {\n      return Type.forSchema(obj, opts);\n    });\n    if (!UnionType) {\n      UnionType = isAmbiguous(types) ? WrappedUnionType : UnwrappedUnionType;\n    }\n    LOGICAL_TYPE = logicalType;\n    type = new UnionType(types, opts);\n  } else { // New type definition.\n    type = (function (typeName) {\n      var Type = TYPES[typeName];\n      if (Type === undefined) {\n        throw new Error(f('unknown type: %j', typeName));\n      }\n      return new Type(schema, opts);\n    })(schema.type);\n  }\n  return type;\n};\n\nType.forValue = function (val, opts) {\n  opts = opts || {};\n\n  // Sentinel used when inferring the types of empty arrays.\n  opts.emptyArrayType = opts.emptyArrayType || Type.forSchema({\n    type: 'array', items: 'null'\n  });\n\n  // Optional custom inference hook.\n  if (opts.valueHook) {\n    var type = opts.valueHook(val, opts);\n    if (type !== undefined) {\n      if (!Type.isType(type)) {\n        throw new Error(f('invalid value hook return value: %j', type));\n      }\n      return type;\n    }\n  }\n\n  // Default inference logic.\n  switch (typeof val) {\n    case 'string':\n      return Type.forSchema('string', opts);\n    case 'boolean':\n      return Type.forSchema('boolean', opts);\n    case 'number':\n      if ((val | 0) === val) {\n        return Type.forSchema('int', opts);\n      } else if (Math.abs(val) < 9007199254740991) {\n        return Type.forSchema('float', opts);\n      }\n      return Type.forSchema('double', opts);\n    case 'object':\n      if (val === null) {\n        return Type.forSchema('null', opts);\n      } else if (Array.isArray(val)) {\n        if (!val.length) {\n          return opts.emptyArrayType;\n        }\n        return Type.forSchema({\n          type: 'array',\n          items: Type.forTypes(\n            val.map(function (v) { return Type.forValue(v, opts); }),\n            opts\n          )\n        }, opts);\n      } else if (Buffer.isBuffer(val)) {\n        return Type.forSchema('bytes', opts);\n      }\n      var fieldNames = Object.keys(val);\n      if (fieldNames.some(function (s) { return !utils.isValidName(s); })) {\n        // We have to fall back to a map.\n        return Type.forSchema({\n          type: 'map',\n          values: Type.forTypes(fieldNames.map(function (s) {\n            return Type.forValue(val[s], opts);\n          }), opts)\n        }, opts);\n      }\n      return Type.forSchema({\n        type: 'record',\n        fields: fieldNames.map(function (s) {\n          return {name: s, type: Type.forValue(val[s], opts)};\n        })\n      }, opts);\n    default:\n      throw new Error(f('cannot infer type from: %j', val));\n  }\n};\n\nType.forTypes = function (types, opts) {\n  if (!types.length) {\n    throw new Error('no types to combine');\n  }\n  if (types.length === 1) {\n    return types[0]; // Nothing to do.\n  }\n  opts = opts || {};\n\n  // Extract any union types, with special care for wrapped unions (see below).\n  var expanded = [];\n  var numWrappedUnions = 0;\n  var isValidWrappedUnion = true;\n  types.forEach(function (type) {\n    switch (type.typeName) {\n      case 'union:unwrapped':\n        isValidWrappedUnion = false;\n        expanded = expanded.concat(type.types);\n        break;\n      case 'union:wrapped':\n        numWrappedUnions++;\n        expanded = expanded.concat(type.types);\n        break;\n      case 'null':\n        expanded.push(type);\n        break;\n      default:\n        isValidWrappedUnion = false;\n        expanded.push(type);\n    }\n  });\n  if (numWrappedUnions) {\n    if (!isValidWrappedUnion) {\n      // It is only valid to combine wrapped unions when no other type is\n      // present other than wrapped unions and nulls (otherwise the values of\n      // others wouldn't be valid in the resulting union).\n      throw new Error('cannot combine wrapped union');\n    }\n    var branchTypes = {};\n    expanded.forEach(function (type) {\n      var name = type.branchName;\n      var branchType = branchTypes[name];\n      if (!branchType) {\n        branchTypes[name] = type;\n      } else if (!type.equals(branchType)) {\n        throw new Error('inconsistent branch type');\n      }\n    });\n    var wrapUnions = opts.wrapUnions;\n    var unionType;\n    opts.wrapUnions = true;\n    try {\n      unionType = Type.forSchema(Object.keys(branchTypes).map(function (name) {\n        return branchTypes[name];\n      }), opts);\n    } catch (err) {\n      opts.wrapUnions = wrapUnions;\n      throw err;\n    }\n    opts.wrapUnions = wrapUnions;\n    return unionType;\n  }\n\n  // Group types by category, similar to the logic for unwrapped unions.\n  var bucketized = {};\n  expanded.forEach(function (type) {\n    var bucket = getTypeBucket(type);\n    var bucketTypes = bucketized[bucket];\n    if (!bucketTypes) {\n      bucketized[bucket] = bucketTypes = [];\n    }\n    bucketTypes.push(type);\n  });\n\n  // Generate the \"augmented\" type for each group.\n  var buckets = Object.keys(bucketized);\n  var augmented = buckets.map(function (bucket) {\n    var bucketTypes = bucketized[bucket];\n    if (bucketTypes.length === 1) {\n      return bucketTypes[0];\n    } else {\n      switch (bucket) {\n        case 'null':\n        case 'boolean':\n          return bucketTypes[0];\n        case 'number':\n          return combineNumbers(bucketTypes);\n        case 'string':\n          return combineStrings(bucketTypes, opts);\n        case 'buffer':\n          return combineBuffers(bucketTypes, opts);\n        case 'array':\n          // Remove any sentinel arrays (used when inferring from empty arrays)\n          // to avoid making things nullable when they shouldn't be.\n          bucketTypes = bucketTypes.filter(function (t) {\n            return t !== opts.emptyArrayType;\n          });\n          if (!bucketTypes.length) {\n            // We still don't have a real type, just return the sentinel.\n            return opts.emptyArrayType;\n          }\n          return Type.forSchema({\n            type: 'array',\n            items: Type.forTypes(bucketTypes.map(function (t) {\n              return t.itemsType;\n            }), opts)\n          }, opts);\n        default:\n          return combineObjects(bucketTypes, opts);\n      }\n    }\n  });\n\n  if (augmented.length === 1) {\n    return augmented[0];\n  } else {\n    // We return an (unwrapped) union of all augmented types.\n    return Type.forSchema(augmented, opts);\n  }\n};\n\nType.isType = function (/* any, [prefix] ... */) {\n  var l = arguments.length;\n  if (!l) {\n    return false;\n  }\n\n  var any = arguments[0];\n  if (\n    !any ||\n    typeof any._update != 'function' ||\n    typeof any.fingerprint != 'function'\n  ) {\n    // Not fool-proof, but most likely good enough.\n    return false;\n  }\n\n  if (l === 1) {\n    // No type names specified, we are done.\n    return true;\n  }\n\n  // We check if at least one of the prefixes matches.\n  var typeName = any.typeName;\n  var i;\n  for (i = 1; i < l; i++) {\n    if (typeName.indexOf(arguments[i]) === 0) {\n      return true;\n    }\n  }\n  return false;\n};\n\nType.__reset = function (size) {\n  debug('resetting type buffer to %d', size);\n  TAP.buf = new buffer.SlowBuffer(size);\n};\n\nObject.defineProperty(Type.prototype, 'branchName', {\n  enumerable: true,\n  get: function () {\n    var type = Type.isType(this, 'logical') ? this.underlyingType : this;\n    if (type.name) {\n      return type.name;\n    }\n    if (Type.isType(type, 'abstract')) {\n      return type._concreteTypeName;\n    }\n    return Type.isType(type, 'union') ? undefined : type.typeName;\n  }\n});\n\nType.prototype.clone = function (val, opts) {\n  if (opts) {\n    opts = {\n      coerce: !!opts.coerceBuffers | 0, // Coerce JSON to Buffer.\n      fieldHook: opts.fieldHook,\n      qualifyNames: !!opts.qualifyNames,\n      skip: !!opts.skipMissingFields,\n      wrap: !!opts.wrapUnions | 0 // Wrap first match into union.\n    };\n    return this._copy(val, opts);\n  } else {\n    // If no modifications are required, we can get by with a serialization\n    // roundtrip (generally much faster than a standard deep copy).\n    return this.fromBuffer(this.toBuffer(val));\n  }\n};\n\nType.prototype.compare = utils.abstractFunction;\n\nType.prototype.compareBuffers = function (buf1, buf2) {\n  return this._match(new Tap(buf1), new Tap(buf2));\n};\n\nType.prototype.createResolver = function (type, opts) {\n  if (!Type.isType(type)) {\n    // More explicit error message than the \"incompatible type\" thrown\n    // otherwise (especially because of the overridden `toJSON` method).\n    throw new Error(f('not a type: %j', type));\n  }\n\n  if (!Type.isType(this, 'union', 'logical') && Type.isType(type, 'logical')) {\n    // Trying to read a logical type as a built-in: unwrap the logical type.\n    // Note that we exclude unions to support resolving into unions containing\n    // logical types.\n    return this.createResolver(type.underlyingType, opts);\n  }\n\n  opts = opts || {};\n  opts.registry = opts.registry || {};\n\n  var resolver, key;\n  if (\n    Type.isType(this, 'record', 'error') &&\n    Type.isType(type, 'record', 'error')\n  ) {\n    // We allow conversions between records and errors.\n    key = this.name + ':' + type.name; // ':' is illegal in Avro type names.\n    resolver = opts.registry[key];\n    if (resolver) {\n      return resolver;\n    }\n  }\n\n  resolver = new Resolver(this);\n  if (key) { // Register resolver early for recursive schemas.\n    opts.registry[key] = resolver;\n  }\n\n  if (Type.isType(type, 'union')) {\n    var resolvers = type.types.map(function (t) {\n      return this.createResolver(t, opts);\n    }, this);\n    resolver._read = function (tap) {\n      var index = tap.readLong();\n      var resolver = resolvers[index];\n      if (resolver === undefined) {\n        throw new Error(f('invalid union index: %s', index));\n      }\n      return resolvers[index]._read(tap);\n    };\n  } else {\n    this._update(resolver, type, opts);\n  }\n\n  if (!resolver._read) {\n    throw new Error(f('cannot read %s as %s', type, this));\n  }\n  return Object.freeze(resolver);\n};\n\nType.prototype.decode = function (buf, pos, resolver) {\n  var tap = new Tap(buf, pos);\n  var val = readValue(this, tap, resolver);\n  if (!tap.isValid()) {\n    return {value: undefined, offset: -1};\n  }\n  return {value: val, offset: tap.pos};\n};\n\nType.prototype.encode = function (val, buf, pos) {\n  var tap = new Tap(buf, pos);\n  this._write(tap, val);\n  if (!tap.isValid()) {\n    // Don't throw as there is no way to predict this. We also return the\n    // number of missing bytes to ease resizing.\n    return buf.length - tap.pos;\n  }\n  return tap.pos;\n};\n\nType.prototype.equals = function (type, opts) {\n  var canon = ( // Canonical equality.\n    Type.isType(type) &&\n    this.fingerprint().equals(type.fingerprint())\n  );\n  if (!canon || !(opts && opts.strict)) {\n    return canon;\n  }\n  return (\n    JSON.stringify(this.schema({exportAttrs: true})) ===\n    JSON.stringify(type.schema({exportAttrs: true}))\n  );\n};\n\nType.prototype.fingerprint = function (algorithm) {\n  if (!algorithm) {\n    if (!this._hash.str) {\n      var schemaStr = JSON.stringify(this.schema());\n      this._hash.str = utils.getHash(schemaStr).toString('binary');\n    }\n    return utils.bufferFrom(this._hash.str, 'binary');\n  } else {\n    return utils.getHash(JSON.stringify(this.schema()), algorithm);\n  }\n};\n\nType.prototype.fromBuffer = function (buf, resolver, noCheck) {\n  var tap = new Tap(buf);\n  var val = readValue(this, tap, resolver, noCheck);\n  if (!tap.isValid()) {\n    throw new Error('truncated buffer');\n  }\n  if (!noCheck && tap.pos < buf.length) {\n    throw new Error('trailing data');\n  }\n  return val;\n};\n\nType.prototype.fromString = function (str) {\n  return this._copy(JSON.parse(str), {coerce: 2});\n};\n\nType.prototype.inspect = function () {\n  var typeName = this.typeName;\n  var className = getClassName(typeName);\n  if (isPrimitive(typeName)) {\n    // The class name is sufficient to identify the type.\n    return f('<%s>', className);\n  } else {\n    // We add a little metadata for convenience.\n    var obj = this.schema({exportAttrs: true, noDeref: true});\n    if (typeof obj == 'object' && !Type.isType(this, 'logical')) {\n      obj.type = undefined; // Would be redundant with constructor name.\n    }\n    return f('<%s %j>', className, obj);\n  }\n};\n\nType.prototype.isValid = function (val, opts) {\n  // We only have a single flag for now, so no need to complicate things.\n  var flags = (opts && opts.noUndeclaredFields) | 0;\n  var errorHook = opts && opts.errorHook;\n  var hook, path;\n  if (errorHook) {\n    path = [];\n    hook = function (any, type) {\n      errorHook.call(this, path.slice(), any, type, val);\n    };\n  }\n  return this._check(val, flags, hook, path);\n};\n\nType.prototype.random = utils.abstractFunction;\n\nType.prototype.schema = function (opts) {\n  // Copy the options to avoid mutating the original options object when we add\n  // the registry of dereferenced types.\n  return this._attrs({\n    exportAttrs: !!(opts && opts.exportAttrs),\n    noDeref: !!(opts && opts.noDeref)\n  });\n};\n\nType.prototype.toBuffer = function (val) {\n  TAP.pos = 0;\n  this._write(TAP, val);\n  var buf = utils.newBuffer(TAP.pos);\n  if (TAP.isValid()) {\n    TAP.buf.copy(buf, 0, 0, TAP.pos);\n  } else {\n    this._write(new Tap(buf), val);\n  }\n  return buf;\n};\n\nType.prototype.toJSON = function () {\n  // Convenience to allow using `JSON.stringify(type)` to get a type's schema.\n  return this.schema({exportAttrs: true});\n};\n\nType.prototype.toString = function (val) {\n  if (val === undefined) {\n    // Consistent behavior with standard `toString` expectations.\n    return JSON.stringify(this.schema({noDeref: true}));\n  }\n  return JSON.stringify(this._copy(val, {coerce: 3}));\n};\n\nType.prototype.wrap = function (val) {\n  var Branch = this._branchConstructor;\n  return Branch === null ? null : new Branch(val);\n};\n\nType.prototype._attrs = function (opts) {\n  // This function handles a lot of the common logic to schema generation\n  // across types, for example keeping track of which types have already been\n  // de-referenced (i.e. derefed).\n  opts.derefed = opts.derefed || {};\n  var name = this.name;\n  if (name !== undefined) {\n    if (opts.noDeref || opts.derefed[name]) {\n      return name;\n    }\n    opts.derefed[name] = true;\n  }\n  var schema = {};\n  // The order in which we add fields to the `schema` object matters here.\n  // Since JS objects are unordered, this implementation (unfortunately) relies\n  // on engines returning properties in the same order that they are inserted\n  // in. This is not in the JS spec, but can be \"somewhat\" safely assumed (see\n  // http://stackoverflow.com/q/5525795/1062617).\n  if (this.name !== undefined) {\n    schema.name = name;\n  }\n  schema.type = this.typeName;\n  var derefedSchema = this._deref(schema, opts);\n  if (derefedSchema !== undefined) {\n    // We allow the original schema to be overridden (this will happen for\n    // primitive types and logical types).\n    schema = derefedSchema;\n  }\n  if (opts.exportAttrs) {\n    if (this.aliases && this.aliases.length) {\n      schema.aliases = this.aliases;\n    }\n    if (this.doc !== undefined) {\n      schema.doc = this.doc;\n    }\n  }\n  return schema;\n};\n\nType.prototype._createBranchConstructor = function () {\n  // jshint -W054\n  var name = this.branchName;\n  if (name === 'null') {\n    return null;\n  }\n  var attr = ~name.indexOf('.') ? 'this[\\'' + name + '\\']' : 'this.' + name;\n  var body = 'return function Branch$(val) { ' + attr + ' = val; };';\n  var Branch = (new Function(body))();\n  Branch.type = this;\n  Branch.prototype.unwrap = new Function('return ' + attr + ';');\n  Branch.prototype.unwrapped = Branch.prototype.unwrap; // Deprecated.\n  return Branch;\n};\n\nType.prototype._peek = function (tap) {\n  var pos = tap.pos;\n  var val = this._read(tap);\n  tap.pos = pos;\n  return val;\n};\n\nType.prototype._check = utils.abstractFunction;\nType.prototype._copy = utils.abstractFunction;\nType.prototype._deref = utils.abstractFunction;\nType.prototype._match = utils.abstractFunction;\nType.prototype._read = utils.abstractFunction;\nType.prototype._skip = utils.abstractFunction;\nType.prototype._update = utils.abstractFunction;\nType.prototype._write = utils.abstractFunction;\n\n// \"Deprecated\" getters (will be explicitly deprecated in 5.1).\n\nType.prototype.getAliases = function () { return this.aliases; };\n\nType.prototype.getFingerprint = Type.prototype.fingerprint;\n\nType.prototype.getName = function (asBranch) {\n  return (this.name || !asBranch) ? this.name : this.branchName;\n};\n\nType.prototype.getSchema = Type.prototype.schema;\n\nType.prototype.getTypeName = function () { return this.typeName; };\n\n// Implementations.\n\n/**\n * Base primitive Avro type.\n *\n * Most of the primitive types share the same cloning and resolution\n * mechanisms, provided by this class. This class also lets us conveniently\n * check whether a type is a primitive using `instanceof`.\n */\nfunction PrimitiveType(noFreeze) {\n  Type.call(this);\n  this._branchConstructor = this._createBranchConstructor();\n  if (!noFreeze) {\n    // Abstract long types can't be frozen at this stage.\n    Object.freeze(this);\n  }\n}\nutil.inherits(PrimitiveType, Type);\n\nPrimitiveType.prototype._update = function (resolver, type) {\n  if (type.typeName === this.typeName) {\n    resolver._read = this._read;\n  }\n};\n\nPrimitiveType.prototype._copy = function (val) {\n  this._check(val, undefined, throwInvalidError);\n  return val;\n};\n\nPrimitiveType.prototype._deref = function () { return this.typeName; };\n\nPrimitiveType.prototype.compare = utils.compare;\n\n/** Nulls. */\nfunction NullType() { PrimitiveType.call(this); }\nutil.inherits(NullType, PrimitiveType);\n\nNullType.prototype._check = function (val, flags, hook) {\n  var b = val === null;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nNullType.prototype._read = function () { return null; };\n\nNullType.prototype._skip = function () {};\n\nNullType.prototype._write = function (tap, val) {\n  if (val !== null) {\n    throwInvalidError(val, this);\n  }\n};\n\nNullType.prototype._match = function () { return 0; };\n\nNullType.prototype.compare = NullType.prototype._match;\n\nNullType.prototype.typeName = 'null';\n\nNullType.prototype.random = NullType.prototype._read;\n\n/** Booleans. */\nfunction BooleanType() { PrimitiveType.call(this); }\nutil.inherits(BooleanType, PrimitiveType);\n\nBooleanType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'boolean';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nBooleanType.prototype._read = function (tap) { return tap.readBoolean(); };\n\nBooleanType.prototype._skip = function (tap) { tap.skipBoolean(); };\n\nBooleanType.prototype._write = function (tap, val) {\n  if (typeof val != 'boolean') {\n    throwInvalidError(val, this);\n  }\n  tap.writeBoolean(val);\n};\n\nBooleanType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBoolean(tap2);\n};\n\nBooleanType.prototype.typeName = 'boolean';\n\nBooleanType.prototype.random = function () { return RANDOM.nextBoolean(); };\n\n/** Integers. */\nfunction IntType() { PrimitiveType.call(this); }\nutil.inherits(IntType, PrimitiveType);\n\nIntType.prototype._check = function (val, flags, hook) {\n  var b = val === (val | 0);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nIntType.prototype._read = function (tap) { return tap.readInt(); };\n\nIntType.prototype._skip = function (tap) { tap.skipInt(); };\n\nIntType.prototype._write = function (tap, val) {\n  if (val !== (val | 0)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeInt(val);\n};\n\nIntType.prototype._match = function (tap1, tap2) {\n  return tap1.matchInt(tap2);\n};\n\nIntType.prototype.typeName = 'int';\n\nIntType.prototype.random = function () { return RANDOM.nextInt(1000) | 0; };\n\n/**\n * Longs.\n *\n * We can't capture all the range unfortunately since JavaScript represents all\n * numbers internally as `double`s, so the default implementation plays safe\n * and throws rather than potentially silently change the data. See `__with` or\n * `AbstractLongType` below for a way to implement a custom long type.\n */\nfunction LongType() { PrimitiveType.call(this); }\nutil.inherits(LongType, PrimitiveType);\n\nLongType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nLongType.prototype._read = function (tap) {\n  var n = tap.readLong();\n  if (!isSafeLong(n)) {\n    throw new Error('potential precision loss');\n  }\n  return n;\n};\n\nLongType.prototype._skip = function (tap) { tap.skipLong(); };\n\nLongType.prototype._write = function (tap, val) {\n  if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(val);\n};\n\nLongType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\n\nLongType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      resolver._read = this._read; // In case `type` is an `AbstractLongType`.\n  }\n};\n\nLongType.prototype.typeName = 'long';\n\nLongType.prototype.random = function () { return RANDOM.nextInt(); };\n\nLongType.__with = function (methods, noUnpack) {\n  methods = methods || {}; // Will give a more helpful error message.\n  // We map some of the methods to a different name to be able to intercept\n  // their input and output (otherwise we wouldn't be able to perform any\n  // unpacking logic, and the type wouldn't work when nested).\n  var mapping = {\n    toBuffer: '_toBuffer',\n    fromBuffer: '_fromBuffer',\n    fromJSON: '_fromJSON',\n    toJSON: '_toJSON',\n    isValid: '_isValid',\n    compare: 'compare'\n  };\n  var type = new AbstractLongType(noUnpack);\n  Object.keys(mapping).forEach(function (name) {\n    if (methods[name] === undefined) {\n      throw new Error(f('missing method implementation: %s', name));\n    }\n    type[mapping[name]] = methods[name];\n  });\n  return Object.freeze(type);\n};\n\n/** Floats. */\nfunction FloatType() { PrimitiveType.call(this); }\nutil.inherits(FloatType, PrimitiveType);\n\nFloatType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nFloatType.prototype._read = function (tap) { return tap.readFloat(); };\n\nFloatType.prototype._skip = function (tap) { tap.skipFloat(); };\n\nFloatType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(val, this);\n  }\n  tap.writeFloat(val);\n};\n\nFloatType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFloat(tap2);\n};\n\nFloatType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'float':\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      // No need to worry about precision loss here since we're always rounding\n      // to float anyway.\n      resolver._read = function (tap) { return tap.readLong(); };\n  }\n};\n\nFloatType.prototype.typeName = 'float';\n\nFloatType.prototype.random = function () { return RANDOM.nextFloat(1e3); };\n\n/** Doubles. */\nfunction DoubleType() { PrimitiveType.call(this); }\nutil.inherits(DoubleType, PrimitiveType);\n\nDoubleType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'number';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nDoubleType.prototype._read = function (tap) { return tap.readDouble(); };\n\nDoubleType.prototype._skip = function (tap) { tap.skipDouble(); };\n\nDoubleType.prototype._write = function (tap, val) {\n  if (typeof val != 'number') {\n    throwInvalidError(val, this);\n  }\n  tap.writeDouble(val);\n};\n\nDoubleType.prototype._match = function (tap1, tap2) {\n  return tap1.matchDouble(tap2);\n};\n\nDoubleType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'double':\n    case 'float':\n    case 'int':\n      resolver._read = type._read;\n      break;\n    case 'abstract:long':\n    case 'long':\n      // Similar to inside `FloatType`, no need to worry about precision loss\n      // here since we're always rounding to double anyway.\n      resolver._read = function (tap) { return tap.readLong(); };\n  }\n};\n\nDoubleType.prototype.typeName = 'double';\n\nDoubleType.prototype.random = function () { return RANDOM.nextFloat(); };\n\n/** Strings. */\nfunction StringType() { PrimitiveType.call(this); }\nutil.inherits(StringType, PrimitiveType);\n\nStringType.prototype._check = function (val, flags, hook) {\n  var b = typeof val == 'string';\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nStringType.prototype._read = function (tap) { return tap.readString(); };\n\nStringType.prototype._skip = function (tap) { tap.skipString(); };\n\nStringType.prototype._write = function (tap, val) {\n  if (typeof val != 'string') {\n    throwInvalidError(val, this);\n  }\n  tap.writeString(val);\n};\n\nStringType.prototype._match = function (tap1, tap2) {\n  return tap1.matchString(tap2);\n};\n\nStringType.prototype._update = function (resolver, type) {\n  switch (type.typeName) {\n    case 'bytes':\n    case 'string':\n      resolver._read = this._read;\n  }\n};\n\nStringType.prototype.typeName = 'string';\n\nStringType.prototype.random = function () {\n  return RANDOM.nextString(RANDOM.nextInt(32));\n};\n\n/**\n * Bytes.\n *\n * These are represented in memory as `Buffer`s rather than binary-encoded\n * strings. This is more efficient (when decoding/encoding from bytes, the\n * common use-case), idiomatic, and convenient.\n *\n * Note the coercion in `_copy`.\n */\nfunction BytesType() { PrimitiveType.call(this); }\nutil.inherits(BytesType, PrimitiveType);\n\nBytesType.prototype._check = function (val, flags, hook) {\n  var b = Buffer.isBuffer(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nBytesType.prototype._read = function (tap) { return tap.readBytes(); };\n\nBytesType.prototype._skip = function (tap) { tap.skipBytes(); };\n\nBytesType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val)) {\n    throwInvalidError(val, this);\n  }\n  tap.writeBytes(val);\n};\n\nBytesType.prototype._match = function (tap1, tap2) {\n  return tap1.matchBytes(tap2);\n};\n\nBytesType.prototype._update = StringType.prototype._update;\n\nBytesType.prototype._copy = function (obj, opts) {\n  var buf;\n  switch ((opts && opts.coerce) | 0) {\n    case 3: // Coerce buffers to strings.\n      this._check(obj, undefined, throwInvalidError);\n      return obj.toString('binary');\n    case 2: // Coerce strings to buffers.\n      if (typeof obj != 'string') {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = utils.bufferFrom(obj, 'binary');\n      this._check(buf, undefined, throwInvalidError);\n      return buf;\n    case 1: // Coerce buffer JSON representation to buffers.\n      if (!isJsonBuffer(obj)) {\n        throw new Error(f('cannot coerce to buffer: %j', obj));\n      }\n      buf = utils.bufferFrom(obj.data);\n      this._check(buf, undefined, throwInvalidError);\n      return buf;\n    default: // Copy buffer.\n      this._check(obj, undefined, throwInvalidError);\n      return utils.bufferFrom(obj);\n  }\n};\n\nBytesType.prototype.compare = Buffer.compare;\n\nBytesType.prototype.typeName = 'bytes';\n\nBytesType.prototype.random = function () {\n  return RANDOM.nextBuffer(RANDOM.nextInt(32));\n};\n\n/** Base \"abstract\" Avro union type. */\nfunction UnionType(schema, opts) {\n  Type.call(this);\n\n  if (!Array.isArray(schema)) {\n    throw new Error(f('non-array union schema: %j', schema));\n  }\n  if (!schema.length) {\n    throw new Error('empty union');\n  }\n  this.types = Object.freeze(schema.map(function (obj) {\n    return Type.forSchema(obj, opts);\n  }));\n\n  this._branchIndices = {};\n  this.types.forEach(function (type, i) {\n    if (Type.isType(type, 'union')) {\n      throw new Error('unions cannot be directly nested');\n    }\n    var branch = type.branchName;\n    if (this._branchIndices[branch] !== undefined) {\n      throw new Error(f('duplicate union branch name: %j', branch));\n    }\n    this._branchIndices[branch] = i;\n  }, this);\n}\nutil.inherits(UnionType, Type);\n\nUnionType.prototype._branchConstructor = function () {\n  throw new Error('unions cannot be directly wrapped');\n};\n\nUnionType.prototype._skip = function (tap) {\n  this.types[tap.readLong()]._skip(tap);\n};\n\nUnionType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  if (n1 === n2) {\n    return this.types[n1]._match(tap1, tap2);\n  } else {\n    return n1 < n2 ? -1 : 1;\n  }\n};\n\nUnionType.prototype._deref = function (schema, opts) {\n  return this.types.map(function (t) { return t._attrs(opts); });\n};\n\nUnionType.prototype.getTypes = function () { return this.types; };\n\n/**\n * \"Natural\" union type.\n *\n * This representation doesn't require a wrapping object and is therefore\n * simpler and generally closer to what users expect. However it cannot be used\n * to represent all Avro unions since some lead to ambiguities (e.g. if two\n * number types are in the union).\n *\n * Currently, this union supports at most one type in each of the categories\n * below:\n *\n * + `null`\n * + `boolean`\n * + `int`, `long`, `float`, `double`\n * + `string`, `enum`\n * + `bytes`, `fixed`\n * + `array`\n * + `map`, `record`\n */\nfunction UnwrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n\n  this._dynamicBranches = null;\n  this._bucketIndices = {};\n  this.types.forEach(function (type, index) {\n    if (Type.isType(type, 'abstract', 'logical')) {\n      if (!this._dynamicBranches) {\n        this._dynamicBranches = [];\n      }\n      this._dynamicBranches.push({index: index, type: type});\n    } else {\n      var bucket = getTypeBucket(type);\n      if (this._bucketIndices[bucket] !== undefined) {\n        throw new Error(f('ambiguous unwrapped union: %j', this));\n      }\n      this._bucketIndices[bucket] = index;\n    }\n  }, this);\n\n  Object.freeze(this);\n}\nutil.inherits(UnwrappedUnionType, UnionType);\n\nUnwrappedUnionType.prototype._getIndex = function (val) {\n  var index = this._bucketIndices[getValueBucket(val)];\n  if (this._dynamicBranches) {\n    // Slower path, we must run the value through all branches.\n    index = this._getBranchIndex(val, index);\n  }\n  return index;\n};\n\nUnwrappedUnionType.prototype._getBranchIndex = function (any, index) {\n  var logicalBranches = this._dynamicBranches;\n  var i, l, branch;\n  for (i = 0, l = logicalBranches.length; i < l; i++) {\n    branch = logicalBranches[i];\n    if (branch.type._check(any)) {\n      if (index === undefined) {\n        index = branch.index;\n      } else {\n        // More than one branch matches the value so we aren't guaranteed to\n        // infer the correct type. We throw rather than corrupt data. This can\n        // be fixed by \"tightening\" the logical types.\n        throw new Error('ambiguous conversion');\n      }\n    }\n  }\n  return index;\n};\n\nUnwrappedUnionType.prototype._check = function (val, flags, hook, path) {\n  var index = this._getIndex(val);\n  var b = index !== undefined;\n  if (b) {\n    return this.types[index]._check(val, flags, hook, path);\n  }\n  if (hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nUnwrappedUnionType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var branchType = this.types[index];\n  if (branchType) {\n    return branchType._read(tap);\n  } else {\n    throw new Error(f('invalid union index: %s', index));\n  }\n};\n\nUnwrappedUnionType.prototype._write = function (tap, val) {\n  var index = this._getIndex(val);\n  if (index === undefined) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(index);\n  if (val !== null) {\n    this.types[index]._write(tap, val);\n  }\n};\n\nUnwrappedUnionType.prototype._update = function (resolver, type, opts) {\n  // jshint -W083\n  // (The loop exits after the first function is created.)\n  var i, l, typeResolver;\n  for (i = 0, l = this.types.length; i < l; i++) {\n    try {\n      typeResolver = this.types[i].createResolver(type, opts);\n    } catch (err) {\n      continue;\n    }\n    resolver._read = function (tap) { return typeResolver._read(tap); };\n    return;\n  }\n};\n\nUnwrappedUnionType.prototype._copy = function (val, opts) {\n  var coerce = opts && opts.coerce | 0;\n  var wrap = opts && opts.wrap | 0;\n  var index;\n  if (wrap === 2) {\n    // We are parsing a default, so always use the first branch's type.\n    index = 0;\n  } else {\n    switch (coerce) {\n      case 1:\n        // Using the `coerceBuffers` option can cause corruption and erroneous\n        // failures with unwrapped unions (in rare cases when the union also\n        // contains a record which matches a buffer's JSON representation).\n        if (isJsonBuffer(val) && this._bucketIndices.buffer !== undefined) {\n          index = this._bucketIndices.buffer;\n        } else {\n          index = this._getIndex(val);\n        }\n        break;\n      case 2:\n        // Decoding from JSON, we must unwrap the value.\n        if (val === null) {\n          index = this._bucketIndices['null'];\n        } else if (typeof val === 'object') {\n          var keys = Object.keys(val);\n          if (keys.length === 1) {\n            index = this._branchIndices[keys[0]];\n            val = val[keys[0]];\n          }\n        }\n        break;\n      default:\n        index = this._getIndex(val);\n    }\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n  }\n  var type = this.types[index];\n  if (val === null || wrap === 3) {\n    return type._copy(val, opts);\n  } else {\n    switch (coerce) {\n      case 3:\n        // Encoding to JSON, we wrap the value.\n        var obj = {};\n        obj[type.branchName] = type._copy(val, opts);\n        return obj;\n      default:\n        return type._copy(val, opts);\n    }\n  }\n};\n\nUnwrappedUnionType.prototype.compare = function (val1, val2) {\n  var index1 = this._getIndex(val1);\n  var index2 = this._getIndex(val2);\n  if (index1 === undefined) {\n    throwInvalidError(val1, this);\n  } else if (index2 === undefined) {\n    throwInvalidError(val2, this);\n  } else if (index1 === index2) {\n    return this.types[index1].compare(val1, val2);\n  } else {\n    return utils.compare(index1, index2);\n  }\n};\n\nUnwrappedUnionType.prototype.typeName = 'union:unwrapped';\n\nUnwrappedUnionType.prototype.random = function () {\n  var index = RANDOM.nextInt(this.types.length);\n  return this.types[index].random();\n};\n\n/**\n * Compatible union type.\n *\n * Values of this type are represented in memory similarly to their JSON\n * representation (i.e. inside an object with single key the name of the\n * contained type).\n *\n * This is not ideal, but is the most efficient way to unambiguously support\n * all unions. Here are a few reasons why the wrapping object is necessary:\n *\n * + Unions with multiple number types would have undefined behavior, unless\n *   numbers are wrapped (either everywhere, leading to large performance and\n *   convenience costs; or only when necessary inside unions, making it hard to\n *   understand when numbers are wrapped or not).\n * + Fixed types would have to be wrapped to be distinguished from bytes.\n * + Using record's constructor names would work (after a slight change to use\n *   the fully qualified name), but would mean that generic objects could no\n *   longer be valid records (making it inconvenient to do simple things like\n *   creating new records).\n */\nfunction WrappedUnionType(schema, opts) {\n  UnionType.call(this, schema, opts);\n  Object.freeze(this);\n}\nutil.inherits(WrappedUnionType, UnionType);\n\nWrappedUnionType.prototype._check = function (val, flags, hook, path) {\n  var b = false;\n  if (val === null) {\n    // Shortcut type lookup in this case.\n    b = this._branchIndices['null'] !== undefined;\n  } else if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      // We require a single key here to ensure that writes are correct and\n      // efficient as soon as a record passes this check.\n      var name = keys[0];\n      var index = this._branchIndices[name];\n      if (index !== undefined) {\n        if (hook) {\n          // Slow path.\n          path.push(name);\n          b = this.types[index]._check(val[name], flags, hook, path);\n          path.pop();\n          return b;\n        } else {\n          return this.types[index]._check(val[name], flags);\n        }\n      }\n    }\n  }\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nWrappedUnionType.prototype._read = function (tap) {\n  var type = this.types[tap.readLong()];\n  if (!type) {\n    throw new Error(f('invalid union index'));\n  }\n  var Branch = type._branchConstructor;\n  if (Branch === null) {\n    return null;\n  } else {\n    return new Branch(type._read(tap));\n  }\n};\n\nWrappedUnionType.prototype._write = function (tap, val) {\n  var index, keys, name;\n  if (val === null) {\n    index = this._branchIndices['null'];\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n    tap.writeLong(index);\n  } else {\n    keys = Object.keys(val);\n    if (keys.length === 1) {\n      name = keys[0];\n      index = this._branchIndices[name];\n    }\n    if (index === undefined) {\n      throwInvalidError(val, this);\n    }\n    tap.writeLong(index);\n    this.types[index]._write(tap, val[name]);\n  }\n};\n\nWrappedUnionType.prototype._update = function (resolver, type, opts) {\n  // jshint -W083\n  // (The loop exits after the first function is created.)\n  var i, l, typeResolver, Branch;\n  for (i = 0, l = this.types.length; i < l; i++) {\n    try {\n      typeResolver = this.types[i].createResolver(type, opts);\n    } catch (err) {\n      continue;\n    }\n    Branch = this.types[i]._branchConstructor;\n    if (Branch) {\n      resolver._read = function (tap) {\n        return new Branch(typeResolver._read(tap));\n      };\n    } else {\n      resolver._read = function () { return null; };\n    }\n    return;\n  }\n};\n\nWrappedUnionType.prototype._copy = function (val, opts) {\n  var wrap = opts && opts.wrap | 0;\n  if (wrap === 2) {\n    var firstType = this.types[0];\n    // Promote into first type (used for schema defaults).\n    if (val === null && firstType.typeName === 'null') {\n      return null;\n    }\n    return new firstType._branchConstructor(firstType._copy(val, opts));\n  }\n  if (val === null && this._branchIndices['null'] !== undefined) {\n    return null;\n  }\n\n  var i, l, obj;\n  if (typeof val == 'object') {\n    var keys = Object.keys(val);\n    if (keys.length === 1) {\n      var name = keys[0];\n      i = this._branchIndices[name];\n      if (i === undefined && opts.qualifyNames) {\n        // We are a bit more flexible than in `_check` here since we have\n        // to deal with other serializers being less strict, so we fall\n        // back to looking up unqualified names.\n        var j, type;\n        for (j = 0, l = this.types.length; j < l; j++) {\n          type = this.types[j];\n          if (type.name && name === utils.unqualify(type.name)) {\n            i = j;\n            break;\n          }\n        }\n      }\n      if (i !== undefined) {\n        obj = this.types[i]._copy(val[name], opts);\n      }\n    }\n  }\n  if (wrap === 1 && obj === undefined) {\n    // Try promoting into first match (convenience, slow).\n    i = 0;\n    l = this.types.length;\n    while (i < l && obj === undefined) {\n      try {\n        obj = this.types[i]._copy(val, opts);\n      } catch (err) {\n        i++;\n      }\n    }\n  }\n  if (obj !== undefined) {\n    return wrap === 3 ? obj : new this.types[i]._branchConstructor(obj);\n  }\n  throwInvalidError(val, this);\n};\n\nWrappedUnionType.prototype.compare = function (val1, val2) {\n  var name1 = val1 === null ? 'null' : Object.keys(val1)[0];\n  var name2 = val2 === null ? 'null' : Object.keys(val2)[0];\n  var index = this._branchIndices[name1];\n  if (name1 === name2) {\n    return name1 === 'null' ?\n      0 :\n      this.types[index].compare(val1[name1], val2[name1]);\n  } else {\n    return utils.compare(index, this._branchIndices[name2]);\n  }\n};\n\nWrappedUnionType.prototype.typeName = 'union:wrapped';\n\nWrappedUnionType.prototype.random = function () {\n  var index = RANDOM.nextInt(this.types.length);\n  var type = this.types[index];\n  var Branch = type._branchConstructor;\n  if (!Branch) {\n    return null;\n  }\n  return new Branch(type.random());\n};\n\n/**\n * Avro enum type.\n *\n * Represented as strings (with allowed values from the set of symbols). Using\n * integers would be a reasonable option, but the performance boost is arguably\n * offset by the legibility cost and the extra deviation from the JSON encoding\n * convention.\n *\n * An integer representation can still be used (e.g. for compatibility with\n * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via\n * `parse`'s registry).\n */\nfunction EnumType(schema, opts) {\n  Type.call(this, schema, opts);\n  if (!Array.isArray(schema.symbols) || !schema.symbols.length) {\n    throw new Error(f('invalid enum symbols: %j', schema.symbols));\n  }\n  this.symbols = Object.freeze(schema.symbols.slice());\n  this._indices = {};\n  this.symbols.forEach(function (symbol, i) {\n    if (!utils.isValidName(symbol)) {\n      throw new Error(f('invalid %s symbol: %j', this, symbol));\n    }\n    if (this._indices[symbol] !== undefined) {\n      throw new Error(f('duplicate %s symbol: %j', this, symbol));\n    }\n    this._indices[symbol] = i;\n  }, this);\n  this.default = schema.default;\n  if (this.default !== undefined && this._indices[this.default] === undefined) {\n    throw new Error(f('invalid %s default: %j', this, this.default));\n  }\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(EnumType, Type);\n\nEnumType.prototype._check = function (val, flags, hook) {\n  var b = this._indices[val] !== undefined;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nEnumType.prototype._read = function (tap) {\n  var index = tap.readLong();\n  var symbol = this.symbols[index];\n  if (symbol === undefined) {\n    throw new Error(f('invalid %s enum index: %s', this.name, index));\n  }\n  return symbol;\n};\n\nEnumType.prototype._skip = function (tap) { tap.skipLong(); };\n\nEnumType.prototype._write = function (tap, val) {\n  var index = this._indices[val];\n  if (index === undefined) {\n    throwInvalidError(val, this);\n  }\n  tap.writeLong(index);\n};\n\nEnumType.prototype._match = function (tap1, tap2) {\n  return tap1.matchLong(tap2);\n};\n\nEnumType.prototype.compare = function (val1, val2) {\n  return utils.compare(this._indices[val1], this._indices[val2]);\n};\n\nEnumType.prototype._update = function (resolver, type, opts) {\n  var symbols = this.symbols;\n  if (\n    type.typeName === 'enum' &&\n    hasCompatibleName(this, type, !opts.ignoreNamespaces) &&\n    (\n      type.symbols.every(function (s) { return ~symbols.indexOf(s); }) ||\n      this.default !== undefined\n    )\n  ) {\n    resolver.symbols = type.symbols.map(function (s) {\n      return this._indices[s] === undefined ? this.default : s;\n    }, this);\n    resolver._read = type._read;\n  }\n};\n\nEnumType.prototype._copy = function (val) {\n  this._check(val, undefined, throwInvalidError);\n  return val;\n};\n\nEnumType.prototype._deref = function (schema) {\n  schema.symbols = this.symbols;\n};\n\nEnumType.prototype.getSymbols = function () { return this.symbols; };\n\nEnumType.prototype.typeName = 'enum';\n\nEnumType.prototype.random = function () {\n  return RANDOM.choice(this.symbols);\n};\n\n/** Avro fixed type. Represented simply as a `Buffer`. */\nfunction FixedType(schema, opts) {\n  Type.call(this, schema, opts);\n  if (schema.size !== (schema.size | 0) || schema.size < 0) {\n    throw new Error(f('invalid %s size', this.branchName));\n  }\n  this.size = schema.size | 0;\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(FixedType, Type);\n\nFixedType.prototype._check = function (val, flags, hook) {\n  var b = Buffer.isBuffer(val) && val.length === this.size;\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nFixedType.prototype._read = function (tap) {\n  return tap.readFixed(this.size);\n};\n\nFixedType.prototype._skip = function (tap) {\n  tap.skipFixed(this.size);\n};\n\nFixedType.prototype._write = function (tap, val) {\n  if (!Buffer.isBuffer(val) || val.length !== this.size) {\n    throwInvalidError(val, this);\n  }\n  tap.writeFixed(val, this.size);\n};\n\nFixedType.prototype._match = function (tap1, tap2) {\n  return tap1.matchFixed(tap2, this.size);\n};\n\nFixedType.prototype.compare = Buffer.compare;\n\nFixedType.prototype._update = function (resolver, type, opts) {\n  if (\n    type.typeName === 'fixed' &&\n    this.size === type.size &&\n    hasCompatibleName(this, type, !opts.ignoreNamespaces)\n  ) {\n    resolver.size = this.size;\n    resolver._read = this._read;\n  }\n};\n\nFixedType.prototype._copy = BytesType.prototype._copy;\n\nFixedType.prototype._deref = function (schema) { schema.size = this.size; };\n\nFixedType.prototype.getSize = function () { return this.size; };\n\nFixedType.prototype.typeName = 'fixed';\n\nFixedType.prototype.random = function () {\n  return RANDOM.nextBuffer(this.size);\n};\n\n/** Avro map. Represented as vanilla objects. */\nfunction MapType(schema, opts) {\n  Type.call(this);\n  if (!schema.values) {\n    throw new Error(f('missing map values: %j', schema));\n  }\n  this.valuesType = Type.forSchema(schema.values, opts);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(MapType, Type);\n\nMapType.prototype._check = function (val, flags, hook, path) {\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\n    if (hook) {\n      hook(val, this);\n    }\n    return false;\n  }\n\n  var keys = Object.keys(val);\n  var b = true;\n  var i, l, j, key;\n  if (hook) {\n    // Slow path.\n    j = path.length;\n    path.push('');\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = path[j] = keys[i];\n      if (!this.valuesType._check(val[key], flags, hook, path)) {\n        b = false;\n      }\n    }\n    path.pop();\n  } else {\n    for (i = 0, l = keys.length; i < l; i++) {\n      if (!this.valuesType._check(val[keys[i]], flags)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\n\nMapType.prototype._read = function (tap) {\n  var values = this.valuesType;\n  var val = {};\n  var n;\n  while ((n = readArraySize(tap))) {\n    while (n--) {\n      var key = tap.readString();\n      val[key] = values._read(tap);\n    }\n  }\n  return val;\n};\n\nMapType.prototype._skip = function (tap) {\n  var values = this.valuesType;\n  var len, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        tap.skipString();\n        values._skip(tap);\n      }\n    }\n  }\n};\n\nMapType.prototype._write = function (tap, val) {\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n\n  var values = this.valuesType;\n  var keys = Object.keys(val);\n  var n = keys.length;\n  var i, key;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      key = keys[i];\n      tap.writeString(key);\n      values._write(tap, val[key]);\n    }\n  }\n  tap.writeLong(0);\n};\n\nMapType.prototype._match = function () {\n  throw new Error('maps cannot be compared');\n};\n\nMapType.prototype._update = function (rsv, type, opts) {\n  if (type.typeName === 'map') {\n    rsv.valuesType = this.valuesType.createResolver(type.valuesType, opts);\n    rsv._read = this._read;\n  }\n};\n\nMapType.prototype._copy = function (val, opts) {\n  if (val && typeof val == 'object' && !Array.isArray(val)) {\n    var values = this.valuesType;\n    var keys = Object.keys(val);\n    var i, l, key;\n    var copy = {};\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      copy[key] = values._copy(val[key], opts);\n    }\n    return copy;\n  }\n  throwInvalidError(val, this);\n};\n\nMapType.prototype.compare = MapType.prototype._match;\n\nMapType.prototype.typeName = 'map';\n\nMapType.prototype.getValuesType = function () { return this.valuesType; };\n\nMapType.prototype.random = function () {\n  var val = {};\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    val[RANDOM.nextString(RANDOM.nextInt(20))] = this.valuesType.random();\n  }\n  return val;\n};\n\nMapType.prototype._deref = function (schema, opts) {\n  schema.values = this.valuesType._attrs(opts);\n};\n\n/** Avro array. Represented as vanilla arrays. */\nfunction ArrayType(schema, opts) {\n  Type.call(this);\n  if (!schema.items) {\n    throw new Error(f('missing array items: %j', schema));\n  }\n  this.itemsType = Type.forSchema(schema.items, opts);\n  this._branchConstructor = this._createBranchConstructor();\n  Object.freeze(this);\n}\nutil.inherits(ArrayType, Type);\n\nArrayType.prototype._check = function (val, flags, hook, path) {\n  if (!Array.isArray(val)) {\n    if (hook) {\n      hook(val, this);\n    }\n    return false;\n  }\n  var items = this.itemsType;\n  var b = true;\n  var i, l, j;\n  if (hook) {\n    // Slow path.\n    j = path.length;\n    path.push('');\n    for (i = 0, l = val.length; i < l; i++) {\n      path[j] = '' + i;\n      if (!items._check(val[i], flags, hook, path)) {\n        b = false;\n      }\n    }\n    path.pop();\n  } else {\n    for (i = 0, l = val.length; i < l; i++) {\n      if (!items._check(val[i], flags)) {\n        return false;\n      }\n    }\n  }\n  return b;\n};\n\nArrayType.prototype._read = function (tap) {\n  var items = this.itemsType;\n  var i = 0;\n  var val, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      n = -n;\n      tap.skipLong(); // Skip size.\n    }\n    // Initializing the array on the first batch gives a ~10% speedup. See\n    // https://github.com/mtth/avsc/pull/338 for more context.\n    val = val || new Array(n)\n    while (n--) {\n      val[i++] = items._read(tap);\n    }\n  }\n  return val || [];\n};\n\nArrayType.prototype._skip = function (tap) {\n  var items = this.itemsType;\n  var len, n;\n  while ((n = tap.readLong())) {\n    if (n < 0) {\n      len = tap.readLong();\n      tap.pos += len;\n    } else {\n      while (n--) {\n        items._skip(tap);\n      }\n    }\n  }\n};\n\nArrayType.prototype._write = function (tap, val) {\n  if (!Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n  var items = this.itemsType;\n  var n = val.length;\n  var i;\n  if (n) {\n    tap.writeLong(n);\n    for (i = 0; i < n; i++) {\n      items._write(tap, val[i]);\n    }\n  }\n  tap.writeLong(0);\n};\n\nArrayType.prototype._match = function (tap1, tap2) {\n  var n1 = tap1.readLong();\n  var n2 = tap2.readLong();\n  var f;\n  while (n1 && n2) {\n    f = this.itemsType._match(tap1, tap2);\n    if (f) {\n      return f;\n    }\n    if (!--n1) {\n      n1 = readArraySize(tap1);\n    }\n    if (!--n2) {\n      n2 = readArraySize(tap2);\n    }\n  }\n  return utils.compare(n1, n2);\n};\n\nArrayType.prototype._update = function (resolver, type, opts) {\n  if (type.typeName === 'array') {\n    resolver.itemsType = this.itemsType.createResolver(type.itemsType, opts);\n    resolver._read = this._read;\n  }\n};\n\nArrayType.prototype._copy = function (val, opts) {\n  if (!Array.isArray(val)) {\n    throwInvalidError(val, this);\n  }\n  var items = new Array(val.length);\n  var i, l;\n  for (i = 0, l = val.length; i < l; i++) {\n    items[i] = this.itemsType._copy(val[i], opts);\n  }\n  return items;\n};\n\nArrayType.prototype._deref = function (schema, opts) {\n  schema.items = this.itemsType._attrs(opts);\n};\n\nArrayType.prototype.compare = function (val1, val2) {\n  var n1 = val1.length;\n  var n2 = val2.length;\n  var i, l, f;\n  for (i = 0, l = Math.min(n1, n2); i < l; i++) {\n    if ((f = this.itemsType.compare(val1[i], val2[i]))) {\n      return f;\n    }\n  }\n  return utils.compare(n1, n2);\n};\n\nArrayType.prototype.getItemsType = function () { return this.itemsType; };\n\nArrayType.prototype.typeName = 'array';\n\nArrayType.prototype.random = function () {\n  var arr = [];\n  var i, l;\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\n    arr.push(this.itemsType.random());\n  }\n  return arr;\n};\n\n/**\n * Avro record.\n *\n * Values are represented as instances of a programmatically generated\n * constructor (similar to a \"specific record\"), available via the\n * `getRecordConstructor` method. This \"specific record class\" gives\n * significant speedups over using generics objects.\n *\n * Note that vanilla objects are still accepted as valid as long as their\n * fields match (this makes it much more convenient to do simple things like\n * update nested records).\n *\n * This type is also used for errors (similar, except for the extra `Error`\n * constructor call) and for messages (see comment below).\n */\nfunction RecordType(schema, opts) {\n  // Force creation of the options object in case we need to register this\n  // record's name.\n  opts = opts || {};\n\n  // Save the namespace to restore it as we leave this record's scope.\n  var namespace = opts.namespace;\n  if (schema.namespace !== undefined) {\n    opts.namespace = schema.namespace;\n  } else if (schema.name) {\n    // Fully qualified names' namespaces are used when no explicit namespace\n    // attribute was specified.\n    var ns = utils.impliedNamespace(schema.name);\n    if (ns !== undefined) {\n      opts.namespace = ns;\n    }\n  }\n  Type.call(this, schema, opts);\n\n  if (!Array.isArray(schema.fields)) {\n    throw new Error(f('non-array record fields: %j', schema.fields));\n  }\n  if (utils.hasDuplicates(schema.fields, function (f) { return f.name; })) {\n    throw new Error(f('duplicate field name: %j', schema.fields));\n  }\n  this._fieldsByName = {};\n  this.fields = Object.freeze(schema.fields.map(function (f) {\n    var field = new Field(f, opts);\n    this._fieldsByName[field.name] = field;\n    return field;\n  }, this));\n  this._branchConstructor = this._createBranchConstructor();\n  this._isError = schema.type === 'error';\n  this.recordConstructor = this._createConstructor(\n    opts.errorStackTraces,\n    opts.omitRecordMethods\n  );\n  this._read = this._createReader();\n  this._skip = this._createSkipper();\n  this._write = this._createWriter();\n  this._check = this._createChecker();\n\n  opts.namespace = namespace;\n  Object.freeze(this);\n}\nutil.inherits(RecordType, Type);\n\nRecordType.prototype._getConstructorName = function () {\n  return this.name ?\n    utils.capitalize(utils.unqualify(this.name)) :\n    this._isError ? 'Error$' : 'Record$';\n};\n\nRecordType.prototype._createConstructor = function (errorStack, plainRecords) {\n  // jshint -W054\n  var outerArgs = [];\n  var innerArgs = [];\n  var ds = []; // Defaults.\n  var innerBody = '';\n  var i, l, field, name, defaultValue, hasDefault, stackField;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    defaultValue = field.defaultValue;\n    hasDefault = defaultValue() !== undefined;\n    name = field.name;\n    if (\n      errorStack && this._isError && name === 'stack' &&\n      Type.isType(field.type, 'string') && !hasDefault\n    ) {\n      // We keep track of whether we've encountered a valid stack field (in\n      // particular, without a default) to populate a stack trace below.\n      stackField = field;\n    }\n    innerArgs.push('v' + i);\n    innerBody += '  ';\n    if (!hasDefault) {\n      innerBody += 'this.' + name + ' = v' + i + ';\\n';\n    } else {\n      innerBody += 'if (v' + i + ' === undefined) { ';\n      innerBody += 'this.' + name + ' = d' + ds.length + '(); ';\n      innerBody += '} else { this.' + name + ' = v' + i + '; }\\n';\n      outerArgs.push('d' + ds.length);\n      ds.push(defaultValue);\n    }\n  }\n  if (stackField) {\n    // We should populate a stack trace.\n    innerBody += '  if (this.stack === undefined) { ';\n    /* istanbul ignore else */\n    if (typeof Error.captureStackTrace == 'function') {\n      // v8 runtimes, the easy case.\n      innerBody += 'Error.captureStackTrace(this, this.constructor);';\n    } else {\n      // A few other runtimes (e.g. SpiderMonkey), might not work everywhere.\n      innerBody += 'this.stack = Error().stack;';\n    }\n    innerBody += ' }\\n';\n  }\n  var outerBody = 'return function ' + this._getConstructorName() + '(';\n  outerBody += innerArgs.join() + ') {\\n' + innerBody + '};';\n  var Record = new Function(outerArgs.join(), outerBody).apply(undefined, ds);\n  if (plainRecords) {\n    return Record;\n  }\n\n  var self = this;\n  Record.getType = function () { return self; };\n  Record.type = self;\n  if (this._isError) {\n    util.inherits(Record, Error);\n    Record.prototype.name = this._getConstructorName();\n  }\n  Record.prototype.clone = function (o) { return self.clone(this, o); };\n  Record.prototype.compare = function (v) { return self.compare(this, v); };\n  Record.prototype.isValid = function (o) { return self.isValid(this, o); };\n  Record.prototype.toBuffer = function () { return self.toBuffer(this); };\n  Record.prototype.toString = function () { return self.toString(this); };\n  Record.prototype.wrap = function () { return self.wrap(this); };\n  Record.prototype.wrapped = Record.prototype.wrap; // Deprecated.\n  return Record;\n};\n\nRecordType.prototype._createChecker = function () {\n  // jshint -W054\n  var names = [];\n  var values = [];\n  var name = this._getConstructorName();\n  var body = 'return function check' + name + '(v, f, h, p) {\\n';\n  body += '  if (\\n';\n  body += '    v === null ||\\n';\n  body += '    typeof v != \\'object\\' ||\\n';\n  body += '    (f && !this._checkFields(v))\\n';\n  body += '  ) {\\n';\n  body += '    if (h) { h(v, this); }\\n';\n  body += '    return false;\\n';\n  body += '  }\\n';\n  if (!this.fields.length) {\n    // Special case, empty record. We handle this directly.\n    body += '  return true;\\n';\n  } else {\n    for (i = 0, l = this.fields.length; i < l; i++) {\n      field = this.fields[i];\n      names.push('t' + i);\n      values.push(field.type);\n      if (field.defaultValue() !== undefined) {\n        body += '  var v' + i + ' = v.' + field.name + ';\\n';\n      }\n    }\n    body += '  if (h) {\\n';\n    body += '    var b = 1;\\n';\n    body += '    var j = p.length;\\n';\n    body += '    p.push(\\'\\');\\n';\n    var i, l, field;\n    for (i = 0, l = this.fields.length; i < l; i++) {\n      field = this.fields[i];\n      body += '    p[j] = \\'' + field.name + '\\';\\n';\n      body += '    b &= ';\n      if (field.defaultValue() === undefined) {\n        body += 't' + i + '._check(v.' + field.name + ', f, h, p);\\n';\n      } else {\n        body += 'v' + i + ' === undefined || ';\n        body += 't' + i + '._check(v' + i + ', f, h, p);\\n';\n      }\n    }\n    body += '    p.pop();\\n';\n    body += '    return !!b;\\n';\n    body += '  } else {\\n    return (\\n      ';\n    body += this.fields.map(function (field, i) {\n      return field.defaultValue() === undefined ?\n        't' + i + '._check(v.' + field.name + ', f)' :\n        '(v' + i + ' === undefined || t' + i + '._check(v' + i + ', f))';\n    }).join(' &&\\n      ');\n    body += '\\n    );\\n  }\\n';\n  }\n  body += '};';\n  return new Function(names.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._createReader = function () {\n  // jshint -W054\n  var names = [];\n  var values = [this.recordConstructor];\n  var i, l;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    names.push('t' + i);\n    values.push(this.fields[i].type);\n  }\n  var name = this._getConstructorName();\n  var body = 'return function read' + name + '(t) {\\n';\n  body += '  return new ' + name + '(\\n    ';\n  body += names.map(function (s) { return s + '._read(t)'; }).join(',\\n    ');\n  body += '\\n  );\\n};';\n  names.unshift(name);\n  // We can do this since the JS spec guarantees that function arguments are\n  // evaluated from left to right.\n  return new Function(names.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._createSkipper = function () {\n  // jshint -W054\n  var args = [];\n  var body = 'return function skip' + this._getConstructorName() + '(t) {\\n';\n  var values = [];\n  var i, l;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    args.push('t' + i);\n    values.push(this.fields[i].type);\n    body += '  t' + i + '._skip(t);\\n';\n  }\n  body += '}';\n  return new Function(args.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._createWriter = function () {\n  // jshint -W054\n  // We still do default handling here, in case a normal JS object is passed.\n  var args = [];\n  var name = this._getConstructorName();\n  var body = 'return function write' + name + '(t, v) {\\n';\n  var values = [];\n  var i, l, field, value;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    args.push('t' + i);\n    values.push(field.type);\n    body += '  ';\n    if (field.defaultValue() === undefined) {\n      body += 't' + i + '._write(t, v.' + field.name + ');\\n';\n    } else {\n      value = field.type.toBuffer(field.defaultValue()).toString('binary');\n      // Convert the default value to a binary string ahead of time. We aren't\n      // converting it to a buffer to avoid retaining too much memory. If we\n      // had our own buffer pool, this could be an idea in the future.\n      args.push('d' + i);\n      values.push(value);\n      body += 'var v' + i + ' = v.' + field.name + ';\\n';\n      body += 'if (v' + i + ' === undefined) {\\n';\n      body += '    t.writeBinary(d' + i + ', ' + value.length + ');\\n';\n      body += '  } else {\\n    t' + i + '._write(t, v' + i + ');\\n  }\\n';\n    }\n  }\n  body += '}';\n  return new Function(args.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._update = function (resolver, type, opts) {\n  // jshint -W054\n  if (!hasCompatibleName(this, type, !opts.ignoreNamespaces)) {\n    throw new Error(f('no alias found for %s', type.name));\n  }\n\n  var rFields = this.fields;\n  var wFields = type.fields;\n  var wFieldsMap = utils.toMap(wFields, function (f) { return f.name; });\n\n  var innerArgs = []; // Arguments for reader constructor.\n  var resolvers = {}; // Resolvers keyed by writer field name.\n  var i, j, field, name, names, matches, fieldResolver;\n  for (i = 0; i < rFields.length; i++) {\n    field = rFields[i];\n    names = getAliases(field);\n    matches = [];\n    for (j = 0; j < names.length; j++) {\n      name = names[j];\n      if (wFieldsMap[name]) {\n        matches.push(name);\n      }\n    }\n    if (matches.length > 1) {\n      throw new Error(\n        f('ambiguous aliasing for %s.%s (%s)', type.name, field.name, matches)\n      );\n    }\n    if (!matches.length) {\n      if (field.defaultValue() === undefined) {\n        throw new Error(\n          f('no matching field for default-less %s.%s', type.name, field.name)\n        );\n      }\n      innerArgs.push('undefined');\n    } else {\n      name = matches[0];\n      fieldResolver = {\n        resolver: field.type.createResolver(wFieldsMap[name].type, opts),\n        name: '_' + field.name, // Reader field name.\n      };\n      if (!resolvers[name]) {\n        resolvers[name] = [fieldResolver];\n      } else {\n        resolvers[name].push(fieldResolver);\n      }\n      innerArgs.push(fieldResolver.name);\n    }\n  }\n\n  // See if we can add a bypass for unused fields at the end of the record.\n  var lazyIndex = -1;\n  i = wFields.length;\n  while (i && resolvers[wFields[--i].name] === undefined) {\n    lazyIndex = i;\n  }\n\n  var uname = this._getConstructorName();\n  var args = [uname];\n  var values = [this.recordConstructor];\n  var body = '  return function read' + uname + '(t, b) {\\n';\n  for (i = 0; i < wFields.length; i++) {\n    if (i === lazyIndex) {\n      body += '  if (!b) {\\n';\n    }\n    field = type.fields[i];\n    name = field.name;\n    if (resolvers[name] === undefined) {\n      body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';\n      args.push('r' + i);\n      values.push(field.type);\n      body += 'r' + i + '._skip(t);\\n';\n    } else {\n      j = resolvers[name].length;\n      while (j--) {\n        body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';\n        args.push('r' + i + 'f' + j);\n        fieldResolver = resolvers[name][j];\n        values.push(fieldResolver.resolver);\n        body += 'var ' + fieldResolver.name + ' = ';\n        body += 'r' + i + 'f' + j + '._' + (j ? 'peek' : 'read') + '(t);\\n';\n      }\n    }\n  }\n  if (~lazyIndex) {\n    body += '  }\\n';\n  }\n  body += '  return new ' + uname + '(' + innerArgs.join() + ');\\n};';\n\n  resolver._read = new Function(args.join(), body).apply(undefined, values);\n};\n\nRecordType.prototype._match = function (tap1, tap2) {\n  var fields = this.fields;\n  var i, l, field, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    order = field._order;\n    type = field.type;\n    if (order) {\n      order *= type._match(tap1, tap2);\n      if (order) {\n        return order;\n      }\n    } else {\n      type._skip(tap1);\n      type._skip(tap2);\n    }\n  }\n  return 0;\n};\n\nRecordType.prototype._checkFields = function (obj) {\n  var keys = Object.keys(obj);\n  var i, l;\n  for (i = 0, l = keys.length; i < l; i++) {\n    if (!this._fieldsByName[keys[i]]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nRecordType.prototype._copy = function (val, opts) {\n  // jshint -W058\n  var hook = opts && opts.fieldHook;\n  var values = [undefined];\n  var i, l, field, value;\n  for (i = 0, l = this.fields.length; i < l; i++) {\n    field = this.fields[i];\n    value = val[field.name];\n    if (value === undefined && field.hasOwnProperty('defaultValue')) {\n      value = field.defaultValue();\n    }\n    if ((opts && !opts.skip) || value !== undefined) {\n      value = field.type._copy(value, opts);\n    }\n    if (hook) {\n      value = hook(field, value, this);\n    }\n    values.push(value);\n  }\n  var Record = this.recordConstructor;\n  return new (Record.bind.apply(Record, values))();\n};\n\nRecordType.prototype._deref = function (schema, opts) {\n  schema.fields = this.fields.map(function (field) {\n    var fieldType = field.type;\n    var fieldSchema = {\n      name: field.name,\n      type: fieldType._attrs(opts)\n    };\n    if (opts.exportAttrs) {\n      var val = field.defaultValue();\n      if (val !== undefined) {\n        // We must both unwrap all unions and coerce buffers to strings.\n        fieldSchema['default'] = fieldType._copy(val, {coerce: 3, wrap: 3});\n      }\n      var fieldOrder = field.order;\n      if (fieldOrder !== 'ascending') {\n        fieldSchema.order = fieldOrder;\n      }\n      var fieldAliases = field.aliases;\n      if (fieldAliases.length) {\n        fieldSchema.aliases = fieldAliases;\n      }\n      var fieldDoc = field.doc;\n      if (fieldDoc !== undefined) {\n        fieldSchema.doc = fieldDoc;\n      }\n    }\n    return fieldSchema;\n  });\n};\n\nRecordType.prototype.compare = function (val1, val2) {\n  var fields = this.fields;\n  var i, l, field, name, order, type;\n  for (i = 0, l = fields.length; i < l; i++) {\n    field = fields[i];\n    name = field.name;\n    order = field._order;\n    type = field.type;\n    if (order) {\n      order *= type.compare(val1[name], val2[name]);\n      if (order) {\n        return order;\n      }\n    }\n  }\n  return 0;\n};\n\nRecordType.prototype.random = function () {\n  // jshint -W058\n  var fields = this.fields.map(function (f) { return f.type.random(); });\n  fields.unshift(undefined);\n  var Record = this.recordConstructor;\n  return new (Record.bind.apply(Record, fields))();\n};\n\nRecordType.prototype.field = function (name) {\n  return this._fieldsByName[name];\n};\n\nRecordType.prototype.getField = RecordType.prototype.field;\n\nRecordType.prototype.getFields = function () { return this.fields; };\n\nRecordType.prototype.getRecordConstructor = function () {\n  return this.recordConstructor;\n};\n\nObject.defineProperty(RecordType.prototype, 'typeName', {\n  enumerable: true,\n  get: function () { return this._isError ? 'error' : 'record'; }\n});\n\n/** Derived type abstract class. */\nfunction LogicalType(schema, opts) {\n  this._logicalTypeName = schema.logicalType;\n  Type.call(this);\n  LOGICAL_TYPE = this;\n  try {\n    this._underlyingType = Type.forSchema(schema, opts);\n  } finally {\n    LOGICAL_TYPE = null;\n    // Remove the underlying type now that we're done instantiating. Note that\n    // in some (rare) cases, it might not have been inserted; for example, if\n    // this constructor was manually called with an already instantiated type.\n    var l = UNDERLYING_TYPES.length;\n    if (l && UNDERLYING_TYPES[l - 1][0] === this) {\n      UNDERLYING_TYPES.pop();\n    }\n  }\n  // We create a separate branch constructor for logical types to keep them\n  // monomorphic.\n  if (Type.isType(this.underlyingType, 'union')) {\n    this._branchConstructor = this.underlyingType._branchConstructor;\n  } else {\n    this._branchConstructor = this.underlyingType._createBranchConstructor();\n  }\n  // We don't freeze derived types to allow arbitrary properties. Implementors\n  // can still do so in the subclass' constructor at their convenience.\n}\nutil.inherits(LogicalType, Type);\n\nObject.defineProperty(LogicalType.prototype, 'typeName', {\n  enumerable: true,\n  get: function () { return 'logical:' + this._logicalTypeName; }\n});\n\nObject.defineProperty(LogicalType.prototype, 'underlyingType', {\n  enumerable: true,\n  get: function () {\n    if (this._underlyingType) {\n      return this._underlyingType;\n    }\n    // If the field wasn't present, it means the logical type isn't complete\n    // yet: we're waiting on its underlying type to be fully instantiated. In\n    // this case, it will be present in the `UNDERLYING_TYPES` array.\n    var i, l, arr;\n    for (i = 0, l = UNDERLYING_TYPES.length; i < l; i++) {\n      arr = UNDERLYING_TYPES[i];\n      if (arr[0] === this) {\n        return arr[1];\n      }\n    }\n  }\n});\n\nLogicalType.prototype.getUnderlyingType = function () {\n  return this.underlyingType;\n};\n\nLogicalType.prototype._read = function (tap) {\n  return this._fromValue(this.underlyingType._read(tap));\n};\n\nLogicalType.prototype._write = function (tap, any) {\n  this.underlyingType._write(tap, this._toValue(any));\n};\n\nLogicalType.prototype._check = function (any, flags, hook, path) {\n  try {\n    var val = this._toValue(any);\n  } catch (err) {\n    // Handled below.\n  }\n  if (val === undefined) {\n    if (hook) {\n      hook(any, this);\n    }\n    return false;\n  }\n  return this.underlyingType._check(val, flags, hook, path);\n};\n\nLogicalType.prototype._copy = function (any, opts) {\n  var type = this.underlyingType;\n  switch (opts && opts.coerce) {\n    case 3: // To string.\n      return type._copy(this._toValue(any), opts);\n    case 2: // From string.\n      return this._fromValue(type._copy(any, opts));\n    default: // Normal copy.\n      return this._fromValue(type._copy(this._toValue(any), opts));\n  }\n};\n\nLogicalType.prototype._update = function (resolver, type, opts) {\n  var _fromValue = this._resolve(type, opts);\n  if (_fromValue) {\n    resolver._read = function (tap) { return _fromValue(type._read(tap)); };\n  }\n};\n\nLogicalType.prototype.compare = function (obj1, obj2) {\n  var val1 = this._toValue(obj1);\n  var val2 = this._toValue(obj2);\n  return this.underlyingType.compare(val1, val2);\n};\n\nLogicalType.prototype.random = function () {\n  return this._fromValue(this.underlyingType.random());\n};\n\nLogicalType.prototype._deref = function (schema, opts) {\n  var type = this.underlyingType;\n  var isVisited = type.name !== undefined && opts.derefed[type.name];\n  schema = type._attrs(opts);\n  if (!isVisited && opts.exportAttrs) {\n    if (typeof schema == 'string') {\n      schema = {type: schema};\n    }\n    schema.logicalType = this._logicalTypeName;\n    this._export(schema);\n  }\n  return schema;\n};\n\nLogicalType.prototype._skip = function (tap) {\n  this.underlyingType._skip(tap);\n};\n\n// Unlike the other methods below, `_export` has a reasonable default which we\n// can provide (not exporting anything).\nLogicalType.prototype._export = function (/* schema */) {};\n\n// Methods to be implemented.\nLogicalType.prototype._fromValue = utils.abstractFunction;\nLogicalType.prototype._toValue = utils.abstractFunction;\nLogicalType.prototype._resolve = utils.abstractFunction;\n\n\n// General helpers.\n\n/**\n * Customizable long.\n *\n * This allows support of arbitrarily large long (e.g. larger than\n * `Number.MAX_SAFE_INTEGER`). See `LongType.__with` method above. Note that we\n * can't use a logical type because we need a \"lower-level\" hook here: passing\n * through through the standard long would cause a loss of precision.\n */\nfunction AbstractLongType(noUnpack) {\n  this._concreteTypeName = 'long';\n  PrimitiveType.call(this, true);\n  // Note that this type \"inherits\" `LongType` (i.e. gain its prototype\n  // methods) but only \"subclasses\" `PrimitiveType` to avoid being prematurely\n  // frozen.\n  this._noUnpack = !!noUnpack;\n}\nutil.inherits(AbstractLongType, LongType);\n\nAbstractLongType.prototype.typeName = 'abstract:long';\n\nAbstractLongType.prototype._check = function (val, flags, hook) {\n  var b = this._isValid(val);\n  if (!b && hook) {\n    hook(val, this);\n  }\n  return b;\n};\n\nAbstractLongType.prototype._read = function (tap) {\n  var buf, pos;\n  if (this._noUnpack) {\n    pos = tap.pos;\n    tap.skipLong();\n    buf = tap.buf.slice(pos, tap.pos);\n  } else {\n    buf = tap.unpackLongBytes(tap);\n  }\n  if (tap.isValid()) {\n    return this._fromBuffer(buf);\n  }\n};\n\nAbstractLongType.prototype._write = function (tap, val) {\n  if (!this._isValid(val)) {\n    throwInvalidError(val, this);\n  }\n  var buf = this._toBuffer(val);\n  if (this._noUnpack) {\n    tap.writeFixed(buf);\n  } else {\n    tap.packLongBytes(buf);\n  }\n};\n\nAbstractLongType.prototype._copy = function (val, opts) {\n  switch (opts && opts.coerce) {\n    case 3: // To string.\n      return this._toJSON(val);\n    case 2: // From string.\n      return this._fromJSON(val);\n    default: // Normal copy.\n      // Slow but guarantees most consistent results. Faster alternatives would\n      // require assumptions on the long class used (e.g. immutability).\n      return this._fromJSON(this._toJSON(val));\n  }\n};\n\nAbstractLongType.prototype._deref = function () { return 'long'; };\n\nAbstractLongType.prototype._update = function (resolver, type) {\n  var self = this;\n  switch (type.typeName) {\n    case 'int':\n      resolver._read = function (tap) {\n        return self._fromJSON(type._read(tap));\n      };\n      break;\n    case 'abstract:long':\n    case 'long':\n      resolver._read = function (tap) { return self._read(tap); };\n  }\n};\n\nAbstractLongType.prototype.random = function () {\n  return this._fromJSON(LongType.prototype.random());\n};\n\n// Methods to be implemented by the user.\nAbstractLongType.prototype._fromBuffer = utils.abstractFunction;\nAbstractLongType.prototype._toBuffer = utils.abstractFunction;\nAbstractLongType.prototype._fromJSON = utils.abstractFunction;\nAbstractLongType.prototype._toJSON = utils.abstractFunction;\nAbstractLongType.prototype._isValid = utils.abstractFunction;\nAbstractLongType.prototype.compare = utils.abstractFunction;\n\n/** A record field. */\nfunction Field(schema, opts) {\n  var name = schema.name;\n  if (typeof name != 'string' || !utils.isValidName(name)) {\n    throw new Error(f('invalid field name: %s', name));\n  }\n\n  this.name = name;\n  this.type = Type.forSchema(schema.type, opts);\n  this.aliases = schema.aliases || [];\n  this.doc = schema.doc !== undefined ? '' + schema.doc : undefined;\n\n  this._order = (function (order) {\n    switch (order) {\n      case 'ascending':\n        return 1;\n      case 'descending':\n        return -1;\n      case 'ignore':\n        return 0;\n      default:\n        throw new Error(f('invalid order: %j', order));\n    }\n  })(schema.order === undefined ? 'ascending' : schema.order);\n\n  var value = schema['default'];\n  if (value !== undefined) {\n    // We need to convert defaults back to a valid format (unions are\n    // disallowed in default definitions, only the first type of each union is\n    // allowed instead).\n    // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html\n    var type = this.type;\n    var val = type._copy(value, {coerce: 2, wrap: 2});\n    // The clone call above will throw an error if the default is invalid.\n    if (isPrimitive(type.typeName) && type.typeName !== 'bytes') {\n      // These are immutable.\n      this.defaultValue = function () { return val; };\n    } else {\n      this.defaultValue = function () { return type._copy(val); };\n    }\n  }\n\n  Object.freeze(this);\n}\n\nField.prototype.defaultValue = function () {}; // Undefined default.\n\nObject.defineProperty(Field.prototype, 'order', {\n  enumerable: true,\n  get: function () {\n    return ['descending', 'ignore', 'ascending'][this._order + 1];\n  }\n});\n\nField.prototype.getAliases = function () { return this.aliases; };\n\nField.prototype.getDefault = Field.prototype.defaultValue;\n\nField.prototype.getName = function () { return this.name; };\n\nField.prototype.getOrder = function () { return this.order; };\n\nField.prototype.getType = function () { return this.type; };\n\n/**\n * Resolver to read a writer's schema as a new schema.\n *\n * @param readerType {Type} The type to convert to.\n */\nfunction Resolver(readerType) {\n  // Add all fields here so that all resolvers share the same hidden class.\n  this._readerType = readerType;\n  this._read = null;\n  this.itemsType = null;\n  this.size = 0;\n  this.symbols = null;\n  this.valuesType = null;\n}\n\nResolver.prototype._peek = Type.prototype._peek;\n\nResolver.prototype.inspect = function () { return '<Resolver>'; };\n\n/** Mutable hash container. */\nfunction Hash() {\n  this.str = undefined;\n}\n\n/**\n * Read a value from a tap.\n *\n * @param type {Type} The type to decode.\n * @param tap {Tap} The tap to read from. No checks are performed here.\n * @param resolver {Resolver} Optional resolver. It must match the input type.\n * @param lazy {Boolean} Skip trailing fields when using a resolver.\n */\nfunction readValue(type, tap, resolver, lazy) {\n  if (resolver) {\n    if (resolver._readerType !== type) {\n      throw new Error('invalid resolver');\n    }\n    return resolver._read(tap, lazy);\n  } else {\n    return type._read(tap);\n  }\n}\n\n/**\n * Get all aliases for a type (including its name).\n *\n * @param obj {Type|Object} Typically a type or a field. Its aliases property\n * must exist and be an array.\n */\nfunction getAliases(obj) {\n  var names = {};\n  if (obj.name) {\n    names[obj.name] = true;\n  }\n  var aliases = obj.aliases;\n  var i, l;\n  for (i = 0, l = aliases.length; i < l; i++) {\n    names[aliases[i]] = true;\n  }\n  return Object.keys(names);\n}\n\n/** Checks if a type can be read as another based on name resolution rules. */\nfunction hasCompatibleName(reader, writer, strict) {\n  if (!writer.name) {\n    return true;\n  }\n  var name = strict ? writer.name : utils.unqualify(writer.name);\n  var aliases = getAliases(reader);\n  var i, l, alias;\n  for (i = 0, l = aliases.length; i < l; i++) {\n    alias = aliases[i];\n    if (!strict) {\n      alias = utils.unqualify(alias);\n    }\n    if (alias === name) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Check whether a type's name is a primitive.\n *\n * @param name {String} Type name (e.g. `'string'`, `'array'`).\n */\nfunction isPrimitive(typeName) {\n  // Since we use this module's own `TYPES` object, we can use `instanceof`.\n  var type = TYPES[typeName];\n  return type && type.prototype instanceof PrimitiveType;\n}\n\n/**\n * Return a type's class name from its Avro type name.\n *\n * We can't simply use `constructor.name` since it isn't supported in all\n * browsers.\n *\n * @param typeName {String} Type name.\n */\nfunction getClassName(typeName) {\n  if (typeName === 'error') {\n    typeName = 'record';\n  } else {\n    var match = /^([^:]+):(.*)$/.exec(typeName);\n    if (match) {\n      if (match[1] === 'union') {\n        typeName = match[2] + 'Union';\n      } else {\n        // Logical type.\n        typeName = match[1];\n      }\n    }\n  }\n  return utils.capitalize(typeName) + 'Type';\n}\n\n/**\n * Get the number of elements in an array block.\n *\n * @param tap {Tap} A tap positioned at the beginning of an array block.\n */\nfunction readArraySize(tap) {\n  var n = tap.readLong();\n  if (n < 0) {\n    n = -n;\n    tap.skipLong(); // Skip size.\n  }\n  return n;\n}\n\n/**\n * Check whether a long can be represented without precision loss.\n *\n * @param n {Number} The number.\n *\n * Two things to note:\n *\n * + We are not using the `Number` constants for compatibility with older\n *   browsers.\n * + We must remove one from each bound because of rounding errors.\n */\nfunction isSafeLong(n) {\n  return n >= -9007199254740990 && n <= 9007199254740990;\n}\n\n/**\n * Check whether an object is the JSON representation of a buffer.\n */\nfunction isJsonBuffer(obj) {\n  return obj && obj.type === 'Buffer' && Array.isArray(obj.data);\n}\n\n/**\n * Throw a somewhat helpful error on invalid object.\n *\n * @param path {Array} Passed from hook, but unused (because empty where this\n * function is used, since we aren't keeping track of it for effiency).\n * @param val {...} The object to reject.\n * @param type {Type} The type to check against.\n *\n * This method is mostly used from `_write` to signal an invalid object for a\n * given type. Note that this provides less information than calling `isValid`\n * with a hook since the path is not propagated (for efficiency reasons).\n */\nfunction throwInvalidError(val, type) {\n  throw new Error(f('invalid %j: %j', type.schema(), val));\n}\n\nfunction maybeQualify(name, ns) {\n  var unqualified = utils.unqualify(name);\n  // Primitives are always in the global namespace.\n  return isPrimitive(unqualified) ? unqualified : utils.qualify(name, ns);\n}\n\n/**\n * Get a type's bucket when included inside an unwrapped union.\n *\n * @param type {Type} Any type.\n */\nfunction getTypeBucket(type) {\n  var typeName = type.typeName;\n  switch (typeName) {\n    case 'double':\n    case 'float':\n    case 'int':\n    case 'long':\n      return 'number';\n    case 'bytes':\n    case 'fixed':\n      return 'buffer';\n    case 'enum':\n      return 'string';\n    case 'map':\n    case 'error':\n    case 'record':\n      return 'object';\n    default:\n      return typeName;\n  }\n}\n\n/**\n * Infer a value's bucket (see unwrapped unions for more details).\n *\n * @param val {...} Any value.\n */\nfunction getValueBucket(val) {\n  if (val === null) {\n    return 'null';\n  }\n  var bucket = typeof val;\n  if (bucket === 'object') {\n    // Could be bytes, fixed, array, map, or record.\n    if (Array.isArray(val)) {\n      return 'array';\n    } else if (Buffer.isBuffer(val)) {\n      return 'buffer';\n    }\n  }\n  return bucket;\n}\n\n/**\n * Check whether a collection of types leads to an ambiguous union.\n *\n * @param types {Array} Array of types.\n */\nfunction isAmbiguous(types) {\n  var buckets = {};\n  var i, l, bucket, type;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (!Type.isType(type, 'logical')) {\n      bucket = getTypeBucket(type);\n      if (buckets[bucket]) {\n        return true;\n      }\n      buckets[bucket] = true;\n    }\n  }\n  return false;\n}\n\n/**\n * Combine number types.\n *\n * Note that never have to create a new type here, we are guaranteed to be able\n * to reuse one of the input types as super-type.\n */\nfunction combineNumbers(types) {\n  var typeNames = ['int', 'long', 'float', 'double'];\n  var superIndex = -1;\n  var superType = null;\n  var i, l, type, index;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    index = typeNames.indexOf(type.typeName);\n    if (index > superIndex) {\n      superIndex = index;\n      superType = type;\n    }\n  }\n  return superType;\n}\n\n/**\n * Combine enums and strings.\n *\n * The order of the returned symbols is undefined and the returned enum is\n *\n */\nfunction combineStrings(types, opts) {\n  var symbols = {};\n  var i, l, type, typeSymbols;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'string') {\n      // If at least one of the types is a string, it will be the supertype.\n      return type;\n    }\n    typeSymbols = type.symbols;\n    var j, m;\n    for (j = 0, m = typeSymbols.length; j < m; j++) {\n      symbols[typeSymbols[j]] = true;\n    }\n  }\n  return Type.forSchema({type: 'enum', symbols: Object.keys(symbols)}, opts);\n}\n\n/**\n * Combine bytes and fixed.\n *\n * This function is optimized to avoid creating new types when possible: in\n * case of a size mismatch between fixed types, it will continue looking\n * through the array to find an existing bytes type (rather than exit early by\n * creating one eagerly).\n */\nfunction combineBuffers(types, opts) {\n  var size = -1;\n  var i, l, type;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'bytes') {\n      return type;\n    }\n    if (size === -1) {\n      size = type.size;\n    } else if (type.size !== size) {\n      // Don't create a bytes type right away, we might be able to reuse one\n      // later on in the types array. Just mark this for now.\n      size = -2;\n    }\n  }\n  return size < 0 ? Type.forSchema('bytes', opts) : types[0];\n}\n\n/**\n * Combine maps and records.\n *\n * Field defaults are kept when possible (i.e. when no coercion to a map\n * happens), with later definitions overriding previous ones.\n */\nfunction combineObjects(types, opts) {\n  var allTypes = []; // Field and value types.\n  var fieldTypes = {}; // Record field types grouped by field name.\n  var fieldDefaults = {};\n  var isValidRecord = true;\n\n  // Check whether the final type will be a map or a record.\n  var i, l, type, fields;\n  for (i = 0, l = types.length; i < l; i++) {\n    type = types[i];\n    if (type.typeName === 'map') {\n      isValidRecord = false;\n      allTypes.push(type.valuesType);\n    } else {\n      fields = type.fields;\n      var j, m, field, fieldDefault, fieldName, fieldType;\n      for (j = 0, m = fields.length; j < m; j++) {\n        field = fields[j];\n        fieldName = field.name;\n        fieldType = field.type;\n        allTypes.push(fieldType);\n        if (isValidRecord) {\n          if (!fieldTypes[fieldName]) {\n            fieldTypes[fieldName] = [];\n          }\n          fieldTypes[fieldName].push(fieldType);\n          fieldDefault = field.defaultValue();\n          if (fieldDefault !== undefined) {\n            // Later defaults will override any previous ones.\n            fieldDefaults[fieldName] = fieldDefault;\n          }\n        }\n      }\n    }\n  }\n\n  if (isValidRecord) {\n    // Check that no fields are missing and that we have the approriate\n    // defaults for those which are.\n    var fieldNames = Object.keys(fieldTypes);\n    for (i = 0, l = fieldNames.length; i < l; i++) {\n      fieldName = fieldNames[i];\n      if (\n        fieldTypes[fieldName].length < types.length &&\n        fieldDefaults[fieldName] === undefined\n      ) {\n        // At least one of the records is missing a field with no default.\n        if (opts && opts.strictDefaults) {\n          isValidRecord = false;\n        } else {\n          fieldTypes[fieldName].unshift(Type.forSchema('null', opts));\n          fieldDefaults[fieldName] = null;\n        }\n      }\n    }\n  }\n\n  var schema;\n  if (isValidRecord) {\n    schema = {\n      type: 'record',\n      fields: fieldNames.map(function (s) {\n        var fieldType = Type.forTypes(fieldTypes[s], opts);\n        var fieldDefault = fieldDefaults[s];\n        if (\n          fieldDefault !== undefined &&\n          ~fieldType.typeName.indexOf('union')\n        ) {\n          // Ensure that the default's corresponding type is first.\n          var unionTypes = fieldType.types.slice();\n          var i, l;\n          for (i = 0, l = unionTypes.length; i < l; i++) {\n            if (unionTypes[i].isValid(fieldDefault)) {\n              break;\n            }\n          }\n          if (i > 0) {\n            var unionType = unionTypes[0];\n            unionTypes[0] = unionTypes[i];\n            unionTypes[i] = unionType;\n            fieldType = Type.forSchema(unionTypes, opts);\n          }\n        }\n        return {\n          name: s,\n          type: fieldType,\n          'default': fieldDefaults[s]\n        };\n      })\n    };\n  } else {\n    schema = {\n      type: 'map',\n      values: Type.forTypes(allTypes, opts)\n    };\n  }\n  return Type.forSchema(schema, opts);\n}\n\n\nmodule.exports = {\n  Type: Type,\n  getTypeBucket: getTypeBucket,\n  getValueBucket: getValueBucket,\n  isPrimitive: isPrimitive,\n  builtins: (function () {\n    var types = {\n      LogicalType: LogicalType,\n      UnwrappedUnionType: UnwrappedUnionType,\n      WrappedUnionType: WrappedUnionType\n    };\n    var typeNames = Object.keys(TYPES);\n    var i, l, typeName;\n    for (i = 0, l = typeNames.length; i < l; i++) {\n      typeName = typeNames[i];\n      types[getClassName(typeName)] = TYPES[typeName];\n    }\n    return types;\n  })()\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/types.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/utils.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/utils.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* jshint node: true */\n\n// TODO: Make long comparison impervious to precision loss.\n// TODO: Optimize binary comparison methods.\n\n\n\n/** Various utilities used across this library. */\n\nvar crypto = __webpack_require__(/*! crypto */ \"./node_modules/avsc/etc/browser/lib/crypto.js\");\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\n// Shared buffer pool for all taps.\nvar POOL = new BufferPool(4096);\n\n// Valid (field, type, and symbol) name regex.\nvar NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;\n\n// Convenience imports.\nvar f = util.format;\n\n/**\n * Create a new empty buffer.\n *\n * @param size {Number} The buffer's size.\n */\nfunction newBuffer(size) {\n  if (typeof Buffer.alloc == 'function') {\n    return Buffer.alloc(size);\n  } else {\n    return new Buffer(size);\n  }\n}\n\n/**\n * Create a new buffer with the input contents.\n *\n * @param data {Array|String} The buffer's data.\n * @param enc {String} Encoding, used if data is a string.\n */\nfunction bufferFrom(data, enc) {\n  if (typeof Buffer.from == 'function') {\n    return Buffer.from(data, enc);\n  } else {\n    return new Buffer(data, enc);\n  }\n}\n\n/**\n * Uppercase the first letter of a string.\n *\n * @param s {String} The string.\n */\nfunction capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\n\n/**\n * Compare two numbers.\n *\n * @param n1 {Number} The first one.\n * @param n2 {Number} The second one.\n */\nfunction compare(n1, n2) { return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1); }\n\n/**\n * Get option or default if undefined.\n *\n * @param opts {Object} Options.\n * @param key {String} Name of the option.\n * @param def {...} Default value.\n *\n * This is useful mostly for true-ish defaults and false-ish values (where the\n * usual `||` idiom breaks down).\n */\nfunction getOption(opts, key, def) {\n  var value = opts[key];\n  return value === undefined ? def : value;\n}\n\n/**\n * Compute a string's hash.\n *\n * @param str {String} The string to hash.\n * @param algorithm {String} The algorithm used. Defaults to MD5.\n */\nfunction getHash(str, algorithm) {\n  algorithm = algorithm || 'md5';\n  var hash = crypto.createHash(algorithm);\n  hash.end(str);\n  return hash.read();\n}\n\n/**\n * Find index of value in array.\n *\n * @param arr {Array} Can also be a false-ish value.\n * @param v {Object} Value to find.\n *\n * Returns -1 if not found, -2 if found multiple times.\n */\nfunction singleIndexOf(arr, v) {\n  var pos = -1;\n  var i, l;\n  if (!arr) {\n    return -1;\n  }\n  for (i = 0, l = arr.length; i < l; i++) {\n    if (arr[i] === v) {\n      if (pos >= 0) {\n        return -2;\n      }\n      pos = i;\n    }\n  }\n  return pos;\n}\n\n/**\n * Convert array to map.\n *\n * @param arr {Array} Elements.\n * @param fn {Function} Function returning an element's key.\n */\nfunction toMap(arr, fn) {\n  var obj = {};\n  var i, elem;\n  for (i = 0; i < arr.length; i++) {\n    elem = arr[i];\n    obj[fn(elem)] = elem;\n  }\n  return obj;\n}\n\n/**\n * Convert map to array of values (polyfill for `Object.values`).\n *\n * @param obj {Object} Map.\n */\nfunction objectValues(obj) {\n  return Object.keys(obj).map(function (key) { return obj[key]; });\n}\n\n/**\n * Check whether an array has duplicates.\n *\n * @param arr {Array} The array.\n * @param fn {Function} Optional function to apply to each element.\n */\nfunction hasDuplicates(arr, fn) {\n  var obj = Object.create(null);\n  var i, l, elem;\n  for (i = 0, l = arr.length; i < l; i++) {\n    elem = arr[i];\n    if (fn) {\n      elem = fn(elem);\n    }\n    if (obj[elem]) {\n      return true;\n    }\n    obj[elem] = true;\n  }\n  return false;\n}\n\n/**\n * Copy properties from one object to another.\n *\n * @param src {Object} The source object.\n * @param dst {Object} The destination object.\n * @param overwrite {Boolean} Whether to overwrite existing destination\n * properties. Defaults to false.\n */\nfunction copyOwnProperties(src, dst, overwrite) {\n  var names = Object.getOwnPropertyNames(src);\n  var i, l, name;\n  for (i = 0, l = names.length; i < l; i++) {\n    name = names[i];\n    if (!dst.hasOwnProperty(name) || overwrite) {\n      var descriptor = Object.getOwnPropertyDescriptor(src, name);\n      Object.defineProperty(dst, name, descriptor);\n    }\n  }\n  return dst;\n}\n\n/**\n * Check whether a string is a valid Avro identifier.\n */\nfunction isValidName(str) { return NAME_PATTERN.test(str); }\n\n/**\n * Verify and return fully qualified name.\n *\n * @param name {String} Full or short name. It can be prefixed with a dot to\n * force global namespace.\n * @param namespace {String} Optional namespace.\n */\nfunction qualify(name, namespace) {\n  if (~name.indexOf('.')) {\n    name = name.replace(/^\\./, ''); // Allow absolute referencing.\n  } else if (namespace) {\n    name = namespace + '.' + name;\n  }\n  name.split('.').forEach(function (part) {\n    if (!isValidName(part)) {\n      throw new Error(f('invalid name: %j', name));\n    }\n  });\n  return name;\n}\n\n/**\n * Remove namespace from a name.\n *\n * @param name {String} Full or short name.\n */\nfunction unqualify(name) {\n  var parts = name.split('.');\n  return parts[parts.length - 1];\n}\n\n/**\n * Return the namespace implied by a name.\n *\n * @param name {String} Full or short name. If short, the returned namespace\n *  will be empty.\n */\nfunction impliedNamespace(name) {\n  var match = /^(.*)\\.[^.]+$/.exec(name);\n  return match ? match[1] : undefined;\n}\n\n/**\n * Returns offset in the string of the end of JSON object (-1 if past the end).\n *\n * To keep the implementation simple, this function isn't a JSON validator. It\n * will gladly return a result for invalid JSON (which is OK since that will be\n * promptly rejected by the JSON parser). What matters is that it is guaranteed\n * to return the correct end when presented with valid JSON.\n *\n * @param str {String} Input string containing serialized JSON..\n * @param pos {Number} Starting position.\n */\nfunction jsonEnd(str, pos) {\n  pos = pos | 0;\n\n  // Handle the case of a simple literal separately.\n  var c = str.charAt(pos++);\n  if (/[\\d-]/.test(c)) {\n    while (/[eE\\d.+-]/.test(str.charAt(pos))) {\n      pos++;\n    }\n    return pos;\n  } else if (/true|null/.test(str.slice(pos - 1, pos + 3))) {\n    return pos + 3;\n  } else if (/false/.test(str.slice(pos - 1, pos + 4))) {\n    return pos + 4;\n  }\n\n  // String, object, or array.\n  var depth = 0;\n  var literal = false;\n  do {\n    switch (c) {\n    case '{':\n    case '[':\n      if (!literal) { depth++; }\n      break;\n    case '}':\n    case ']':\n      if (!literal && !--depth) {\n        return pos;\n      }\n      break;\n    case '\"':\n      literal = !literal;\n      if (!depth && !literal) {\n        return pos;\n      }\n      break;\n    case '\\\\':\n      pos++; // Skip the next character.\n    }\n  } while ((c = str.charAt(pos++)));\n\n  return -1;\n}\n\n/** \"Abstract\" function to help with \"subclassing\". */\nfunction abstractFunction() { throw new Error('abstract'); }\n\n/** Batch-deprecate \"getters\" from an object's prototype. */\nfunction addDeprecatedGetters(obj, props) {\n  var proto = obj.prototype;\n  var i, l, prop, getter;\n  for (i = 0, l = props.length; i < l; i++) {\n    prop = props[i];\n    getter = 'get' + capitalize(prop);\n    proto[getter] = util.deprecate(\n      createGetter(prop),\n      'use `.' + prop + '` instead of `.' + getter + '()`'\n    );\n  }\n\n  function createGetter(prop) {\n    return function () {\n      var delegate = this[prop];\n      return typeof delegate == 'function' ?\n        delegate.apply(this, arguments) :\n        delegate;\n    };\n  }\n}\n\n/**\n * Simple buffer pool to avoid allocating many small buffers.\n *\n * This provides significant speedups in recent versions of node (6+).\n */\nfunction BufferPool(len) {\n  this._len = len | 0;\n  this._pos = 0;\n  this._slab = newBuffer(this._len);\n}\n\nBufferPool.prototype.alloc = function (len) {\n  if (len < 0) {\n    throw new Error('negative length');\n  }\n  var maxLen = this._len;\n  if (len > maxLen) {\n    return newBuffer(len);\n  }\n  if (this._pos + len > maxLen) {\n    this._slab = newBuffer(maxLen);\n    this._pos = 0;\n  }\n  return this._slab.slice(this._pos, this._pos += len);\n};\n\n/**\n * Generator of random things.\n *\n * Inspired by: http://stackoverflow.com/a/424445/1062617\n */\nfunction Lcg(seed) {\n  var a = 1103515245;\n  var c = 12345;\n  var m = Math.pow(2, 31);\n  var state = Math.floor(seed || Math.random() * (m - 1));\n\n  this._max = m;\n  this._nextInt = function () { return state = (a * state + c) % m; };\n}\n\nLcg.prototype.nextBoolean = function () {\n  // jshint -W018\n  return !!(this._nextInt() % 2);\n};\n\nLcg.prototype.nextInt = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? this._max : end;\n  return start + Math.floor(this.nextFloat() * (end - start));\n};\n\nLcg.prototype.nextFloat = function (start, end) {\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  end = end === undefined ? 1 : end;\n  return start + (end - start) * this._nextInt() / this._max;\n};\n\nLcg.prototype.nextString = function(len, flags) {\n  len |= 0;\n  flags = flags || 'aA';\n  var mask = '';\n  if (flags.indexOf('a') > -1) {\n    mask += 'abcdefghijklmnopqrstuvwxyz';\n  }\n  if (flags.indexOf('A') > -1) {\n    mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  }\n  if (flags.indexOf('#') > -1) {\n    mask += '0123456789';\n  }\n  if (flags.indexOf('!') > -1) {\n    mask += '~`!@#$%^&*()_+-={}[]:\";\\'<>?,./|\\\\';\n  }\n  var result = [];\n  for (var i = 0; i < len; i++) {\n    result.push(this.choice(mask));\n  }\n  return result.join('');\n};\n\nLcg.prototype.nextBuffer = function (len) {\n  var arr = [];\n  var i;\n  for (i = 0; i < len; i++) {\n    arr.push(this.nextInt(256));\n  }\n  return bufferFrom(arr);\n};\n\nLcg.prototype.choice = function (arr) {\n  var len = arr.length;\n  if (!len) {\n    throw new Error('choosing from empty array');\n  }\n  return arr[this.nextInt(len)];\n};\n\n/**\n * Ordered queue which returns items consecutively.\n *\n * This is actually a heap by index, with the added requirements that elements\n * can only be retrieved consecutively.\n */\nfunction OrderedQueue() {\n  this._index = 0;\n  this._items = [];\n}\n\nOrderedQueue.prototype.push = function (item) {\n  var items = this._items;\n  var i = items.length | 0;\n  var j;\n  items.push(item);\n  while (i > 0 && items[i].index < items[j = ((i - 1) >> 1)].index) {\n    item = items[i];\n    items[i] = items[j];\n    items[j] = item;\n    i = j;\n  }\n};\n\nOrderedQueue.prototype.pop = function () {\n  var items = this._items;\n  var len = (items.length - 1) | 0;\n  var first = items[0];\n  if (!first || first.index > this._index) {\n    return null;\n  }\n  this._index++;\n  if (!len) {\n    items.pop();\n    return first;\n  }\n  items[0] = items.pop();\n  var mid = len >> 1;\n  var i = 0;\n  var i1, i2, j, item, c, c1, c2;\n  while (i < mid) {\n    item = items[i];\n    i1 = (i << 1) + 1;\n    i2 = (i + 1) << 1;\n    c1 = items[i1];\n    c2 = items[i2];\n    if (!c2 || c1.index <= c2.index) {\n      c = c1;\n      j = i1;\n    } else {\n      c = c2;\n      j = i2;\n    }\n    if (c.index >= item.index) {\n      break;\n    }\n    items[j] = item;\n    items[i] = c;\n    i = j;\n  }\n  return first;\n};\n\n/**\n * A tap is a buffer which remembers what has been already read.\n *\n * It is optimized for performance, at the cost of failing silently when\n * overflowing the buffer. This is a purposeful trade-off given the expected\n * rarity of this case and the large performance hit necessary to enforce\n * validity. See `isValid` below for more information.\n */\nfunction Tap(buf, pos) {\n  this.buf = buf;\n  this.pos = pos | 0;\n  if (this.pos < 0) {\n    throw new Error('negative offset');\n  }\n}\n\n/**\n * Check that the tap is in a valid state.\n *\n * For efficiency reasons, none of the methods below will fail if an overflow\n * occurs (either read, skip, or write). For this reason, it is up to the\n * caller to always check that the read, skip, or write was valid by calling\n * this method.\n */\nTap.prototype.isValid = function () { return this.pos <= this.buf.length; };\n\nTap.prototype._invalidate = function () { this.pos = this.buf.length + 1; };\n\n// Read, skip, write methods.\n//\n// These should fail silently when the buffer overflows. Note this is only\n// required to be true when the functions are decoding valid objects. For\n// example errors will still be thrown if a bad count is read, leading to a\n// negative position offset (which will typically cause a failure in\n// `readFixed`).\n\nTap.prototype.readBoolean = function () { return !!this.buf[this.pos++]; };\n\nTap.prototype.skipBoolean = function () { this.pos++; };\n\nTap.prototype.writeBoolean = function (b) { this.buf[this.pos++] = !!b; };\n\nTap.prototype.readInt = Tap.prototype.readLong = function () {\n  var n = 0;\n  var k = 0;\n  var buf = this.buf;\n  var b, h, f, fk;\n\n  do {\n    b = buf[this.pos++];\n    h = b & 0x80;\n    n |= (b & 0x7f) << k;\n    k += 7;\n  } while (h && k < 28);\n\n  if (h) {\n    // Switch to float arithmetic, otherwise we might overflow.\n    f = n;\n    fk = 268435456; // 2 ** 28.\n    do {\n      b = buf[this.pos++];\n      f += (b & 0x7f) * fk;\n      fk *= 128;\n    } while (b & 0x80);\n    return (f % 2 ? -(f + 1) : f) / 2;\n  }\n\n  return (n >> 1) ^ -(n & 1);\n};\n\nTap.prototype.skipInt = Tap.prototype.skipLong = function () {\n  var buf = this.buf;\n  while (buf[this.pos++] & 0x80) {}\n};\n\nTap.prototype.writeInt = Tap.prototype.writeLong = function (n) {\n  var buf = this.buf;\n  var f, m;\n\n  if (n >= -1073741824 && n < 1073741824) {\n    // Won't overflow, we can use integer arithmetic.\n    m = n >= 0 ? n << 1 : (~n << 1) | 1;\n    do {\n      buf[this.pos] = m & 0x7f;\n      m >>= 7;\n    } while (m && (buf[this.pos++] |= 0x80));\n  } else {\n    // We have to use slower floating arithmetic.\n    f = n >= 0 ? n * 2 : (-n * 2) - 1;\n    do {\n      buf[this.pos] = f & 0x7f;\n      f /= 128;\n    } while (f >= 1 && (buf[this.pos++] |= 0x80));\n  }\n  this.pos++;\n};\n\nTap.prototype.readFloat = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return 0;\n  }\n  return this.buf.readFloatLE(pos);\n};\n\nTap.prototype.skipFloat = function () { this.pos += 4; };\n\nTap.prototype.writeFloat = function (f) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 4;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeFloatLE(f, pos);\n};\n\nTap.prototype.readDouble = function () {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return 0;\n  }\n  return this.buf.readDoubleLE(pos);\n};\n\nTap.prototype.skipDouble = function () { this.pos += 8; };\n\nTap.prototype.writeDouble = function (d) {\n  var buf = this.buf;\n  var pos = this.pos;\n  this.pos += 8;\n  if (this.pos > buf.length) {\n    return;\n  }\n  return this.buf.writeDoubleLE(d, pos);\n};\n\nTap.prototype.readFixed = function (len) {\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  var fixed = POOL.alloc(len);\n  this.buf.copy(fixed, 0, pos, pos + len);\n  return fixed;\n};\n\nTap.prototype.skipFixed = function (len) { this.pos += len; };\n\nTap.prototype.writeFixed = function (buf, len) {\n  len = len || buf.length;\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > this.buf.length) {\n    return;\n  }\n  buf.copy(this.buf, pos, 0, len);\n};\n\nTap.prototype.readBytes = function () {\n  var len = this.readLong();\n  if (len < 0) {\n    this._invalidate();\n    return;\n  }\n  return this.readFixed(len);\n};\n\nTap.prototype.skipBytes = function () {\n  var len = this.readLong();\n  if (len < 0) {\n    this._invalidate();\n    return;\n  }\n  this.pos += len;\n};\n\nTap.prototype.writeBytes = function (buf) {\n  var len = buf.length;\n  this.writeLong(len);\n  this.writeFixed(buf, len);\n};\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.utf8Slice == 'function') {\n  // Use this optimized function when available.\n  Tap.prototype.readString = function () {\n    var len = this.readLong();\n    if (len < 0) {\n      this._invalidate();\n      return '';\n    }\n    var pos = this.pos;\n    var buf = this.buf;\n    this.pos += len;\n    if (this.pos > buf.length) {\n      return;\n    }\n    return this.buf.utf8Slice(pos, pos + len);\n  };\n} else {\n  Tap.prototype.readString = function () {\n    var len = this.readLong();\n    if (len < 0) {\n      this._invalidate();\n      return '';\n    }\n    var pos = this.pos;\n    var buf = this.buf;\n    this.pos += len;\n    if (this.pos > buf.length) {\n      return;\n    }\n    return this.buf.slice(pos, pos + len).toString();\n  };\n}\n\nTap.prototype.skipString = function () {\n  var len = this.readLong();\n  if (len < 0) {\n    this._invalidate();\n    return;\n  }\n  this.pos += len;\n};\n\nTap.prototype.writeString = function (s) {\n  var len = Buffer.byteLength(s);\n  var buf = this.buf;\n  this.writeLong(len);\n  var pos = this.pos;\n  this.pos += len;\n  if (this.pos > buf.length) {\n    return;\n  }\n  if (len > 64 && typeof Buffer.prototype.utf8Write == 'function') {\n    // This method is roughly 50% faster than the manual implementation below\n    // for long strings (which is itself faster than the generic `Buffer#write`\n    // at least in most browsers, where `utf8Write` is not available).\n    buf.utf8Write(s, pos, len);\n  } else {\n    var i, l, c1, c2;\n    for (i = 0, l = len; i < l; i++) {\n      c1 = s.charCodeAt(i);\n      if (c1 < 0x80) {\n        buf[pos++] = c1;\n      } else if (c1 < 0x800) {\n        buf[pos++] = c1 >> 6 | 0xc0;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      } else if (\n        (c1 & 0xfc00) === 0xd800 &&\n        ((c2 = s.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n      ) {\n        c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n        i++;\n        buf[pos++] = c1 >> 18 | 0xf0;\n        buf[pos++] = c1 >> 12 & 0x3f | 0x80;\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      } else {\n        buf[pos++] = c1 >> 12 | 0xe0;\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\n        buf[pos++] = c1 & 0x3f | 0x80;\n      }\n    }\n  }\n};\n\n/* istanbul ignore else */\nif (typeof Buffer.prototype.latin1Write == 'function') {\n  // `binaryWrite` has been renamed to `latin1Write` in Node v6.4.0, see\n  // https://github.com/nodejs/node/pull/7111. Note that the `'binary'`\n  // encoding argument still works however.\n  Tap.prototype.writeBinary = function (str, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.latin1Write(str, pos, len);\n  };\n} else if (typeof Buffer.prototype.binaryWrite == 'function') {\n  Tap.prototype.writeBinary = function (str, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.binaryWrite(str, pos, len);\n  };\n} else {\n  // Slowest implementation.\n  Tap.prototype.writeBinary = function (s, len) {\n    var pos = this.pos;\n    this.pos += len;\n    if (this.pos > this.buf.length) {\n      return;\n    }\n    this.buf.write(s, pos, len, 'binary');\n  };\n}\n\n// Binary comparison methods.\n//\n// These are not guaranteed to consume the objects they are comparing when\n// returning a non-zero result (allowing for performance benefits), so no other\n// operations should be done on either tap after a compare returns a non-zero\n// value. Also, these methods do not have the same silent failure requirement\n// as read, skip, and write since they are assumed to be called on valid\n// buffers.\n\nTap.prototype.matchBoolean = function (tap) {\n  return this.buf[this.pos++] - tap.buf[tap.pos++];\n};\n\nTap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {\n  var n1 = this.readLong();\n  var n2 = tap.readLong();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchFloat = function (tap) {\n  var n1 = this.readFloat();\n  var n2 = tap.readFloat();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchDouble = function (tap) {\n  var n1 = this.readDouble();\n  var n2 = tap.readDouble();\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\n};\n\nTap.prototype.matchFixed = function (tap, len) {\n  return this.readFixed(len).compare(tap.readFixed(len));\n};\n\nTap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {\n  var l1 = this.readLong();\n  var p1 = this.pos;\n  this.pos += l1;\n  var l2 = tap.readLong();\n  var p2 = tap.pos;\n  tap.pos += l2;\n  var b1 = this.buf.slice(p1, this.pos);\n  var b2 = tap.buf.slice(p2, tap.pos);\n  return b1.compare(b2);\n};\n\n// Functions for supporting custom long classes.\n//\n// The two following methods allow the long implementations to not have to\n// worry about Avro's zigzag encoding, we directly expose longs as unpacked.\n\nTap.prototype.unpackLongBytes = function () {\n  var res = newBuffer(8);\n  var n = 0;\n  var i = 0; // Byte index in target buffer.\n  var j = 6; // Bit offset in current target buffer byte.\n  var buf = this.buf;\n  var b, neg;\n\n  b = buf[this.pos++];\n  neg = b & 1;\n  res.fill(0);\n\n  n |= (b & 0x7f) >> 1;\n  while (b & 0x80) {\n    b = buf[this.pos++];\n    n |= (b & 0x7f) << j;\n    j += 7;\n    if (j >= 8) {\n      // Flush byte.\n      j -= 8;\n      res[i++] = n;\n      n >>= 8;\n    }\n  }\n  res[i] = n;\n\n  if (neg) {\n    invert(res, 8);\n  }\n\n  return res;\n};\n\nTap.prototype.packLongBytes = function (buf) {\n  var neg = (buf[7] & 0x80) >> 7;\n  var res = this.buf;\n  var j = 1;\n  var k = 0;\n  var m = 3;\n  var n;\n\n  if (neg) {\n    invert(buf, 8);\n    n = 1;\n  } else {\n    n = 0;\n  }\n\n  var parts = [\n    buf.readUIntLE(0, 3),\n    buf.readUIntLE(3, 3),\n    buf.readUIntLE(6, 2)\n  ];\n  // Not reading more than 24 bits because we need to be able to combine the\n  // \"carry\" bits from the previous part and JavaScript only supports bitwise\n  // operations on 32 bit integers.\n  while (m && !parts[--m]) {} // Skip trailing 0s.\n\n  // Leading parts (if any), we never bail early here since we need the\n  // continuation bit to be set.\n  while (k < m) {\n    n |= parts[k++] << j;\n    j += 24;\n    while (j > 7) {\n      res[this.pos++] = (n & 0x7f) | 0x80;\n      n >>= 7;\n      j -= 7;\n    }\n  }\n\n  // Final part, similar to normal packing aside from the initial offset.\n  n |= parts[m] << j;\n  do {\n    res[this.pos] = n & 0x7f;\n    n >>= 7;\n  } while (n && (res[this.pos++] |= 0x80));\n  this.pos++;\n\n  // Restore original buffer (could make this optional?).\n  if (neg) {\n    invert(buf, 8);\n  }\n};\n\n// Helpers.\n\n/**\n * Invert all bits in a buffer.\n *\n * @param buf {Buffer} Non-empty buffer to invert.\n * @param len {Number} Buffer length (must be positive).\n */\nfunction invert(buf, len) {\n  while (len--) {\n    buf[len] = ~buf[len];\n  }\n}\n\n\nmodule.exports = {\n  abstractFunction: abstractFunction,\n  addDeprecatedGetters: addDeprecatedGetters,\n  bufferFrom: bufferFrom,\n  capitalize: capitalize,\n  copyOwnProperties: copyOwnProperties,\n  getHash: getHash,\n  compare: compare,\n  getOption: getOption,\n  impliedNamespace: impliedNamespace,\n  isValidName: isValidName,\n  jsonEnd: jsonEnd,\n  newBuffer: newBuffer,\n  objectValues: objectValues,\n  qualify: qualify,\n  toMap: toMap,\n  singleIndexOf: singleIndexOf,\n  hasDuplicates: hasDuplicates,\n  unqualify: unqualify,\n  BufferPool: BufferPool,\n  Lcg: Lcg,\n  OrderedQueue: OrderedQueue,\n  Tap: Tap\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/utils.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar callBind = __webpack_require__(/*! ./ */ \"./node_modules/call-bind/index.js\");\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/call-bind/callBound.js?");

/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/call-bind/index.js?");

/***/ }),

/***/ "./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\nconst fs = __webpack_require__(/*! fs */ \"?a0c3\")\nconst path = __webpack_require__(/*! path */ \"./node_modules/path/path.js\")\nconst os = __webpack_require__(/*! os */ \"?613f\")\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parser src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _log (message) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(\"MISSING_ENV_VAR\", key)) {\n        \"MISSING_ENV_VAR\"[key] = parsed[key]\n      } else {\n        if (override === true) {\n          \"MISSING_ENV_VAR\"[key] = parsed[key]\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`)\n          } else {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`)\n          }\n        }\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    if (debug) {\n      _log(`Failed to load ${dotenvPath} ${e.message}`)\n    }\n\n    return { error: e }\n  }\n}\n\nconst DotenvModule = {\n  config,\n  parse\n}\n\nmodule.exports.config = DotenvModule.config\nmodule.exports.parse = DotenvModule.parse\nmodule.exports = DotenvModule\n\n\n//# sourceURL=webpack://js-kart/./node_modules/dotenv/lib/main.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"./node_modules/is-callable/index.js\");\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/for-each/index.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar hasOwn = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/g, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/get-intrinsic/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/has-symbols/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/has-symbols/shams.js?");

/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasSymbols = __webpack_require__(/*! has-symbols/shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/has-tostringtag/shams.js?");

/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack://js-kart/./node_modules/has/src/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/is-arguments/index.js?");

/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar fnToStr = Function.prototype.toString;\nvar reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;\nvar badArrayLike;\nvar isCallableMarker;\nif (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {\n\ttry {\n\t\tbadArrayLike = Object.defineProperty({}, 'length', {\n\t\t\tget: function () {\n\t\t\t\tthrow isCallableMarker;\n\t\t\t}\n\t\t});\n\t\tisCallableMarker = {};\n\t\t// eslint-disable-next-line no-throw-literal\n\t\treflectApply(function () { throw 42; }, null, badArrayLike);\n\t} catch (_) {\n\t\tif (_ !== isCallableMarker) {\n\t\t\treflectApply = null;\n\t\t}\n\t}\n} else {\n\treflectApply = null;\n}\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`\n/* globals document: false */\nvar documentDotAll = typeof document === 'object' && typeof document.all === 'undefined' && document.all !== undefined ? document.all : {};\n\nmodule.exports = reflectApply\n\t? function isCallable(value) {\n\t\tif (value === documentDotAll) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (typeof value === 'function' && !value.prototype) { return true; }\n\t\ttry {\n\t\t\treflectApply(value, null, badArrayLike);\n\t\t} catch (e) {\n\t\t\tif (e !== isCallableMarker) { return false; }\n\t\t}\n\t\treturn !isES6ClassFn(value);\n\t}\n\t: function isCallable(value) {\n\t\tif (value === documentDotAll) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (typeof value === 'function' && !value.prototype) { return true; }\n\t\tif (hasToStringTag) { return tryFunctionObject(value); }\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tvar strClass = toStr.call(value);\n\t\treturn strClass === fnClass || strClass === genClass;\n\t};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/is-callable/index.js?");

/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/is-generator-function/index.js?");

/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! for-each */ \"./node_modules/for-each/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/is-typed-array/index.js?");

/***/ }),

/***/ "./node_modules/path/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/path/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/path/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/path/node_modules/util/support/isBufferBrowser.js":
/*!************************************************************************!*\
  !*** ./node_modules/path/node_modules/util/support/isBufferBrowser.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://js-kart/./node_modules/path/node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/path/node_modules/util/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/path/node_modules/util/util.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(__webpack_require__.g.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = \"MISSING_ENV_VAR\".NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/path/node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/path/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/path/node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/path/path.js":
/*!***********************************!*\
  !*** ./node_modules/path/path.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n\r\nvar isWindows = process.platform === 'win32';\r\nvar util = __webpack_require__(/*! util */ \"./node_modules/path/node_modules/util/util.js\");\r\n\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  var res = [];\r\n  for (var i = 0; i < parts.length; i++) {\r\n    var p = parts[i];\r\n\r\n    // ignore empty parts\r\n    if (!p || p === '.')\r\n      continue;\r\n\r\n    if (p === '..') {\r\n      if (res.length && res[res.length - 1] !== '..') {\r\n        res.pop();\r\n      } else if (allowAboveRoot) {\r\n        res.push('..');\r\n      }\r\n    } else {\r\n      res.push(p);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// returns an array with empty elements removed from either end of the input\r\n// array or the original array if no elements need to be removed\r\nfunction trimArray(arr) {\r\n  var lastIndex = arr.length - 1;\r\n  var start = 0;\r\n  for (; start <= lastIndex; start++) {\r\n    if (arr[start])\r\n      break;\r\n  }\r\n\r\n  var end = lastIndex;\r\n  for (; end >= 0; end--) {\r\n    if (arr[end])\r\n      break;\r\n  }\r\n\r\n  if (start === 0 && end === lastIndex)\r\n    return arr;\r\n  if (start > end)\r\n    return [];\r\n  return arr.slice(start, end + 1);\r\n}\r\n\r\n// Regex to split a windows path into three parts: [*, device, slash,\r\n// tail] windows-only\r\nvar splitDeviceRe =\r\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\r\n\r\n// Regex to split the tail part of the above into [*, dir, basename, ext]\r\nvar splitTailRe =\r\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\r\n\r\nvar win32 = {};\r\n\r\n// Function to split a filename into [root, dir, basename, ext]\r\nfunction win32SplitPath(filename) {\r\n  // Separate device+slash from tail\r\n  var result = splitDeviceRe.exec(filename),\r\n      device = (result[1] || '') + (result[2] || ''),\r\n      tail = result[3] || '';\r\n  // Split the tail into dir, basename and extension\r\n  var result2 = splitTailRe.exec(tail),\r\n      dir = result2[1],\r\n      basename = result2[2],\r\n      ext = result2[3];\r\n  return [device, dir, basename, ext];\r\n}\r\n\r\nfunction win32StatPath(path) {\r\n  var result = splitDeviceRe.exec(path),\r\n      device = result[1] || '',\r\n      isUnc = !!device && device[1] !== ':';\r\n  return {\r\n    device: device,\r\n    isUnc: isUnc,\r\n    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\r\n    tail: result[3]\r\n  };\r\n}\r\n\r\nfunction normalizeUNCRoot(device) {\r\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\r\n}\r\n\r\n// path.resolve([from ...], to)\r\nwin32.resolve = function() {\r\n  var resolvedDevice = '',\r\n      resolvedTail = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1; i--) {\r\n    var path;\r\n    if (i >= 0) {\r\n      path = arguments[i];\r\n    } else if (!resolvedDevice) {\r\n      path = process.cwd();\r\n    } else {\r\n      // Windows has the concept of drive-specific current working\r\n      // directories. If we've resolved a drive letter but not yet an\r\n      // absolute path, get cwd for that drive. We're sure the device is not\r\n      // an unc path at this points, because unc paths are always absolute.\r\n      path = \"MISSING_ENV_VAR\"['=' + resolvedDevice];\r\n      // Verify that a drive-local cwd was found and that it actually points\r\n      // to our drive. If not, default to the drive's root.\r\n      if (!path || path.substr(0, 3).toLowerCase() !==\r\n          resolvedDevice.toLowerCase() + '\\\\') {\r\n        path = resolvedDevice + '\\\\';\r\n      }\r\n    }\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    var result = win32StatPath(path),\r\n        device = result.device,\r\n        isUnc = result.isUnc,\r\n        isAbsolute = result.isAbsolute,\r\n        tail = result.tail;\r\n\r\n    if (device &&\r\n        resolvedDevice &&\r\n        device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n      // This path points to another device so it is not applicable\r\n      continue;\r\n    }\r\n\r\n    if (!resolvedDevice) {\r\n      resolvedDevice = device;\r\n    }\r\n    if (!resolvedAbsolute) {\r\n      resolvedTail = tail + '\\\\' + resolvedTail;\r\n      resolvedAbsolute = isAbsolute;\r\n    }\r\n\r\n    if (resolvedDevice && resolvedAbsolute) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Convert slashes to backslashes when `resolvedDevice` points to an UNC\r\n  // root. Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path,\r\n  // but handle relative paths to be safe (might happen when process.cwd()\r\n  // fails)\r\n\r\n  // Normalize the tail path\r\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\r\n                                !resolvedAbsolute).join('\\\\');\r\n\r\n  return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n         '.';\r\n};\r\n\r\n\r\nwin32.normalize = function(path) {\r\n  var result = win32StatPath(path),\r\n      device = result.device,\r\n      isUnc = result.isUnc,\r\n      isAbsolute = result.isAbsolute,\r\n      tail = result.tail,\r\n      trailingSlash = /[\\\\\\/]$/.test(tail);\r\n\r\n  // Normalize the tail path\r\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\r\n\r\n  if (!tail && !isAbsolute) {\r\n    tail = '.';\r\n  }\r\n  if (tail && trailingSlash) {\r\n    tail += '\\\\';\r\n  }\r\n\r\n  // Convert slashes to backslashes when `device` points to an UNC root.\r\n  // Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    device = normalizeUNCRoot(device);\r\n  }\r\n\r\n  return device + (isAbsolute ? '\\\\' : '') + tail;\r\n};\r\n\r\n\r\nwin32.isAbsolute = function(path) {\r\n  return win32StatPath(path).isAbsolute;\r\n};\r\n\r\nwin32.join = function() {\r\n  var paths = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    if (!util.isString(arg)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (arg) {\r\n      paths.push(arg);\r\n    }\r\n  }\r\n\r\n  var joined = paths.join('\\\\');\r\n\r\n  // Make sure that the joined path doesn't start with two slashes, because\r\n  // normalize() will mistake it for an UNC path then.\r\n  //\r\n  // This step is skipped when it is very clear that the user actually\r\n  // intended to point at an UNC path. This is assumed when the first\r\n  // non-empty string arguments starts with exactly two slashes followed by\r\n  // at least one more non-slash character.\r\n  //\r\n  // Note that for normalize() to treat a path as an UNC path it needs to\r\n  // have at least 2 components, so we don't filter for that here.\r\n  // This means that the user can use join to construct UNC paths from\r\n  // a server name and a share name; for example:\r\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\r\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\r\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\r\n  }\r\n\r\n  return win32.normalize(joined);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// it will solve the relative path from 'from' to 'to', for instance:\r\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\nwin32.relative = function(from, to) {\r\n  from = win32.resolve(from);\r\n  to = win32.resolve(to);\r\n\r\n  // windows is not case sensitive\r\n  var lowerFrom = from.toLowerCase();\r\n  var lowerTo = to.toLowerCase();\r\n\r\n  var toParts = trimArray(to.split('\\\\'));\r\n\r\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\r\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\r\n\r\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (lowerFromParts[i] !== lowerToParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (samePartsLength == 0) {\r\n    return to;\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('\\\\');\r\n};\r\n\r\n\r\nwin32._makeLong = function(path) {\r\n  // Note: this will *probably* throw somewhere.\r\n  if (!util.isString(path))\r\n    return path;\r\n\r\n  if (!path) {\r\n    return '';\r\n  }\r\n\r\n  var resolvedPath = win32.resolve(path);\r\n\r\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\r\n    // path is local filesystem path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\' + resolvedPath;\r\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\r\n    // path is network UNC path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\n\r\nwin32.dirname = function(path) {\r\n  var result = win32SplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nwin32.basename = function(path, ext) {\r\n  var f = win32SplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nwin32.extname = function(path) {\r\n  return win32SplitPath(path)[3];\r\n};\r\n\r\n\r\nwin32.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir;\r\n  var base = pathObject.base || '';\r\n  if (!dir) {\r\n    return base;\r\n  }\r\n  if (dir[dir.length - 1] === win32.sep) {\r\n    return dir + base;\r\n  }\r\n  return dir + win32.sep + base;\r\n};\r\n\r\n\r\nwin32.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = win32SplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nwin32.sep = '\\\\';\r\nwin32.delimiter = ';';\r\n\r\n\r\n// Split a filename into [root, dir, basename, ext], unix version\r\n// 'root' is just a slash, or nothing.\r\nvar splitPathRe =\r\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\nvar posix = {};\r\n\r\n\r\nfunction posixSplitPath(filename) {\r\n  return splitPathRe.exec(filename).slice(1);\r\n}\r\n\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nposix.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path[0] === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\r\n                                !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nposix.normalize = function(path) {\r\n  var isAbsolute = posix.isAbsolute(path),\r\n      trailingSlash = path && path[path.length - 1] === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nposix.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nposix.join = function() {\r\n  var path = '';\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var segment = arguments[i];\r\n    if (!util.isString(segment)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (segment) {\r\n      if (!path) {\r\n        path += segment;\r\n      } else {\r\n        path += '/' + segment;\r\n      }\r\n    }\r\n  }\r\n  return posix.normalize(path);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nposix.relative = function(from, to) {\r\n  from = posix.resolve(from).substr(1);\r\n  to = posix.resolve(to).substr(1);\r\n\r\n  var fromParts = trimArray(from.split('/'));\r\n  var toParts = trimArray(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\n\r\nposix._makeLong = function(path) {\r\n  return path;\r\n};\r\n\r\n\r\nposix.dirname = function(path) {\r\n  var result = posixSplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nposix.basename = function(path, ext) {\r\n  var f = posixSplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nposix.extname = function(path) {\r\n  return posixSplitPath(path)[3];\r\n};\r\n\r\n\r\nposix.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\r\n  var base = pathObject.base || '';\r\n  return dir + base;\r\n};\r\n\r\n\r\nposix.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = posixSplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  allParts[1] = allParts[1] || '';\r\n  allParts[2] = allParts[2] || '';\r\n  allParts[3] = allParts[3] || '';\r\n\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nposix.sep = '/';\r\nposix.delimiter = ':';\r\n\r\n\r\nif (isWindows)\r\n  module.exports = win32;\r\nelse /* posix */\r\n  module.exports = posix;\r\n\r\nmodule.exports.posix = posix;\r\nmodule.exports.win32 = win32;\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/path/path.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://js-kart/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://js-kart/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n\n\nvar isArgumentsObject = __webpack_require__(/*! is-arguments */ \"./node_modules/is-arguments/index.js\");\nvar isGeneratorFunction = __webpack_require__(/*! is-generator-function */ \"./node_modules/is-generator-function/index.js\");\nvar whichTypedArray = __webpack_require__(/*! which-typed-array */ \"./node_modules/which-typed-array/index.js\");\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n\n\n//# sourceURL=webpack://js-kart/./node_modules/util/support/types.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (\"MISSING_ENV_VAR\".NODE_DEBUG) {\n  var debugEnv = \"MISSING_ENV_VAR\".NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = __webpack_require__(/*! ./support/types */ \"./node_modules/util/support/types.js\");\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! for-each */ \"./node_modules/for-each/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/which-typed-array/index.js?");

/***/ }),

/***/ "./src/client/client.js":
/*!******************************!*\
  !*** ./src/client/client.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Car = __webpack_require__(/*! ../shared_modules/car */ \"./src/shared_modules/car.js\");\nconst util = __webpack_require__(/*! ../shared_modules/util */ \"./src/shared_modules/util.js\");\nconst PhysX = __webpack_require__(/*! ../shared_modules/physx */ \"./src/shared_modules/physx.js\");\nconst Vec2D = PhysX.Vec2D;\nconst PhysObject = PhysX.PhysObject;\nconst PhysEnv = PhysX.PhysEnv;\n\nconst wall_material = {\n    density: Infinity,\n    restitution: .5,\n    sFriction: .24,\n    dFriction: .16,\n};\n\nclass Client {\n    constructor() {\n        this.tick;\n        this.confirmedTick;\n        this.delay = 8;     // built in delay to help smooth lag spikes\n        this.latency = 40;\n\n        this.state = {\n            scene: null,\n            cars: {},\n            walls: [], \n        };\n\n        this.env = new PhysEnv(1);\n\n        this.stateBuffer = [];\n        this.inputBuffer = [];\n        \n        this.id;\n        this.viewID;\n        this.isSpectator;\n        this.freezeTime = 0;\n        \n        this.inputs = {\n            left: false,\n            right: false,\n            up: false,\n            down: false,\n            shift: false,\n            enter: false,\n        }\n    }\n\n    getTick() {\n        return (util.getTime() + this.latency) / 16;\n    }\n\n    processPacket(packet, event) {\n        switch(event) {\n            case 'id':\n                this.id = packet;\n                this.updateViewID();\n\n                console.log(\"Client ID: \" + this.id);\n                break;\n\n            // Set the client's car in the current state to history\n            case 'rewind':\n                let A = this.state.cars[this.id];\n                let B = packet;\n\n                if(!A && !B)\n                    return;\n                \n                if(A && !B) {\n                    this.env.removeObject(A);\n                    delete this.state.cars[this.id];\n\n                    return;\n                }\n                \n                if(!A && B) {\n                    this.state.cars[this.id] = new Car(B.pos, B.hue);\n                    this.state.cars[this.id].masks = ['car-car'];\n                    this.env.addObject(this.state.cars[this.id]);\n                }\n                \n                this.updateCar(this.state.cars[this.id], B);\n                break;\n\n            case 'dynamic':\n                for(let i = 0; i < util.MAX_PLAYERS; i++) {\n                    let A = this.state.cars[i];\n                    let B = packet.cars[i];\n\n                    if(!A && !B || i == this.id)\n                        continue;\n                    \n                    if(A && !B) {\n                        this.env.removeObject(A);\n                        delete this.state.cars[i];\n\n                        continue;\n                    }\n                    \n                    if(!A && B) {\n                        this.state.cars[i] = new Car(B.pos, B.hue);\n                        this.state.cars[i].masks = ['car-car'];\n                        this.env.addObject(this.state.cars[i]);\n                    }\n                    \n                    this.updateCar(this.state.cars[i], B);\n                }\n\n                break;\n\n            case 'static':\n                const changeScene = this.state.scene != packet.scene;    \n\n                if(this.state.scene == \"lobby\" && packet.scene == \"race\") {\n                    this.freezeTime = 5;\n                }\n\n                this.state.scene = packet.scene;\n                this.state.walls = [];\n                \n                for(const border of packet.walls) {\n                    let new_border = [];\n\n                    for(const ref of border) {\n                        let pos = new Vec2D(ref.pos.x, ref.pos.y);\n                        \n                        let points = [];\n                        for(const point of ref.points) {\n                            points.push(new Vec2D(point.x, point.y));\n                        }\n\n                        let wall = new PhysObject(pos, points, wall_material);\n                        new_border.push(wall);\n                    }\n\n                    this.state.walls.push(new_border);\n                }\n\n                if(changeScene)\n                    this.resetEnv();\n                break;\n            default:\n        }\n    }\n\n    updateCar(car, ref) {\n        car.pos = new Vec2D(ref.pos.x, ref.pos.y);\n        car.vel = new Vec2D(ref.vel.x, ref.vel.y);\n\n        car.angle = ref.angle;\n        car.rotVel = ref.rotVel;\n\n        car.ready = ref.ready;\n        car.lap = ref.lap;\n\n        car.inputs = ref.inputs;\n\n        for(let i = 0; i < car.points.length; i++) {\n            car.points[i] = Vec2D.rotate({x: 0, y: 0}, car.shape[i], car.angle);\n            car.points[i].add(car.pos);\n        }\n    }\n\n    resetEnv() {\n        console.log(\"RESET ENV\");\n        this.env.clearObjects();\n\n        for(const car of Object.values(this.state.cars))\n            this.env.addObject(car);\n\n        for(const border of this.state.walls)\n            for(const wall of border)\n                this.env.addObject(wall);\n    }\n\n    updateViewID() {\n        this.isSpectator = this.id >= util.MAX_PLAYERS || (this.state.scene == \"race\" && this.state.cars[this.id].ready)\n        \n        if(!this.isSpectator) {\n            this.viewID = this.id;\n        } else if(!this.state.cars[this.viewID]) {\n            this.viewID = Object.keys(this.state.cars)[0];\n        }\n    }\n\n    changeViewID() {\n        let d = 0;\n\n        if(this.inputs.left)\n            d--;\n\n        if(this.inputs.right)\n            d++;\n\n        if(d == 0)\n            return;\n        \n        const cars = Object.entries(this.state.cars);\n\n        let idx = 0;\n        for(const id of Object.keys(this.state.cars)) {\n            if(id == this.viewID) {\n                this.viewID = cars[(idx + d + cars.length) % cars.length][0];\n                return;\n            }\n            idx++;\n        }\n    }\n\n    lerpState(alpha) {\n        let buffer = util.getBuffer(this.stateBuffer, this.tick - 1);\n        \n        if(!buffer)\n            return this.state;\n        \n        let lerp = {};\n        let curr = this.state.cars;\n        let last = buffer.cars;\n\n        for(let i = 0; i < util.MAX_PLAYERS; i++) {\n            let a = curr[i];\n            let b = last[i];\n\n            if(!a)  \n                continue;\n\n            if(!b) {\n                lerp[i] = a;\n                continue;\n            }\n            \n            let obj = util.copyObj(a);\n            \n            obj.pos.x = b.pos.x * (1 - alpha) + a.pos.x * alpha;\n            obj.pos.y = b.pos.y * (1 - alpha) + a.pos.y * alpha;\n            obj.vel.x = b.vel.x * (1 - alpha) + a.vel.x * alpha;\n            obj.vel.y = b.vel.y * (1 - alpha) + a.vel.y * alpha;\n            obj.angle = b.angle * (1 - alpha) + a.angle * alpha;\n            obj.rotVel = b.rotVel * (1 - alpha) + a.rotVel * alpha;\n\n            for(let i = 0; i < obj.points.length; i++) {\n                obj.points[i] = Vec2D.rotate({x: 0, y: 0}, Car.POINTS[i], obj.angle);\n                obj.points[i].add(obj.pos);\n            }\n\n            lerp[i] = obj;\n        }\n\n        let state = util.copyObj(this.state);\n        state.cars = lerp;\n\n        return state;\n    }\n\n    copyDynamicState(state) {\n        let newState = {};\n\n        newState.cars = {};\n        \n        for(const [idx, obj] of Object.entries(state.cars)) {\n            if(idx == this.idx)\n                continue;\n\n            newState.cars[idx] = this.copyCarState(obj);\n        }\n\n        return newState;\n    }\n\n    copyCarState(car) {\n        return {\n            angle:  car.angle,\n            rotVel: car.rotVel,\n            lap:    car.lap,\n            ready:  car.ready,\n            pos: {\n                x:  car.pos.x,\n                y:  car.pos.y,\n            },\n            vel: {\n                x:  car.vel.x,\n                y:  car.vel.y,\n            },\n            inputs: {\n                up: car.inputs.up,\n                down: car.inputs.down,\n                left: car.inputs.left,\n                right: car.inputs.right,\n                shift: car.inputs.shift,\n                enter: car.inputs.enter,\n            }\n        };\n    }\n\n    comparePlayerStates(A, B) {\n        const t_tolerance = 1;\n        const a_tolerance = .1;\n\n        if(!A || !B)\n            return false;\n\n        const tx = A.pos.x - B.pos.x;\n        const ty = A.pos.y - B.pos.y;\n        const tdif2 = tx * tx + ty * ty;\n\n        const vx = A.vel.x - B.vel.x;\n        const vy = A.vel.y - B.vel.y;\n        const vdif2 = vx * vx + vy * vy;\n\n        if(tdif2 > t_tolerance * t_tolerance)\n            return false;\n            \n        if(vdif2 > t_tolerance * t_tolerance)\n            return false;\n        \n        if(Math.abs(A.rotVel - B.rotVel) > a_tolerance)\n            return false;\n\n        if(Math.abs(A.angle - B.angle) > a_tolerance)\n            return false;\n\n        if(A.ready != B.ready)\n            return false;\n\n        if(A.lap != B.lap)\n            return false;\n\n        return true;\n    }\n\n    update(dt) {\n        if(this.freezeTime > 0) {\n            this.freezeTime -= dt;\n            return;\n        }\n\n        for(const [id, car] of Object.entries(this.state.cars)) {\n            car.controlPlayer(dt);\n        }\n\n        this.env.update(dt);\n    }\n}\n\nmodule.exports = Client;\n\n//# sourceURL=webpack://js-kart/./src/client/client.js?");

/***/ }),

/***/ "./src/client/index.js":
/*!*****************************!*\
  !*** ./src/client/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! ../shared_modules/util */ \"./src/shared_modules/util.js\");\nconst Client = __webpack_require__(/*! ./client */ \"./src/client/client.js\");\nconst Camera = __webpack_require__(/*! ../shared_modules/camera */ \"./src/shared_modules/camera.js\");\nconst avsc = __webpack_require__(/*! ../shared_modules/serialize.js */ \"./src/shared_modules/serialize.js\");\n(__webpack_require__(/*! dotenv */ \"./node_modules/dotenv/lib/main.js\").config)();\n\nconst HOST = \"ws://jskart-env.eba-cu8cyf69.us-east-2.elasticbeanstalk.com\";\nconsole.log(HOST);\n\nlet socket = new WebSocket(HOST);\n\nlet client = new Client(); \n\nlet canvas = document.getElementById(\"paper\");\nlet camera = new Camera(canvas);\n\n// TODO: create circular queue for messages\nlet messageTypes = {};\nlet messages = [];\n\ndocument.fonts.ready.then(() => {\n    camera.drawLoading();\n});\n\nsocket.onerror = error => {\n    camera.drawError(error);\n}\n\nsocket.onopen = event => {\n    console.log(\"Client connected!\");\n\n    client.tick = Math.floor(client.getTick());\n    waitForID();\n}\n\nsocket.onmessage = async event => {\n    const buffer = await event.data.arrayBuffer();\n    let data = avsc.decode(buffer);\n\n    if(data.packets.ping) {\n        client.latency = data.packets.ping.latency + client.delay;\n        client.tickLatency = Math.floor(client.latency / 16);\n        socket.send(avsc.encode(data));\n        return;\n    }\n\n    pushMessage(data);\n\n    if(messages.length > 128) {\n        for(const [idx, message] of messages.entries()) {\n            \n            necessary = false;\n\n            for(const id of Object.keys(message.packets)) {\n                if(messageTypes[id] <= 1) {\n                    necessary = true;\n                    break;\n                }\n            }\n\n            if(!necessary) {\n                popMessage(idx);\n                return;\n            }\n        }\n    }\n}\n\nfunction pushMessage(message) {\n    messages.push(message);\n\n    for(const id of Object.keys(message.packets)) {\n        if(messageTypes[id]) {\n            messageTypes[id]++;\n        } else {\n            messageTypes[id] = 1;\n        }\n    }\n}\n\nfunction popMessage(idx) {\n    for(const id of Object.keys(messages[idx].packets)) {\n        messageTypes[id]--;\n    }\n                    \n    return messages.splice(idx, 1)[0];\n}\n\nfunction processTick(tick) {\n    let rewind = client.tick;\n    let auth_state = null;\n    \n    while(messages.length > 0 && messages[0].tick < tick) {\n        const message = popMessage(0);\n\n        if(message.packets.id != null)\n            client.processPacket(message.packets.id, 'id');\n        \n        if(message.packets.static)\n            client.processPacket(message.packets.static, 'static');\n\n        if(message.packets.dynamic) {\n            client.processPacket(message.packets.dynamic, 'dynamic');\n\n            const buffered = util.getBuffer(client.stateBuffer, message.tick);\n            if(buffered && !client.isSpectator) {\n                if(client.comparePlayerStates(buffered.cars[client.id], message.packets.dynamic.cars[client.id])) {\n                    rewind = client.tick;\n                    auth_state = null;\n                } else {\n                    rewind = message.tick;\n                    auth_state = message.packets.dynamic.cars[client.id];\n                }\n            } else {\n                auth_state = message.packets.dynamic.cars[client.id];\n            }\n        }\n    }\n\n    if(auth_state) {\n        client.processPacket(auth_state, 'rewind');\n    }\n\n    return rewind;\n}\n\nfunction handleInputs() {\n    let bufferFrame = util.getBuffer(client.stateBuffer, client.tick - 1);\n    let hasBuffer = !client.isSpectator && bufferFrame;\n    let bufferedInputs = null;\n    \n    if(hasBuffer)\n        bufferedInputs = bufferFrame.cars[client.id].inputs;\n\n    for(const key in client.inputs) {\n        if(!hasBuffer || client.inputs[key] != bufferedInputs[key]) {\n            sendInputs(client.inputs);\n\n            if(client.isSpectator)\n                client.changeViewID();\n\n            break;\n        }\n    }\n}\n\nfunction sendInputs(inputs) {\n    let bundle = {\n        packets: {\n            inputs: inputs, \n        },\n        tick: client.tick,\n    }\n\n    const message = avsc.encode(bundle);\n    socket.send(message);\n}\n\nfunction waitForID() {  \n    client.tick = Math.floor(client.getTick());\n\n    processTick(client.tick);\n\n    if(client.id != null) {\n        gameLoop();\n        return;\n    }\n\n    window.requestAnimationFrame(waitForID);\n}\n\nfunction gameLoop() {\n    const dt = .016;\n    const curTick = Math.floor(client.getTick());\n    const alpha = client.getTick() - curTick;\n    \n    if(curTick - client.tick > 128)\n        client.tick = curTick - 128;\n\n    client.updateViewID();\n\n    while(client.tick < curTick) {\n        handleInputs();\n        \n        if(!client.isSpectator)\n            client.state.cars[client.id].inputs = client.inputs;\n        \n        util.setBuffer(client.stateBuffer, client.tick, client.copyDynamicState(client.state));\n        \n        client.update(dt);\n\n        client.tick++;\n    }\n\n    let rewind = processTick(client.tick);\n\n    if(rewind < client.tick) {\n        // console.log(client.tick - rewind)\n        const rewindBuffer = client.copyDynamicState(client.state);\n\n        while(rewind < client.tick) {\n            const stateBuffer = util.getBuffer(client.stateBuffer, rewind);\n            client.state.cars[client.id].inputs = stateBuffer.cars[client.id].inputs;\n            \n            util.setBuffer(client.stateBuffer, rewind, client.copyDynamicState(client.state));\n\n            client.update(dt);\n\n            rewind++;\n        }\n\n        for(const idx of Object.keys(client.state.cars))\n            if(idx != client.id)\n                client.updateCar(client.state.cars[idx], rewindBuffer.cars[idx]);\n    }\n\n    let lerp = client.lerpState(alpha);\n\n    if(client.state.scene == \"race\")\n        camera.update(lerp.cars[client.viewID], dt);\n\n    camera.draw(lerp, client);\n    camera.drawPing(Math.floor(client.latency * 100)/100);\n\n    window.requestAnimationFrame(gameLoop);\n}\n\ndocument.addEventListener(\"keydown\", (e) => {\n    switch(e.code) {\n        case 'KeyW':\n        case 'ArrowUp':\n            client.inputs.up = true;\n            break;\n        case 'KeyA':\n        case 'ArrowLeft':\n            client.inputs.left = true;\n            break;\n        case 'KeyS':\n        case 'ArrowDown':\n            client.inputs.down = true;\n            break;\n        case 'KeyD':\n        case 'ArrowRight':\n            client.inputs.right = true;\n            break;\n        case 'ShiftLeft':\n            client.inputs.shift = true;\n            break;\n        case \"Enter\":\n            client.inputs.enter = true;\n            break;\n        default:\n    }\n});\n\ndocument.addEventListener(\"keyup\", (e) => {\n    switch(e.code) {\n        case 'KeyW':\n        case 'ArrowUp':\n            client.inputs.up = false;\n            break;\n        case 'KeyA':\n        case 'ArrowLeft':\n            client.inputs.left = false;\n            break;\n        case 'KeyS':\n        case 'ArrowDown':\n            client.inputs.down = false;\n            break;\n        case 'KeyD':\n        case 'ArrowRight':\n            client.inputs.right = false;\n            break;\n        case 'ShiftLeft':\n            client.inputs.shift = false;\n            break;\n        case 'Enter':\n            client.inputs.enter = false;\n            break;\n        default:\n    }\n});\n\n//# sourceURL=webpack://js-kart/./src/client/index.js?");

/***/ }),

/***/ "./src/shared_modules/camera.js":
/*!**************************************!*\
  !*** ./src/shared_modules/camera.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let util = __webpack_require__(/*! ./util */ \"./src/shared_modules/util.js\");\nlet PhysX = __webpack_require__(/*! ./physx */ \"./src/shared_modules/physx.js\");\nlet Vec2D = PhysX.Vec2D;\n\nfunction num_to_place(num) {\n    switch(num) {\n        case 1:\n            return \"1st\";\n        case 2:\n            return \"2nd\";\n        case 3:\n            return \"3rd\";\n        default:\n            return num+\"th\";\n    }\n}\n\nclass Camera {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext(\"2d\");\n        this.angle = 0;\n        this.x = 0;\n        this.y = 0;\n        this.scale = 1;\n\n        this.offset = 0;\n\n        this.target = {\n            angle: 0,\n            x: 0,\n            y: 0,\n            scale: 1,\n        };\n\n        this.ctx.lineCap = \"round\";\n        this.ctx.translate(canvas.width * .5, this.canvas.height * .5);\n    }\n\n    update(car, dt) {\n        const followFactor = 8 * dt;\n\n        this.target.angle = car.angle + car.rotVel / 6;\n        this.target.x = car.pos.x + car.vel.x / 6;\n        this.target.y = car.pos.y + car.vel.y / 6;\n        this.target.scale = 1 / (1.7 + Vec2D.mag(car.vel) / 2400);\n    \n        this.angle += (this.target.angle - this.angle) * followFactor;\n        this.x += (this.target.x - this.x) * followFactor;\n        this.y += (this.target.y - this.y) * followFactor;\n        this.scale += (this.target.scale - this.scale) * followFactor * .2;\n    }\n\n    drawError(error) {\n        this.ctx.globalCompositeOperation = \"source-over\";\n        this.ctx.fillStyle = \"#121212\";\n        \n        this.ctx.fillRect(-this.canvas.width * .5, -this.canvas.height * .5, this.canvas.width, this.canvas.height);\n\n        this.ctx.globalCompositeOperation = \"lighter\";\n        this.ctx.shadowBlur = 4;\n\n        this.ctx.fillStyle = `hsl(0, 30%, 60%)`;\n        this.ctx.shadowColor = `hsl(0, 30%, 50%)`;\n        this.ctx.font = \"bold 24px Share Tech Mono\";\n        this.ctx.textAlign = \"center\";\n        this.ctx.textBaseline = \"middle\";\n\n        this.ctx.fillText('Could not connect to:', 0, -20);\n        this.ctx.fillText(error.target.url, 0, 20);\n    }\n\n    drawLoading() {\n        this.ctx.globalCompositeOperation = \"source-over\";\n        this.ctx.fillStyle = \"#121212\";\n        \n        this.ctx.fillRect(-this.canvas.width * .5, -this.canvas.height * .5, this.canvas.width, this.canvas.height);\n\n        this.ctx.globalCompositeOperation = \"lighter\";\n        this.ctx.shadowBlur = 4;\n\n        this.ctx.fillStyle = `hsl(0, 30%, 60%)`;\n        this.ctx.shadowColor = `hsl(0, 30%, 50%)`;\n        this.ctx.font = \"bold 24px Share Tech Mono\";\n        this.ctx.textAlign = \"center\";\n        this.ctx.textBaseline = \"middle\";\n\n        this.ctx.fillText('Connecting...', 0, 0);\n    }\n\n    drawWalls(walls) {\n        let hue = 0;\n        this.ctx.lineWidth = 6;\n        this.ctx.shadowBlur = 4;\n\n        for(const wall of walls)  {\n            this.ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;\n            this.ctx.strokeStyle = `hsl(${hue}, 50%, 85%)`;\n\n            this.ctx.beginPath();\n            this.ctx.moveTo(wall.points[1].x, wall.points[1].y);\n            this.ctx.lineTo(wall.points[2].x, wall.points[2].y);\n\n            this.ctx.moveTo(wall.points[0].x, wall.points[0].y);\n            this.ctx.lineTo(wall.points[3].x, wall.points[3].y);\n            \n            this.ctx.closePath();\n            this.ctx.stroke();\n\n            hue += 360 / walls.length;\n        }\n    }\n\n    drawStartLine(walls) {\n        this.ctx.strokeStyle = `hsl(0, 0%, 15%)`;\n        this.ctx.shadowColor = `hsl(0, 0%, 15%)`;\n\n        this.offset++;\n        this.ctx.lineDashOffset = this.offset;\n        this.ctx.lineCap = \"butt\";\n\n        const size = 30;\n        this.ctx.lineWidth = size;\n        this.ctx.setLineDash([size, size]);\n        const len = walls[0].length - 1;\n        \n        const p1 = walls[1][len].points[1];\n        const p2 = walls[0][len].points[0];\n\n        const slope = Vec2D.normalize({\n                        x: p1.x - p2.x,\n                        y: p1.y - p2.y,\n                    });\n\n        const perp = new Vec2D(-slope.y, slope.x);\n        const offset = perp.mult(size);\n\n        this.ctx.beginPath();\n        this.ctx.moveTo(p1.x, p1.y);\n        this.ctx.lineTo(p2.x, p2.y);\n        this.ctx.stroke();\n\n        this.ctx.lineDashOffset = this.offset + size;\n\n        this.ctx.beginPath();\n        this.ctx.moveTo(p1.x + offset.x, p1.y + offset.y);\n        this.ctx.lineTo(p2.x + offset.x, p2.y + offset.y);\n        this.ctx.stroke();\n\n        this.ctx.setLineDash([]);\n        this.ctx.lineCap = \"round\";\n    }\n    \n    drawObject(obj, color, lineWidth = 2) {\n        this.ctx.strokeStyle = color;\n        this.ctx.lineWidth = lineWidth;\n\n        this.ctx.beginPath();\n        for(const point of obj.points) {\n            this.ctx.lineTo(point.x, point.y);\n        }\n        this.ctx.closePath();\n        this.ctx.stroke();\n    }\n\n    drawPlaces(state) {\n        for(const car of Object.values(state.cars)) {\n            if(car.lap == -1)\n                continue;\n\n            this.ctx.fillStyle = `hsl(${car.hue}, 100%, 80%)`;\n            this.ctx.textAlign = \"center\";\n            this.ctx.textBaseline = \"middle\";\n            this.ctx.font = \"bold 24px Share Tech Mono\";\n            this.ctx.shadowBlur = 0;\n\n            this.ctx.fillText(num_to_place(car.lap), car.pos.x, car.pos.y - 30);\n        }\n    }\n\n    drawCenteredMessage(message, hue = 0) {\n        this.ctx.fillStyle = `hsl(${hue}, 100%, 80%)`;\n        this.ctx.font = \"bold 24px Share Tech Mono\";\n        this.ctx.textAlign = \"center\";\n        this.ctx.textBaseline = \"middle\";\n        this.ctx.shadowBlur = 0;\n\n        this.ctx.fillText(message, 0, this.canvas.height * -.4);\n    }\n\n    drawLap(car) {\n        this.ctx.fillStyle = `hsl(0, 0%, 50%)`;\n        this.ctx.font = \"bold 30px Share Tech Mono\";\n        this.ctx.textAlign = \"right\";\n        this.ctx.textBaseline = \"bottom\";\n        this.ctx.shadowBlur = 0;\n\n        const text = \"LAP: \"+ car.lap + \"/\" + util.NUM_LAPS;\n        this.ctx.fillText(text, this.canvas.width / 2 - 10, this.canvas.height / 2 - 10);\n    }\n\n    drawSpectatorMessage(id) {\n        this.ctx.fillStyle = `hsl(0, 0%, 50%)`;\n        this.ctx.font = \"bold 30px Share Tech Mono\";\n        this.ctx.textAlign = \"left\";\n        this.ctx.textBaseline = \"top\";\n        this.ctx.shadowBlur = 0;\n\n        const text = `SPECTATING: CAR ${parseInt(id) + 1}`;\n        this.ctx.fillText(text, -this.canvas.width / 2 + 10, -this.canvas.height / 2 + 10);\n    }\n\n    drawPing(ping) {\n        this.ctx.fillStyle = `hsl(0, 0%, 50%)`;\n        this.ctx.font = \"bold 15px Share Tech Mono\";\n        this.ctx.textAlign = \"left\";\n        this.ctx.textBaseline = \"bottom\";\n        this.ctx.shadowBlur = 0;\n\n        const text = `PING: ` + ping;\n        this.ctx.fillText(text, -this.canvas.width / 2 + 10, this.canvas.height / 2 - 10);\n    }\n\n    drawLobby(state, client) {\n        const {id, isSpectator} = client;\n\n        const car = state.cars[id];\n\n        for(const wall of state.walls)\n            this.drawWalls(wall);\n\n        this.drawPlaces(state)\n\n        for(const car of Object.values(state.cars)) {\n            const rd = car.ready ? 1 : .3;\n            this.ctx.shadowColor = `hsl(${car.hue}, ${100 * rd}%, ${50 * rd}%)`;\n            const color = `hsl(${car.hue}, ${100 * rd}%, ${85 * rd}%)`;\n            this.ctx.shadowBlur = 4;\n            this.drawObject(car, color, 4);\n        }\n\n        if(!isSpectator && !car.ready) {\n            this.drawCenteredMessage(\"PRESS [ENTER] TO READY\", car.hue);\n        }\n\n        if(isSpectator) {\n            this.drawCenteredMessage(\"SPECTATING\");\n        }\n    }\n\n    drawCountDown(freezeTime) {\n        const x = 1 - (freezeTime % 1);\n        const lerp = 0.6031746 + 3.358466*x - 9.236111*x*x + 10.87963*x*x*x - 5.208333*x*x*x*x;\n\n        this.ctx.strokeStyle = `hsl(0, 0%, 70%)`;\n        this.ctx.font = `bold ${lerp * 200}px Share Tech Mono`;\n        this.ctx.textAlign = \"center\";\n        this.ctx.textBaseline = \"middle\";\n        this.ctx.lineWidth = 1;\n\n        let count = Math.floor(freezeTime);\n\n        if(count == 0)\n            count = \"GO!\";\n\n        if(count > 3)\n            count = \"\";\n\n        this.ctx.globalAlpha = lerp;\n        this.ctx.strokeText(count, 0, -this.canvas.height / 6);\n        this.ctx.globalAlpha = 1;\n    }\n\n    drawRace(state, client) {\n        const {id, isSpectator, freezeTime} = client;\n\n        this.ctx.translate(0, this.canvas.height * .17);\n        this.ctx.scale(this.scale, this.scale);\n        this.ctx.rotate(-this.angle - Math.PI/2);\n        this.ctx.translate(-this.x, -this.y);\n\n        this.drawStartLine(state.walls);\n        \n        for(const wall of state.walls)\n            this.drawWalls(wall);\n\n        for(const car of Object.values(state.cars)) {\n            this.ctx.shadowColor = `hsl(${car.hue}, 100%, 50%)`;\n            const color = `hsl(${car.hue}, 100%, 85%)`;\n            this.drawObject(car, color, 4);\n        }\n\n        this.ctx.translate(this.x, this.y);\n        this.ctx.rotate(this.angle + Math.PI/2);\n        this.ctx.scale(1/this.scale, 1/this.scale);\n        this.ctx.translate(0, -this.canvas.height * .17);\n\n        const car = state.cars[id];\n\n        this.drawLap(car);\n        \n        if(isSpectator) {\n            this.drawSpectatorMessage(id);\n        }\n\n        if(freezeTime > 0) {\n            this.drawCountDown(freezeTime);\n        }\n    }\n\n    draw(state, client) {\n        this.ctx.globalCompositeOperation = \"source-over\";\n        this.ctx.fillStyle = \"#121212\";\n        \n        this.ctx.fillRect(-this.canvas.width * .5, -this.canvas.height * .5, this.canvas.width, this.canvas.height);\n\n        this.ctx.globalCompositeOperation = \"lighter\";\n\n        if(state.scene == \"lobby\") {\n            this.drawLobby(state, client);\n        } else {\n            this.drawRace(state, client);\n        }\n    }\n}\n\nmodule.exports = Camera;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/camera.js?");

/***/ }),

/***/ "./src/shared_modules/car.js":
/*!***********************************!*\
  !*** ./src/shared_modules/car.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PhysX = __webpack_require__(/*! ./physx */ \"./src/shared_modules/physx.js\");\nconst Vec2D = PhysX.Vec2D;\nconst PhysObject = PhysX.PhysObject;\n\nclass Car extends PhysObject {\n    static POINTS = [new Vec2D(0, 1),\n        new Vec2D(0, 19),\n        new Vec2D(12, 22),\n        new Vec2D(40, 19),\n        new Vec2D(40, 1),\n        new Vec2D(12, -2),];\n\n    constructor(pos, hue, material = null) {\n\n        if(!material) {\n            material = {\n                density: 2.5,\n                restitution: .35,\n                sFriction: .06,\n                dFriction: .04,\n            };\n        }\n\n        super(pos, Car.POINTS, material);\n        this.moi *= 10;\n\n        this.inputs = {\n            left: false,\n            right: false,\n            up: false,\n            down: false,\n            shift: false,\n            enter: false,\n        }\n\n        this.ready = false;\n        this.hue = hue;\n        this.lap = -1;\n        this.lastCheckpoint = 0;\n    }\n\n    controlPlayer(dt) {\n        const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);\n        const maxSpeed = 1000;\n        const isDrifting = false;\n\n        const accFactor = 600 * dt;\n        const maxRotFactor = 2.5;\n        const maxRot = maxRotFactor * Math.min(speed / 100, 1)\n        const rotFactor = 14 * dt;\n        const driftFactor = isDrifting ? .96 : .8;\n        \n        const dx = Math.cos(this.angle);\n        const dy = Math.sin(this.angle);\n\n        const dir = new Vec2D(dx, dy);\n        const orth = new Vec2D(-dy, dx);\n\n        const fwdSpeed = dir.dot(this.vel);\n        const fwdVel = dir.mult(fwdSpeed);\n\n        const orthSpeed = orth.dot(this.vel);\n        const orthVel = orth.mult(orthSpeed * driftFactor);\n\n        this.vel = fwdVel.addRet(orthVel);\n\n        if(this.inputs.up && !this.inputs.down && fwdSpeed < maxSpeed) {\n            const dx = Math.cos(this.angle) * accFactor;\n            const dy = Math.sin(this.angle) * accFactor;\n    \n            this.vel.add(new Vec2D(dx, dy));\n        } else if(this.inputs.down && !this.inputs.up && fwdSpeed > -maxSpeed / 2) {\n            const dx = Math.cos(this.angle) * accFactor;\n            const dy = Math.sin(this.angle) * accFactor;\n    \n            this.vel.sub(new Vec2D(dx, dy));\n        } else {\n            this.vel.x *= isDrifting ? .999 : .99;\n            this.vel.y *= isDrifting ? .999 : .99;\n        }\n    \n        const turningLeft = this.inputs.left && !this.inputs.right; \n        const turningRight = !this.inputs.left && this.inputs.right;\n\n        if((turningLeft && fwdSpeed > 0) || (turningRight && fwdSpeed < 0)) {\n            if(this.rotVel > 0) this.rotVel = 0;\n            if(this.rotVel < -maxRot) this.rotVel = -maxRot;\n\n            this.rotVel -= rotFactor;\n        } else if((turningRight && fwdSpeed > 0) || (turningLeft && fwdSpeed < 0)) {\n            if(this.rotVel < 0) this.rotVel = 0;\n            if(this.rotVel > maxRot) this.rotVel = maxRot;\n\n            this.rotVel += rotFactor;\n        } else {\n            this.rotVel *= .92;\n        }\n    }\n}\n\nmodule.exports = Car;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/car.js?");

/***/ }),

/***/ "./src/shared_modules/physx.js":
/*!*************************************!*\
  !*** ./src/shared_modules/physx.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("function clip(v1, v2, n, o) {\n    let points = [];\n    const d1 = n.dot(v1) - o;\n    const d2 = n.dot(v2) - o;\n\n    if(d1 >= 0) points.push(v1);\n\n    if(d2 >= 0) points.push(v2);\n\n    if(d1 * d2 < 0) {\n        let e = Vec2D.dif(v1, v2);\n        const u = d1 / (d1 - d2);\n        e = e.mult(u);\n        e.add(v1);\n\n        points.push(e);\n    }\n\n    return points;\n}\n\nfunction debugLine(p1, p2, ctx, color = \"red\") {\n    ctx.strokeStyle = color;\n    ctx.beginPath()\n    ctx.moveTo(p1.x, p1.y);\n    ctx.lineTo(p2.x, p2.y);\n    ctx.stroke();\n}\n\nfunction insertionSort(arr, lambda = (x) => x) {\n    let val, j, i;\n    for(i = 1; i < arr.length; i++) {\n        val = arr[i];\n        j = i - 1;\n\n        while(j >= 0 && lambda(arr[j]) > lambda(val)) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = val;\n    }\n}\n\nfunction polygonSupport(points, d) {\n    let furthest = null;\n    let dot = -Infinity;\n\n    for(const point of points) {\n        const proj = point.dot(d);\n        if(proj > dot) {\n            furthest = point;\n            dot = proj;\n        }\n    }\n\n    return furthest;\n}\n\nfunction minkowskiDifSupport(s1, s2, d) {\n    return Vec2D.dif(polygonSupport(s2.points, d.mult(-1)), polygonSupport(s1.points, d));\n}\n\nfunction mean(arr) {\n    let sum = 0;\n    for(const el of arr) {\n        sum += el;\n    }\n    return sum / arr.length;\n}\n\nfunction variance(arr) {\n    let variance = 0;\n    const mean = mean(arr);\n    for(const el of arr) {\n        const dif = el - mean;\n        variance += dif * dif;\n    }\n    return variance / arr.length;\n}\n\nfunction calculateMassAndMoi(obj) {\n    if(obj.material.density == Infinity)\n        return [Infinity, Infinity];\n\n    let mass = 0;\n    // let center = new Vec2D(0, 0);\n    let moi = 0;\n\n    let prev = obj.shape.length - 1;\n    for(let cur = 0; cur < obj.shape.length; cur++) {\n        const a = obj.shape[prev];\n        const b = obj.shape[cur];\n\n        const areaStep = Math.abs(Vec2D.cross(a, b) / 2);\n        const massStep = areaStep * obj.material.density;\n        // const centerStep = a.addRet(b).div(3);\n        const moiStep = massStep / 6 * (a.dot(a) + b.dot(b) + a.dot(b));\n\n        mass += massStep\n        // center.add(centerStep);\n        moi += moiStep;\n    }\n\n    return [mass, moi];\n}\n\nconst wood = {\n    density: 1,\n    restitution: .45,\n    sFriction: .3,\n    dFriction: .2,\n};\n\nconst rubber = {\n    density: 2.5,\n    restitution: .95,\n    sFriction: .6,\n    dFriction: .4,\n};\n\nconst wall = {\n    density: Infinity,\n    restitution: .5,\n    sFriction: .24,\n    dFriction: .16,\n};\n\nclass Vec2D {\n    static rotate(pivot, point, rad) {\n        const dx = (point.x - pivot.x);\n        const dy = (point.y - pivot.y);\n\n        const sin = Math.sin(rad);\n        const cos = Math.cos(rad);\n\n        const nx = dx * cos - dy * sin; \n        const ny = dx * sin + dy * cos;\n\n        return new Vec2D(nx, ny);\n    }\n\n    static mag(vec) {\n        return Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n    }\n    \n    static distance(v1, v2) {\n        return Vec2D.mag(Vec2D.dif(v1, v2));\n    }\n\n    static normalize(vec) {\n        if(vec.x == 0 && vec.y == 0) return new Vec2D(0, 0);\n        const mag = Vec2D.mag(vec);\n        return new Vec2D(vec.x / mag, vec.y / mag);\n    }\n\n    static dif(v1, v2) {\n        return new Vec2D(v2.x - v1.x, v2.y - v1.y);\n    }\n\n    static tripleProd(v1, v2, v3) {\n        const k = v1.x * v2.y - v1.y * v2.x;\n        const nx = -v3.y * k;\n        const ny = v3.x * k;\n        return new Vec2D(nx, ny, 0);\n    }\n\n    static cross(A, B) {\n        if(A.x == undefined) {\n            // scalar x vector\n            return new Vec2D(-A * B.y, A * B.x);\n        } else if(B.x == undefined) {\n            // vector x scalar\n            return new Vec2D(B * A.y, -B * A.x);\n        } else {\n            // vector x vector\n            return A.x * B.y - A.y * B.x;\n        }\n    }\n\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    add(other) {\n        this.x += other.x;\n        this.y += other.y;\n    }\n\n    sub(other) {\n        this.x -= other.x;\n        this.y -= other.y;\n    }\n\n    scale(num) {\n        this.x *= num;\n        this.y *= num;\n    }\n    \n    addRet(other) {\n        return new Vec2D(this.x + other.x, this.y + other.y);\n    }\n\n    subRet(other) {\n        return new Vec2D(this.x - other.x, this.y - other.y);\n    }\n\n    mult(num) {\n        return new Vec2D(this.x * num, this.y * num);\n    }\n\n    div(num) {\n        return new Vec2D(this.x / num, this.y / num);\n    }\n\n    dot(other) {\n        return this.x * other.x + this.y * other.y;\n    }\n}\n\nclass AABB {\n\n    static findAABB(obj) {\n        let b = new Vec2D(Infinity, Infinity);\n        let e = new Vec2D(-Infinity, -Infinity);\n\n        for(const point of obj.points) {\n            b.x = Math.min(point.x, b.x);\n            b.y = Math.min(point.y, b.y);\n\n            e.x = Math.max(point.x, e.x);\n            e.y = Math.max(point.y, e.y);\n        }\n\n        return new AABB(b, e);\n    }\n\n    constructor(b, e) {\n        this.b = b;\n        this.e = e;\n    }\n\n    update(obj) {\n        this.b.add(new Vec2D(Infinity, Infinity));\n        this.e.add(new Vec2D(-Infinity, -Infinity));\n\n        for(const point of obj.points) {\n            this.b.x = Math.min(point.x, this.b.x);\n            this.b.y = Math.min(point.y, this.b.y);\n\n            this.e.x = Math.max(point.x, this.e.x);\n            this.e.y = Math.max(point.y, this.e.y);\n        }\n    }\n\n    draw(ctx) {\n        ctx.strokeStyle = this.color;\n        ctx.strokeRect(this.b.x, this.b.y, this.e.x - this.b.x, this.e.y - this.b.y);\n    }\n}\n\nclass PhysObject {\n\n    static findCOM(points) {\n        let COM = new Vec2D(0, 0);\n        \n        for(const point of points) {\n            COM.add(point);\n        }\n\n        COM.x /= points.length;\n        COM.y /= points.length;\n\n        return COM;\n    }\n\n    constructor(pos, points, material = wood) {\n        this.force = new Vec2D(0, 0);\n        this.acc = new Vec2D(0, 0);\n        this.vel = new Vec2D(0, 0);\n        this.pos = pos;\n\n        this.torque = 0;\n        this.rotAcc = 0;\n        this.rotVel = 0;\n        this.angle = 0;\n\n        this.masks = [];\n\n        const center = PhysObject.findCOM(points);\n        points.forEach((p) => p.sub(center));\n        this.shape = points;\n        this.points = [];\n        for(let i = 0; i < points.length; i++) {\n            this.points[i] = Vec2D.rotate(new Vec2D(0, 0), this.shape[i], this.angle);\n            this.points[i].add(this.pos);\n        }\n\n        this.material = material;\n        const [mass, moi] = calculateMassAndMoi(this);\n\n        this.mass = mass;\n        this.moi = moi;\n        \n        this.AABB = AABB.findAABB(this);\n        this.func = null;\n    }\n\n    // a force consists of a position vector and a direction vector\n    applyForce(force) {\n        const r = new Vec2D(force.pos.x - this.pos.x, force.pos.y - this.pos.y);\n\n        this.force.add(force.dir);\n        this.torque += r.x * force.dir.y - r.y * force.dir.x;\n    }\n\n    stepForces(dt) {\n        this.acc = this.force.div(this.mass);\n        \n        if(this.mass == 0)\n            this.acc = new Vec2D(0, 0);\n        \n        this.vel.add(this.acc.mult(dt));\n        \n        this.pos.add(this.vel.mult(dt));\n        \n        this.rotAcc = this.torque / this.moi;\n\n        if(this.moi == 0)\n            this.rotAcc = 0;\n        \n        this.rotVel += this.rotAcc * dt;\n\n        this.angle += this.rotVel * dt;\n\n        this.force = new Vec2D(0, 0);\n        this.torque = 0;\n    }\n\n    update() {\n        for(let i = 0; i < this.points.length; i++) {\n            this.points[i] = Vec2D.rotate(new Vec2D(0, 0), this.shape[i], this.angle);\n            this.points[i].add(this.pos);\n        }\n\n        this.AABB.update(this);\n    }\n\n    draw(ctx) {\n        ctx.strokeStyle = \"white\";\n        ctx.lineWidth = 1.5;\n\n        ctx.beginPath();\n        for(const point of this.points) {\n            ctx.lineTo(point.x, point.y);\n        }\n        ctx.closePath();\n\n        ctx.stroke();\n    }\n}\n\nclass PhysEnv {\n    constructor(iterations = 1) {\n        this.objects = [];\n        this.intervals = [];\n        this.sweepX = true;\n\n        this.iterations = iterations;\n    }\n\n    addObject(obj) {\n        let start = [obj.AABB.b, this.objects.length];\n        let end = [obj.AABB.e, this.objects.length];\n        \n        this.intervals.push(start, end);\n        this.objects.push(obj);\n    }\n\n    removeObject(obj) {\n        let idx = -1;\n        \n        for(let i = 0; i < this.objects.length; i++) {\n            if(obj == this.objects[i]) {\n                idx = i;\n                this.objects.splice(i, 1);\n                break;\n            }\n        }\n\n        for(let i = this.intervals.length - 1; i >= 0; i--) {\n            if(idx == this.intervals[i][1]) {\n                this.intervals.splice(i, 1);\n            } else if(this.intervals[i][1] > idx) {\n                this.intervals[i][1]--;\n            }\n        }\n    }\n\n    clearObjects() {\n        this.objects = [];\n        this.intervals = [];\n    }\n\n    sweepAndPrune() {\n        let overlaps = [];\n        let activeObjects = {};\n\n        if(this.sweepX) {\n            insertionSort(this.intervals, (x) => x[0].x);\n        } else {\n            insertionSort(this.intervals, (x) => x[0].y);\n        }\n\n        for(let i = this.intervals.length - 1; i >= 0; i--) {\n            const node = this.intervals[i];\n            if(activeObjects[node[1]] != null) {\n                delete activeObjects[node[1]];\n            } else {\n                for(const key in activeObjects) {\n                    if((this.objects[node[1]].mass == Infinity &&\n                        this.objects[activeObjects[key]].mass == Infinity) || \n                       (this.objects[node[1]].mass == 0 &&\n                        this.objects[activeObjects[key]].mass == 0))\n                        continue;\n                    overlaps.push([this.objects[node[1]], this.objects[activeObjects[key]]]);\n                }\n\n                activeObjects[node[1]] = node[1];\n            }\n        }\n\n        // for(const node of this.intervals) {\n        //     if(activeObjects[node[1]] != null) {\n        //         delete activeObjects[node[1]];\n        //     } else {\n        //         for(const key in activeObjects) {\n        //             overlaps.push([this.objects[node[1]], this.objects[activeObjects[key]]]);\n        //         }\n\n        //         activeObjects[node[1]] = node[1];\n        //     }\n        // }\n\n        return overlaps;\n    }\n\n    update(dt) {\n        this.stepForces(dt);\n        for(let i = 0; i < this.iterations; i++) {\n            this.detectCollisions();\n        }\n    }\n\n    stepForces(dt) {\n        for(const obj of this.objects) {\n            obj.stepForces(dt);\n            obj.update();\n        }\n    }\n\n    detectCollisions() {\n        let simplex = [];\n        let possibleCollisions = this.sweepAndPrune();\n        for(let [s1, s2] of possibleCollisions) {\n            if((simplex = this.GJK(s1, s2))) {\n                if(s1.func) s1.func(s1, s2);\n                if(s2.func) s2.func(s2, s1);\n                \n                if(s1.mass == 0 || s2.mass == 0)\n                    continue;\n\n                let masked = false;\n\n                for(let i = 0; i < s1.masks.length; i++) {\n                    for(let j = 0; j < s2.masks.length; j++) {\n                        if(s1.masks[i] == s2.masks[j]) {\n                            masked = true;\n                            \n                            i = s1.masks.length;\n                            j = s2.masks.length;\n                        }\n                    }\n                }\n\n                if(masked)\n                    continue;\n\n                let [normal, depth] = this.EPA(s1, s2, simplex);\n                \n                let contacts = this.findContacts(s1, s2, normal);\n\n                if(contacts == null)\n                    continue;\n\n                for(const contact of contacts)\n                    this.applyImpulses(s1, s2, normal, contact);\n\n                this.resolveIntersections(s1, s2, normal, depth);\n\n                s1.update();\n                s2.update();\n            }\n        }\n    }\n\n    resolveIntersections(s1, s2, normal, depth) {\n        const slop = .1;\n        const percent = .85;\n        const correction = Math.max(depth - slop, 0) * percent;\n        const totalMass = s1.mass + s2.mass;\n        if(s1.mass == Infinity && s2.mass == Infinity) {\n            return;\n        } else if(s1.mass == Infinity) {\n            s2.pos.x += normal.x * correction;\n            s2.pos.y += normal.y * correction;\n        } else if(s2.mass == Infinity) {\n            s1.pos.x -= normal.x * correction;\n            s1.pos.y -= normal.y * correction;\n        } else {\n            s1.pos.x -= normal.x * correction * s2.mass / totalMass;\n            s1.pos.y -= normal.y * correction * s2.mass / totalMass;\n            \n            s2.pos.x += normal.x * correction * s1.mass / totalMass;\n            s2.pos.y += normal.y * correction * s1.mass / totalMass;\n        }\n    }\n\n    applyImpulses(s1, s2, normal, contact) {\n        const r1 = Vec2D.dif(s1.pos, contact);\n        const v1 = s1.vel.addRet(Vec2D.cross(s1.rotVel, r1));\n\n        const r2 = Vec2D.dif(s2.pos, contact);\n        const v2 = s2.vel.addRet(Vec2D.cross(s2.rotVel, r2));\n\n        const abVel = Vec2D.dif(v1, v2);\n        const contactVel = abVel.dot(normal);\n\n        if(contactVel >= 0)\n            return;\n\n        const armA = Vec2D.cross(r1, normal);\n        const armB = Vec2D.cross(r2, normal);\n\n        const rest = Math.min(s1.material.restitution, s2.material.restitution);\n\n        const m = 1 / s1.mass + 1 / s2.mass + armA * armA / s1.moi + armB * armB / s2.moi; \n        const j = (-(rest + 1) * contactVel) / m;\n        const impulse = normal.mult(j);\n\n        s1.vel.sub(impulse.div(s1.mass));\n        s2.vel.add(impulse.div(s2.mass));\n        \n        const r1CrossI = Vec2D.cross(r1, impulse);\n        const r2CrossI = Vec2D.cross(r2, impulse);\n\n        s1.rotVel -= r1CrossI / s1.moi;\n        s2.rotVel += r2CrossI / s2.moi;\n\n        const tangent = Vec2D.normalize(abVel.subRet(normal.mult(contactVel)));\n        const jt = -abVel.dot(tangent) / m;\n\n        const mu = Math.sqrt(s1.material.sFriction * s1.material.sFriction + s2.material.sFriction * s2.material.sFriction);\n\n        if(Math.abs(jt) < j * mu) {\n            var impulset = tangent.mult(jt);\n        } else {\n            const dFriction = Math.sqrt(s1.material.dFriction * s1.material.dFriction + s2.material.dFriction * s2.material.dFriction);\n            var impulset = tangent.mult(-j * dFriction);\n        }\n\n        if(!isFinite(impulset.x) || !isFinite(impulset.y))\n            return;\n\n        s1.vel.sub(impulset.div(s1.mass));\n        s2.vel.add(impulset.div(s2.mass));\n\n        const r1CrossIt = Vec2D.cross(r1, impulset);\n        const r2CrossIt = Vec2D.cross(r2, impulset);\n\n        s1.rotVel -= r1CrossIt / s1.moi;\n        s2.rotVel += r2CrossIt / s2.moi;\n    }\n\n    findContacts(s1, s2, normal) {\n        const [p1, e1] = this.findCollisionEdge(s1, normal);\n        const [p2, e2] = this.findCollisionEdge(s2, normal.mult(-1));\n\n        const e1Dif = Vec2D.dif(e1[1], e1[0]);\n        const e2Dif = Vec2D.dif(e2[1], e2[0]);\n\n        let ref, pRef, eRef, inc, pInc, eInc;\n        if(Math.abs(e1Dif.dot(normal)) <= Math.abs(e2Dif.dot(normal))) {\n            pRef = p1;\n            eRef = e1;\n            ref = e1Dif;\n\n            pInc = p2;\n            eInc = e2;\n            inc = e2Dif;\n        } else {\n            pRef = p2;\n            eRef = e2;\n            ref = e2Dif;\n\n            pInc = p1;\n            eInc = e1;\n            inc = e1Dif;\n        }\n\n        const refV = Vec2D.normalize(ref).mult(-1);\n        const o1 = refV.dot(eRef[0]);\n\n        let cp = clip(eInc[0], eInc[1], refV, o1);\n\n        if(cp.length < 2) return;\n\n        const o2 = refV.dot(eRef[1]);\n        \n        cp = clip(cp[0], cp[1], refV.mult(-1), -o2);\n        \n        if(cp.length < 2) return;\n\n        let refNorm = Vec2D.cross(ref, -1);\n        \n        const max = refNorm.dot(pRef);\n\n        if(refNorm.dot(cp[1]) - max < 0)\n            cp.splice(1, 1);\n\n        if(refNorm.dot(cp[0]) - max < 0)\n            cp.splice(0, 1);\n    \n        return cp;\n    }\n\n    findCollisionEdge(s, normal) {\n        let v = null;\n        let idx = null;\n        let dot = -Infinity;\n    \n        for(const [i, point] of s.points.entries()) {\n            const proj = point.dot(normal);\n            if(proj > dot) {\n                v = point;\n                idx = i;\n                dot = proj;\n            }\n        }\n    \n        const v0 = s.points[(idx - 1 + s.points.length) % s.points.length];\n        const v1 = s.points[(idx + 1) % s.points.length];\n\n        const leftEdge = Vec2D.dif(v, v0);\n        const rightEdge = Vec2D.dif(v, v1);\n\n        if(Vec2D.normalize(rightEdge).dot(normal) <= Vec2D.normalize(leftEdge).dot(normal)) {\n            return [v, [v0, v], leftEdge];\n        } else {\n            return [v, [v, v1], rightEdge];\n        }\n    }\n\n    GJK(s1, s2) {\n        let d = Vec2D.normalize(Vec2D.dif(s1.pos, s2.pos));\n        let simplex = [minkowskiDifSupport(s1, s2, d)];\n        d = Vec2D.dif(simplex[0], new Vec2D(0, 0));\n\n        while(true) {\n            d = Vec2D.normalize(d);\n            const A = minkowskiDifSupport(s1, s2, d);\n            if(A.dot(d) < 0)\n                return false;\n            simplex.push(A);\n            if(this.handleSimplex(simplex, d))\n                return simplex;\n        }\n    }\n\n    handleSimplex(simplex, d) {\n        if(simplex.length == 2)\n            return this.lineCase(simplex, d);\n        return this.triangleCase(simplex, d);\n    }\n\n    lineCase(simplex, d) {\n        let [B, A] = simplex;\n        let AB = Vec2D.dif(A, B);\n        let AO = Vec2D.dif(A, new Vec2D(0, 0));\n        let ABperp = Vec2D.tripleProd(AB, AO, AB);\n        d.x = ABperp.x;\n        d.y = ABperp.y;\n        return false;\n    }\n\n    triangleCase(simplex, d) {\n        let [C, B, A] = simplex;\n\n        let AB = Vec2D.dif(A, B);\n        let AC = Vec2D.dif(A, C);\n        let AO = Vec2D.dif(A, new Vec2D(0, 0));\n\n        let ABperp = Vec2D.tripleProd(AC, AB, AB);\n        let ACperp = Vec2D.tripleProd(AB, AC, AC);\n\n        if(ABperp.dot(AO) > 0) {\n\n            simplex.splice(0, 1);\n\n            d.x = ABperp.x;\n            d.y = ABperp.y;\n\n            return false;\n        } else if(ACperp.dot(AO) > 0) {\n\n            simplex.splice(1, 1);\n\n            d.x = ACperp.x;\n            d.y = ACperp.y;\n\n            return false;\n        }\n        return true;\n    }\n\n    // expanding polytope algorithm\n    EPA(s1, s2, simplex) {\n        while(true) {\n            let [edgeDist, edgeNorm, edgeIDX] = this.findClosestEdge(simplex);\n            let sup = minkowskiDifSupport(s1, s2, edgeNorm);\n\n            const d = sup.dot(edgeNorm);\n            \n            if(d - edgeDist <= 0.01) {\n                return [edgeNorm, edgeDist];\n            } else {\n                simplex.splice(edgeIDX, 0, sup);\n            }\n        }\n    }\n\n    findClosestEdge(simplex) {\n        let dist = Infinity;\n        let normal, idx;\n\n        for(let i = 0; i < simplex.length; i++) {\n            const j = (i + 1) % simplex.length;\n\n            const edge = Vec2D.dif(simplex[i], simplex[j]);\n            const n = Vec2D.normalize(Vec2D.tripleProd(edge, simplex[i], edge));\n\n            const d = n.dot(simplex[i]);\n\n            if(d < dist) {\n                dist = d;\n                normal = n;\n                idx = j;\n            }\n        }\n\n        return [dist, normal, idx];\n    }\n\n    drawObjects(ctx) {\n        for(const obj of this.objects) {\n            obj.draw(ctx);\n        }\n    }\n}\n\nexports.Vec2D = Vec2D;\nexports.PhysEnv = PhysEnv;\nexports.PhysObject = PhysObject;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/physx.js?");

/***/ }),

/***/ "./src/shared_modules/serialize.js":
/*!*****************************************!*\
  !*** ./src/shared_modules/serialize.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nlet avro = __webpack_require__(/*! avsc */ \"./node_modules/avsc/etc/browser/avsc.js\");\nlet util = __webpack_require__(/*! ./util */ \"./src/shared_modules/util.js\");\n\n\nlet car_schema = {\n    name: '_0',\n    default: null,\n    type: [ 'null', {\n        type: 'record',\n        fields: [\n            { name: 'ready', type: 'boolean' },\n            { name: 'lap', type: 'int' },\n            { name: 'hue', type: 'int' },\n            { name: 'angle', type: 'double' },\n            { name: 'rotVel', type: 'double' },\n            { \n                name: 'pos',\n                type: {\n                    type: 'record',\n                    fields: [\n                        { name: 'x', type: 'double' },\n                        { name: 'y', type: 'double' }\n                    ]\n                }\n            },\n            { \n                name: 'vel', \n                type: {\n                    type: 'record',\n                    fields: [\n                        { name: 'x', type: 'double' },\n                        { name: 'y', type: 'double' }\n                    ]\n                }\n            },\n            {\n                name: 'inputs',\n                type: ['null', {\n                    type: 'record',\n                    fields: [\n                        { name: 'left',  type: 'boolean' },\n                        { name: 'right', type: 'boolean' },\n                        { name: 'up',    type: 'boolean' },\n                        { name: 'down',  type: 'boolean' },\n                        { name: 'shift', type: 'boolean' },\n                        { name: 'enter', type: 'boolean' },\n                    ]\n                }]\n            }\n        ]\n    }]\n};\n\ncar_schema_list = [];\n\nfor(let id = 0; id < util.MAX_PLAYERS; id++) {\n    let new_schema = util.copyObj(car_schema);\n    new_schema.name = \"_\" + id;\n\n    car_schema_list.push(new_schema);\n}\n\nconst BUNDLE_TYPE = avro.Type.forSchema({\n    type: 'record',\n    fields: [\n        { name: 'tick', type: 'long' },\n        {\n            name: 'packets', \n            type: {\n                type: 'record',\n                fields: [\n                    { name: 'id', default: null, type: ['null', 'int'] },\n                    {\n                        name: 'dynamic',\n                        default: null,\n                        type: [ 'null', {\n                            type: 'record',\n                            fields: [\n                                { \n                                    name: 'cars', \n                                    type: {\n                                        type: 'record',\n                                        fields: car_schema_list,\n                                    }\n                                }\n                            ]\n                        }]\n                    },\n                    {\n                        name: 'static',\n                        default: null,\n                        type: [ 'null', {\n                            type: 'record',\n                            fields: [\n                                { name: 'scene', type: 'string' },\n                                { \n                                    name: 'walls', \n                                    type: {\n                                        type: 'array',\n                                        items: [\n                                            {\n                                                type: 'array', \n                                                items: [\n                                                    {\n                                                        type: 'record',\n                                                        fields: [\n                                                            {\n                                                                name: 'pos',\n                                                                type: {\n                                                                    type: 'record',\n                                                                    fields: [\n                                                                        { name: 'x', type: 'double' },\n                                                                        { name: 'y', type: 'double' }\n                                                                    ]\n                                                                }\n                                                            },\n                                                            {\n                                                                name: 'points',\n                                                                type: {\n                                                                    type: 'array',\n                                                                    items: [\n                                                                        {\n                                                                            type: 'record',\n                                                                            fields: [\n                                                                                { name: 'x', type: 'double' },\n                                                                                { name: 'y', type: 'double' }\n                                                                            ]\n                                                                        }\n                                                                    ]\n                                                                }\n                                                            }\n                                                        ]\n                                                    }\n                                                ]\n                                            }\n                                        ]\n                                    }\n                                },\n                            ]\n                        }]\n                    },\n                    {\n                        name: 'inputs',\n                        default: null,\n                        type: ['null', {\n                            type: 'record',\n                            fields: [\n                                { name: 'left',  type: 'boolean' },\n                                { name: 'right', type: 'boolean' },\n                                { name: 'up',    type: 'boolean' },\n                                { name: 'down',  type: 'boolean' },\n                                { name: 'shift', type: 'boolean' },\n                                { name: 'enter', type: 'boolean' },\n                            ]\n                        }]\n                    },\n                    { \n                        name: 'ping', \n                        default: null, \n                        type: ['null', {\n                            type: 'record',\n                            fields: [\n                                { name: 'timestamp', type: ['long'] },\n                                { name: 'latency', type: ['double'] },\n                            ]\n                        }]\n                    },\n                ]\n            }\n        },\n    ]\n});\n\nlet encode = (data) => {\n    if(data.packets.dynamic) {\n        var cars = data.packets.dynamic.cars;\n        let temp = {};\n\n        for(const [id, car] of Object.entries(cars))\n            temp['_'+id] = car;\n\n        data.packets.dynamic.cars = temp;\n    }\n\n    const buffer = BUNDLE_TYPE.toBuffer(data);\n\n    if(cars)\n        data.packets.dynamic.cars = cars;\n    \n    return buffer;\n}\n\nlet decode = (buf) => {\n    const buffer = Buffer.from(buf, 'utf8')\n    const data = BUNDLE_TYPE.fromBuffer(buffer);\n\n    if(data.packets.dynamic) {\n        let cars = data.packets.dynamic.cars;\n\n        for(const [id, car] of Object.entries(cars)) {\n            delete cars[id];\n\n            if(car)\n                cars[id.substr(1)] = car;\n        }\n    }\n\n    return data;\n}\n\n// let vec = new Vec2D(-1, 1);\n// let car = new Car(vec, 60);\n// let cars = {\n//     '2': car,\n//     '4': car,\n// };\n\n// let walls = [\n//     [[new Vec2D(0, 0), new Vec2D(0, 1), new Vec2D(1, 1), new Vec2D(1, 0)], [new Vec2D(0, 0), new Vec2D(0, -1), new Vec2D(1, -1), new Vec2D(1, 0)]],\n//     [[new Vec2D(0, 0), new Vec2D(0, 1), new Vec2D(-1, 1), new Vec2D(-1, 0)], [new Vec2D(0, 0), new Vec2D(0, -1), new Vec2D(-1, -1), new Vec2D(-1, 0)]],\n// ];\n\n// let bundle = {\n//     tick: 16000000,\n//     packets: {\n//         id: 4,\n//         dynamic: {\n//             cars: cars,\n//         },\n//         static: {\n//             scene: 'lobby',\n//             walls: walls,\n//         },\n//     },\n// };\n\n// const buff = encode(bundle); \n\n// console.log(buff);\n// console.log(decode(buff).packets.dynamic.cars);\n// console.log(bundle.packets.dynamic.cars)\n\nexports.encode = encode;\nexports.decode = decode;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/serialize.js?");

/***/ }),

/***/ "./src/shared_modules/util.js":
/*!************************************!*\
  !*** ./src/shared_modules/util.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("this.CANVAS_WIDTH = 480;\nthis.CANVAS_HEIGHT = 720;\nthis.BUFFER_SIZE = 1024\nthis.MAX_PLAYERS = 5;\nthis.NUM_LAPS = 3;\n\nthis.getTime = () => {\n    let d = new Date();\n    let t = d.getTime();\n    return t;\n}\n\nfunction interval (duration, fn) {\n    var _this = this\n    this.baseline = undefined\n    \n    this.run = function(){\n        if(_this.baseline === undefined){\n            _this.baseline = new Date().getTime()\n        }\n        fn()\n        var end = new Date().getTime()\n        _this.baseline += duration\n    \n        var nextTick = duration - (end - _this.baseline)\n        if(nextTick<0){\n            nextTick = 0\n        }\n        \n        _this.timer = setTimeout(function(){\n            _this.run(end)\n        }, nextTick)\n    }\n  \n    this.stop = function(){\n        clearTimeout(_this.timer)\n    }\n}\n\nthis.min_missing_id = (clients, min = 0, offset = 0) => {\n    let arr = Array.from(clients).sort((a, b) => a.id - b.id);\n\n    for(var i = 0; i < arr.length - 1; i++) {\n        if(arr[i + offset].id != i + min) {\n            break;\n        }\n    }\n    return i + min;\n}\n\nthis.getBuffer = (buffer, id) => {\n    return buffer[(id + this.BUFFER_SIZE) % this.BUFFER_SIZE];\n}\n\nthis.setBuffer = (buffer, id, data) => {\n    buffer[(id + this.BUFFER_SIZE) % this.BUFFER_SIZE] = data;\n}\n\nthis.copyObj = (obj) => {\n    return JSON.parse(JSON.stringify(obj));\n}\n\nexports = this;\nexports.interval = interval;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/util.js?");

/***/ }),

/***/ "?1dbe":
/*!************************!*\
  !*** stream (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/stream_(ignored)?");

/***/ }),

/***/ "?5399":
/*!************************!*\
  !*** stream (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/stream_(ignored)?");

/***/ }),

/***/ "?6f86":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/zlib_(ignored)?");

/***/ }),

/***/ "?a0c3":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/fs_(ignored)?");

/***/ }),

/***/ "?613f":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/os_(ignored)?");

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/available-typed-arrays/index.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/client/index.js");
/******/ 	
/******/ })()
;