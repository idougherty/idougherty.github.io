/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/avsc/etc/browser/avsc-services.js":
/*!********************************************************!*\
  !*** ./node_modules/avsc/etc/browser/avsc-services.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint browserify: true */\r\n\r\n\r\n\r\n/**\r\n * Optional entry point for browser builds.\r\n *\r\n * To use it: `require('avsc/etc/browser/avsc-services')`.\r\n */\r\n\r\nvar avroTypes = __webpack_require__(/*! ./avsc-types */ \"./node_modules/avsc/etc/browser/avsc-types.js\"),\r\n    services = __webpack_require__(/*! ../../lib/services */ \"./node_modules/avsc/lib/services.js\"),\r\n    specs = __webpack_require__(/*! ../../lib/specs */ \"./node_modules/avsc/lib/specs.js\"),\r\n    utils = __webpack_require__(/*! ../../lib/utils */ \"./node_modules/avsc/lib/utils.js\");\r\n\r\n\r\n/** Slightly enhanced parsing, supporting IDL declarations. */\r\nfunction parse(any, opts) {\r\n  var schemaOrProtocol = specs.read(any);\r\n  return schemaOrProtocol.protocol ?\r\n    services.Service.forProtocol(schemaOrProtocol, opts) :\r\n    avroTypes.Type.forSchema(schemaOrProtocol, opts);\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  Service: services.Service,\r\n  assembleProtocol: specs.assembleProtocol,\r\n  discoverProtocol: services.discoverProtocol,\r\n  parse: parse,\r\n  readProtocol: specs.readProtocol,\r\n  readSchema: specs.readSchema,\r\n};\r\n\r\nutils.copyOwnProperties(avroTypes, module.exports);\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/avsc-services.js?");

/***/ }),

/***/ "./node_modules/avsc/etc/browser/avsc-types.js":
/*!*****************************************************!*\
  !*** ./node_modules/avsc/etc/browser/avsc-types.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint browserify: true */\r\n\r\n\r\n\r\n/**\r\n * Optional entry point for browser builds.\r\n *\r\n * To use it: `require('avsc/etc/browser/avsc-types')`.\r\n */\r\n\r\nvar types = __webpack_require__(/*! ../../lib/types */ \"./node_modules/avsc/lib/types.js\");\r\n\r\n\r\n/** Basic parse method, only supporting JSON parsing. */\r\nfunction parse(any, opts) {\r\n  var schema;\r\n  if (typeof any == 'string') {\r\n    try {\r\n      schema = JSON.parse(any);\r\n    } catch (err) {\r\n      schema = any;\r\n    }\r\n  } else {\r\n    schema = any;\r\n  }\r\n  return types.Type.forSchema(schema, opts);\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  Type: types.Type,\r\n  parse: parse,\r\n  types: types.builtins,\r\n  // Deprecated exports (not using `util.deprecate` since it causes stack\r\n  // overflow errors in the browser).\r\n  combine: types.Type.forTypes,\r\n  infer: types.Type.forValue\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/avsc-types.js?");

/***/ }),

/***/ "./node_modules/avsc/etc/browser/avsc.js":
/*!***********************************************!*\
  !*** ./node_modules/avsc/etc/browser/avsc.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint browser: true, node: true */\r\n\r\n\r\n\r\n/**\r\n * Main browserify entry point.\r\n *\r\n * This version of the entry point adds a couple browser-specific utilities to\r\n * read and write blobs.\r\n */\r\n\r\nvar avroServices = __webpack_require__(/*! ./avsc-services */ \"./node_modules/avsc/etc/browser/avsc-services.js\"),\r\n    containers = __webpack_require__(/*! ../../lib/containers */ \"./node_modules/avsc/lib/containers.js\"),\r\n    utils = __webpack_require__(/*! ../../lib/utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    stream = __webpack_require__(/*! stream */ \"?1dbe\"),\r\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\n\r\n\r\n/** Transform stream which lazily reads a blob's contents. */\r\nfunction BlobReader(blob, opts) {\r\n  stream.Readable.call(this);\r\n  opts = opts || {};\r\n\r\n  this._batchSize = opts.batchSize || 65536;\r\n  this._blob = blob;\r\n  this._pos = 0;\r\n}\r\nutil.inherits(BlobReader, stream.Readable);\r\n\r\nBlobReader.prototype._read = function () {\r\n  var pos = this._pos;\r\n  if (pos >= this._blob.size) {\r\n    this.push(null);\r\n    return;\r\n  }\r\n\r\n  this._pos += this._batchSize;\r\n  var blob = this._blob.slice(pos, this._pos, this._blob.type);\r\n  var reader = new FileReader();\r\n  var self = this;\r\n  reader.addEventListener('loadend', function cb(evt) {\r\n    reader.removeEventListener('loadend', cb, false);\r\n    if (evt.error) {\r\n      self.emit('error', evt.error);\r\n    } else {\r\n      self.push(utils.bufferFrom(reader.result));\r\n    }\r\n  }, false);\r\n  reader.readAsArrayBuffer(blob);\r\n};\r\n\r\n/** Transform stream which builds a blob from all data written to it. */\r\nfunction BlobWriter() {\r\n  stream.Transform.call(this, {readableObjectMode: true});\r\n  this._bufs = [];\r\n}\r\nutil.inherits(BlobWriter, stream.Transform);\r\n\r\nBlobWriter.prototype._transform = function (buf, encoding, cb) {\r\n  this._bufs.push(buf);\r\n  cb();\r\n};\r\n\r\nBlobWriter.prototype._flush = function (cb) {\r\n  this.push(new Blob(this._bufs, {type: 'application/octet-binary'}));\r\n  cb();\r\n};\r\n\r\n/** Read an Avro-container stored as a blob. */\r\nfunction createBlobDecoder(blob, opts) {\r\n  return new BlobReader(blob).pipe(new containers.streams.BlockDecoder(opts));\r\n}\r\n\r\n/**\r\n * Store Avro values into an Avro-container blob.\r\n *\r\n * The returned stream will emit a single value, the blob, when ended.\r\n */\r\nfunction createBlobEncoder(schema, opts) {\r\n  var encoder = new containers.streams.BlockEncoder(schema, opts);\r\n  var builder = new BlobWriter();\r\n  encoder.pipe(builder);\r\n  return new stream.Duplex({\r\n    objectMode: true,\r\n    read: function () {\r\n      // Not the fastest implementation, but it will only be called at most\r\n      // once (since the builder only ever emits a single value) so it'll do.\r\n      // It's also likely impractical to create very large blobs.\r\n      var val = builder.read();\r\n      if (val) {\r\n        done(val);\r\n      } else {\r\n        builder.once('readable', done);\r\n      }\r\n      var self = this;\r\n      function done(val) {\r\n        self.push(val || builder.read());\r\n        self.push(null);\r\n      }\r\n    },\r\n    write: function (val, encoding, cb) {\r\n      return encoder.write(val, encoding, cb);\r\n    }\r\n  }).on('finish', function () { encoder.end(); });\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  createBlobDecoder: createBlobDecoder,\r\n  createBlobEncoder: createBlobEncoder,\r\n  streams: containers.streams\r\n};\r\n\r\nutils.copyOwnProperties(avroServices, module.exports);\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/avsc.js?");

/***/ }),

/***/ "./node_modules/avsc/etc/browser/lib/crypto.js":
/*!*****************************************************!*\
  !*** ./node_modules/avsc/etc/browser/lib/crypto.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* jshint browserify: true */\r\n\r\n\r\n\r\n/**\r\n * Shim to enable schema fingerprint computation.\r\n *\r\n * MD5 implementation originally from [1], used with permission from the\r\n * author, and lightly edited.\r\n *\r\n * [1] http://www.myersdaily.org/joseph/javascript/md5-text.html\r\n *\r\n */\r\n\r\nfunction createHash(algorithm) {\r\n  if (algorithm !== 'md5') {\r\n    throw new Error('only md5 is supported in the browser');\r\n  }\r\n  return new Hash();\r\n}\r\n\r\nfunction Hash() { this.data = undefined; }\r\nHash.prototype.end = function (data) { this.data = data; };\r\nHash.prototype.read = function () { return md5(this.data); };\r\n\r\nfunction md5cycle(x, k) {\r\n  var a = x[0], b = x[1], c = x[2], d = x[3];\r\n\r\n  a = ff(a, b, c, d, k[0], 7, -680876936);\r\n  d = ff(d, a, b, c, k[1], 12, -389564586);\r\n  c = ff(c, d, a, b, k[2], 17,  606105819);\r\n  b = ff(b, c, d, a, k[3], 22, -1044525330);\r\n  a = ff(a, b, c, d, k[4], 7, -176418897);\r\n  d = ff(d, a, b, c, k[5], 12,  1200080426);\r\n  c = ff(c, d, a, b, k[6], 17, -1473231341);\r\n  b = ff(b, c, d, a, k[7], 22, -45705983);\r\n  a = ff(a, b, c, d, k[8], 7,  1770035416);\r\n  d = ff(d, a, b, c, k[9], 12, -1958414417);\r\n  c = ff(c, d, a, b, k[10], 17, -42063);\r\n  b = ff(b, c, d, a, k[11], 22, -1990404162);\r\n  a = ff(a, b, c, d, k[12], 7,  1804603682);\r\n  d = ff(d, a, b, c, k[13], 12, -40341101);\r\n  c = ff(c, d, a, b, k[14], 17, -1502002290);\r\n  b = ff(b, c, d, a, k[15], 22,  1236535329);\r\n\r\n  a = gg(a, b, c, d, k[1], 5, -165796510);\r\n  d = gg(d, a, b, c, k[6], 9, -1069501632);\r\n  c = gg(c, d, a, b, k[11], 14,  643717713);\r\n  b = gg(b, c, d, a, k[0], 20, -373897302);\r\n  a = gg(a, b, c, d, k[5], 5, -701558691);\r\n  d = gg(d, a, b, c, k[10], 9,  38016083);\r\n  c = gg(c, d, a, b, k[15], 14, -660478335);\r\n  b = gg(b, c, d, a, k[4], 20, -405537848);\r\n  a = gg(a, b, c, d, k[9], 5,  568446438);\r\n  d = gg(d, a, b, c, k[14], 9, -1019803690);\r\n  c = gg(c, d, a, b, k[3], 14, -187363961);\r\n  b = gg(b, c, d, a, k[8], 20,  1163531501);\r\n  a = gg(a, b, c, d, k[13], 5, -1444681467);\r\n  d = gg(d, a, b, c, k[2], 9, -51403784);\r\n  c = gg(c, d, a, b, k[7], 14,  1735328473);\r\n  b = gg(b, c, d, a, k[12], 20, -1926607734);\r\n\r\n  a = hh(a, b, c, d, k[5], 4, -378558);\r\n  d = hh(d, a, b, c, k[8], 11, -2022574463);\r\n  c = hh(c, d, a, b, k[11], 16,  1839030562);\r\n  b = hh(b, c, d, a, k[14], 23, -35309556);\r\n  a = hh(a, b, c, d, k[1], 4, -1530992060);\r\n  d = hh(d, a, b, c, k[4], 11,  1272893353);\r\n  c = hh(c, d, a, b, k[7], 16, -155497632);\r\n  b = hh(b, c, d, a, k[10], 23, -1094730640);\r\n  a = hh(a, b, c, d, k[13], 4,  681279174);\r\n  d = hh(d, a, b, c, k[0], 11, -358537222);\r\n  c = hh(c, d, a, b, k[3], 16, -722521979);\r\n  b = hh(b, c, d, a, k[6], 23,  76029189);\r\n  a = hh(a, b, c, d, k[9], 4, -640364487);\r\n  d = hh(d, a, b, c, k[12], 11, -421815835);\r\n  c = hh(c, d, a, b, k[15], 16,  530742520);\r\n  b = hh(b, c, d, a, k[2], 23, -995338651);\r\n\r\n  a = ii(a, b, c, d, k[0], 6, -198630844);\r\n  d = ii(d, a, b, c, k[7], 10,  1126891415);\r\n  c = ii(c, d, a, b, k[14], 15, -1416354905);\r\n  b = ii(b, c, d, a, k[5], 21, -57434055);\r\n  a = ii(a, b, c, d, k[12], 6,  1700485571);\r\n  d = ii(d, a, b, c, k[3], 10, -1894986606);\r\n  c = ii(c, d, a, b, k[10], 15, -1051523);\r\n  b = ii(b, c, d, a, k[1], 21, -2054922799);\r\n  a = ii(a, b, c, d, k[8], 6,  1873313359);\r\n  d = ii(d, a, b, c, k[15], 10, -30611744);\r\n  c = ii(c, d, a, b, k[6], 15, -1560198380);\r\n  b = ii(b, c, d, a, k[13], 21,  1309151649);\r\n  a = ii(a, b, c, d, k[4], 6, -145523070);\r\n  d = ii(d, a, b, c, k[11], 10, -1120210379);\r\n  c = ii(c, d, a, b, k[2], 15,  718787259);\r\n  b = ii(b, c, d, a, k[9], 21, -343485551);\r\n\r\n  x[0] = add32(a, x[0]);\r\n  x[1] = add32(b, x[1]);\r\n  x[2] = add32(c, x[2]);\r\n  x[3] = add32(d, x[3]);\r\n}\r\n\r\nfunction cmn(q, a, b, x, s, t) {\r\n  a = add32(add32(a, q), add32(x, t));\r\n  return add32((a << s) | (a >>> (32 - s)), b);\r\n}\r\n\r\nfunction ff(a, b, c, d, x, s, t) {\r\n  return cmn((b & c) | ((~b) & d), a, b, x, s, t);\r\n}\r\n\r\nfunction gg(a, b, c, d, x, s, t) {\r\n  return cmn((b & d) | (c & (~d)), a, b, x, s, t);\r\n}\r\n\r\nfunction hh(a, b, c, d, x, s, t) {\r\n  return cmn(b ^ c ^ d, a, b, x, s, t);\r\n}\r\n\r\nfunction ii(a, b, c, d, x, s, t) {\r\n  return cmn(c ^ (b | (~d)), a, b, x, s, t);\r\n}\r\n\r\nfunction md51(s) {\r\n  var n = s.length,\r\n  state = [1732584193, -271733879, -1732584194, 271733878], i;\r\n  for (i=64; i<=s.length; i+=64) {\r\n    md5cycle(state, md5blk(s.substring(i-64, i)));\r\n  }\r\n\r\n  s = s.substring(i-64);\r\n  var tail = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];\r\n  for (i=0; i<s.length; i++) {\r\n    tail[i>>2] |= s.charCodeAt(i) << ((i%4) << 3);\r\n  }\r\n  tail[i>>2] |= 0x80 << ((i%4) << 3);\r\n  if (i > 55) {\r\n    md5cycle(state, tail);\r\n    for (i=0; i<16; i++) {\r\n      tail[i] = 0;\r\n    }\r\n  }\r\n  tail[14] = n*8;\r\n  md5cycle(state, tail);\r\n  return state;\r\n}\r\n\r\nfunction md5blk(s) {\r\n  var md5blks = [], i;\r\n  for (i=0; i<64; i+=4) {\r\n    md5blks[i>>2] = s.charCodeAt(i) +\r\n      (s.charCodeAt(i+1) << 8) +\r\n      (s.charCodeAt(i+2) << 16) +\r\n      (s.charCodeAt(i+3) << 24);\r\n  }\r\n  return md5blks;\r\n}\r\n\r\nfunction md5(s) {\r\n  var arr = md51(s);\r\n  var buf = Buffer.alloc ? Buffer.alloc(16) : new Buffer(16);\r\n  var i;\r\n  for (i = 0; i < 4; i++) {\r\n    buf.writeIntLE(arr[i], i * 4, 4);\r\n  }\r\n  return buf;\r\n}\r\n\r\nfunction add32(a, b) {\r\n  return (a + b) & 0xFFFFFFFF;\r\n}\r\n\r\nmodule.exports = {\r\n  createHash: createHash\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/lib/crypto.js?");

/***/ }),

/***/ "./node_modules/avsc/etc/browser/lib/files.js":
/*!****************************************************!*\
  !*** ./node_modules/avsc/etc/browser/lib/files.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("/* jshint node: true */\r\n\r\n\r\n\r\n/** Shim without file-system operations. */\r\n\r\nfunction createError() { return new Error('unsupported in the browser'); }\r\n\r\nfunction createImportHook() {\r\n  return function (fpath, kind, cb) { cb(createError()); };\r\n}\r\n\r\nfunction createSyncImportHook() {\r\n  return function () { throw createError(); };\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  createImportHook: createImportHook,\r\n  createSyncImportHook: createSyncImportHook,\r\n  existsSync: function () { return false; },\r\n  readFileSync: function () { throw createError(); }\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/etc/browser/lib/files.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/containers.js":
/*!*********************************************!*\
  !*** ./node_modules/avsc/lib/containers.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n/* jshint node: true */\r\n\r\n// TODO: Add streams which prefix each record with its length.\r\n\r\n\r\n\r\n/**\r\n * This module defines custom streams to write and read Avro files.\r\n *\r\n * In particular, the `Block{En,De}coder` streams are able to deal with Avro\r\n * container files. None of the streams below depend on the filesystem however,\r\n * this way they can also be used in the browser (for example to parse HTTP\r\n * responses).\r\n */\r\n\r\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\r\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    stream = __webpack_require__(/*! stream */ \"?5399\"),\r\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\"),\r\n    zlib = __webpack_require__(/*! zlib */ \"?6f86\");\r\n\r\n\r\nvar OPTS = {namespace: 'org.apache.avro.file'};\r\n\r\nvar LONG_TYPE = types.Type.forSchema('long', OPTS);\r\n\r\nvar MAP_BYTES_TYPE = types.Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\r\n\r\nvar HEADER_TYPE = types.Type.forSchema({\r\n  name: 'Header',\r\n  type: 'record',\r\n  fields : [\r\n    {name: 'magic', type: {type: 'fixed', name: 'Magic', size: 4}},\r\n    {name: 'meta', type: MAP_BYTES_TYPE},\r\n    {name: 'sync', type: {type: 'fixed', name: 'Sync', size: 16}}\r\n  ]\r\n}, OPTS);\r\n\r\nvar BLOCK_TYPE = types.Type.forSchema({\r\n  name: 'Block',\r\n  type: 'record',\r\n  fields : [\r\n    {name: 'count', type: 'long'},\r\n    {name: 'data', type: 'bytes'},\r\n    {name: 'sync', type: 'Sync'}\r\n  ]\r\n}, OPTS);\r\n\r\n// First 4 bytes of an Avro object container file.\r\nvar MAGIC_BYTES = utils.bufferFrom('Obj\\x01');\r\n\r\n// Convenience.\r\nvar f = util.format;\r\nvar Tap = utils.Tap;\r\n\r\n\r\n/** Duplex stream for decoding fragments. */\r\nfunction RawDecoder(schema, opts) {\r\n  opts = opts || {};\r\n\r\n  var noDecode = !!opts.noDecode;\r\n  stream.Duplex.call(this, {\r\n    readableObjectMode: !noDecode,\r\n    allowHalfOpen: false\r\n  });\r\n\r\n  this._type = types.Type.forSchema(schema);\r\n  this._tap = new Tap(utils.newBuffer(0));\r\n  this._writeCb = null;\r\n  this._needPush = false;\r\n  this._readValue = createReader(noDecode, this._type);\r\n  this._finished = false;\r\n\r\n  this.on('finish', function () {\r\n    this._finished = true;\r\n    this._read();\r\n  });\r\n}\r\nutil.inherits(RawDecoder, stream.Duplex);\r\n\r\nRawDecoder.prototype._write = function (chunk, encoding, cb) {\r\n  // Store the write callback and call it when we are done decoding all records\r\n  // in this chunk. If we call it right away, we risk loading the entire input\r\n  // in memory. We only need to store the latest callback since the stream API\r\n  // guarantees that `_write` won't be called again until we call the previous.\r\n  this._writeCb = cb;\r\n\r\n  var tap = this._tap;\r\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\r\n  tap.pos = 0;\r\n  if (this._needPush) {\r\n    this._needPush = false;\r\n    this._read();\r\n  }\r\n};\r\n\r\nRawDecoder.prototype._read = function () {\r\n  this._needPush = false;\r\n\r\n  var tap = this._tap;\r\n  var pos = tap.pos;\r\n  var val = this._readValue(tap);\r\n  if (tap.isValid()) {\r\n    this.push(val);\r\n  } else if (!this._finished) {\r\n    tap.pos = pos;\r\n    this._needPush = true;\r\n    if (this._writeCb) {\r\n      // This should only ever be false on the first read, and only if it\r\n      // happens before the first write.\r\n      this._writeCb();\r\n    }\r\n  } else {\r\n    this.push(null);\r\n  }\r\n};\r\n\r\n\r\n/** Duplex stream for decoding object container files. */\r\nfunction BlockDecoder(opts) {\r\n  opts = opts || {};\r\n\r\n  var noDecode = !!opts.noDecode;\r\n  stream.Duplex.call(this, {\r\n    allowHalfOpen: true, // For async decompressors.\r\n    readableObjectMode: !noDecode\r\n  });\r\n\r\n  this._rType = opts.readerSchema !== undefined ?\r\n    types.Type.forSchema(opts.readerSchema) :\r\n    undefined;\r\n  this._wType = null;\r\n  this._codecs = opts.codecs;\r\n  this._codec = undefined;\r\n  this._parseHook = opts.parseHook;\r\n  this._tap = new Tap(utils.newBuffer(0));\r\n  this._blockTap = new Tap(utils.newBuffer(0));\r\n  this._syncMarker = null;\r\n  this._readValue = null;\r\n  this._noDecode = noDecode;\r\n  this._queue = new utils.OrderedQueue();\r\n  this._decompress = null; // Decompression function.\r\n  this._index = 0; // Next block index.\r\n  this._remaining = undefined; // In the current block.\r\n  this._needPush = false;\r\n  this._finished = false;\r\n\r\n  this.on('finish', function () {\r\n    this._finished = true;\r\n    if (this._needPush) {\r\n      this._read();\r\n    }\r\n  });\r\n}\r\nutil.inherits(BlockDecoder, stream.Duplex);\r\n\r\nBlockDecoder.defaultCodecs = function () {\r\n  return {\r\n    'null': function (buf, cb) { cb(null, buf); },\r\n    'deflate': zlib.inflateRaw\r\n  };\r\n};\r\n\r\nBlockDecoder.getDefaultCodecs = BlockDecoder.defaultCodecs;\r\n\r\nBlockDecoder.prototype._decodeHeader = function () {\r\n  var tap = this._tap;\r\n  if (tap.buf.length < MAGIC_BYTES.length) {\r\n    // Wait until more data arrives.\r\n    return false;\r\n  }\r\n\r\n  if (!MAGIC_BYTES.equals(tap.buf.slice(0, MAGIC_BYTES.length))) {\r\n    this.emit('error', new Error('invalid magic bytes'));\r\n    return false;\r\n  }\r\n\r\n  var header = HEADER_TYPE._read(tap);\r\n  if (!tap.isValid()) {\r\n    return false;\r\n  }\r\n\r\n  this._codec = (header.meta['avro.codec'] || 'null').toString();\r\n  var codecs = this._codecs || BlockDecoder.getDefaultCodecs();\r\n  this._decompress = codecs[this._codec];\r\n  if (!this._decompress) {\r\n    this.emit('error', new Error(f('unknown codec: %s', this._codec)));\r\n    return;\r\n  }\r\n\r\n  try {\r\n    var schema = JSON.parse(header.meta['avro.schema'].toString());\r\n    if (this._parseHook) {\r\n      schema = this._parseHook(schema);\r\n    }\r\n    this._wType = types.Type.forSchema(schema);\r\n  } catch (err) {\r\n    this.emit('error', err);\r\n    return;\r\n  }\r\n\r\n  try {\r\n    this._readValue = createReader(this._noDecode, this._wType, this._rType);\r\n  } catch (err) {\r\n    this.emit('error', err);\r\n    return;\r\n  }\r\n\r\n  this._syncMarker = header.sync;\r\n  this.emit('metadata', this._wType, this._codec, header);\r\n  return true;\r\n};\r\n\r\nBlockDecoder.prototype._write = function (chunk, encoding, cb) {\r\n  var tap = this._tap;\r\n  tap.buf = Buffer.concat([tap.buf, chunk]);\r\n  tap.pos = 0;\r\n\r\n  if (!this._decodeHeader()) {\r\n    process.nextTick(cb);\r\n    return;\r\n  }\r\n\r\n  // We got the header, switch to block decoding mode. Also, call it directly\r\n  // in case we already have all the data (in which case `_write` wouldn't get\r\n  // called anymore).\r\n  this._write = this._writeChunk;\r\n  this._write(utils.newBuffer(0), encoding, cb);\r\n};\r\n\r\nBlockDecoder.prototype._writeChunk = function (chunk, encoding, cb) {\r\n  var tap = this._tap;\r\n  tap.buf = Buffer.concat([tap.buf.slice(tap.pos), chunk]);\r\n  tap.pos = 0;\r\n\r\n  var nBlocks = 1;\r\n  var block;\r\n  while ((block = tryReadBlock(tap))) {\r\n    if (!this._syncMarker.equals(block.sync)) {\r\n      this.emit('error', new Error('invalid sync marker'));\r\n      return;\r\n    }\r\n    nBlocks++;\r\n    this._decompress(\r\n      block.data,\r\n      this._createBlockCallback(block.data.length, block.count, chunkCb)\r\n    );\r\n  }\r\n  chunkCb();\r\n\r\n  function chunkCb() {\r\n    if (!--nBlocks) {\r\n      cb();\r\n    }\r\n  }\r\n};\r\n\r\nBlockDecoder.prototype._createBlockCallback = function (size, count, cb) {\r\n  var self = this;\r\n  var index = this._index++;\r\n\r\n  return function (cause, data) {\r\n    if (cause) {\r\n      var err = new Error(f('%s codec decompression error', self._codec));\r\n      err.cause = cause;\r\n      self.emit('error', err);\r\n      cb();\r\n    } else {\r\n      self.emit('block', new BlockInfo(count, data.length, size));\r\n      self._queue.push(new BlockData(index, data, cb, count));\r\n      if (self._needPush) {\r\n        self._read();\r\n      }\r\n    }\r\n  };\r\n};\r\n\r\nBlockDecoder.prototype._read = function () {\r\n  this._needPush = false;\r\n\r\n  var tap = this._blockTap;\r\n  if (!this._remaining) {\r\n    var data = this._queue.pop();\r\n    if (!data || !data.count) {\r\n      if (this._finished) {\r\n        this.push(null);\r\n      } else {\r\n        this._needPush = true;\r\n      }\r\n      if (data) {\r\n        data.cb();\r\n      }\r\n      return; // Wait for more data.\r\n    }\r\n    data.cb();\r\n    this._remaining = data.count;\r\n    tap.buf = data.buf;\r\n    tap.pos = 0;\r\n  }\r\n\r\n  this._remaining--;\r\n  var val;\r\n  try {\r\n    val = this._readValue(tap);\r\n    if (!tap.isValid()) {\r\n      throw new Error('truncated block');\r\n    }\r\n  } catch (err) {\r\n    this._remaining = 0;\r\n    this.emit('error', err); // Corrupt data.\r\n    return;\r\n  }\r\n  this.push(val);\r\n};\r\n\r\n\r\n/** Duplex stream for encoding. */\r\nfunction RawEncoder(schema, opts) {\r\n  opts = opts || {};\r\n\r\n  stream.Transform.call(this, {\r\n    writableObjectMode: true,\r\n    allowHalfOpen: false\r\n  });\r\n\r\n  this._type = types.Type.forSchema(schema);\r\n  this._writeValue = function (tap, val) {\r\n    try {\r\n      this._type._write(tap, val);\r\n    } catch (err) {\r\n      this.emit('typeError', err, val, this._type);\r\n    }\r\n  };\r\n  this._tap = new Tap(utils.newBuffer(opts.batchSize || 65536));\r\n\r\n  this.on('typeError', function (err) { this.emit('error', err); });\r\n}\r\nutil.inherits(RawEncoder, stream.Transform);\r\n\r\nRawEncoder.prototype._transform = function (val, encoding, cb) {\r\n  var tap = this._tap;\r\n  var buf = tap.buf;\r\n  var pos = tap.pos;\r\n\r\n  this._writeValue(tap, val);\r\n  if (!tap.isValid()) {\r\n    if (pos) {\r\n      // Emit any valid data.\r\n      this.push(copyBuffer(tap.buf, 0, pos));\r\n    }\r\n    var len = tap.pos - pos;\r\n    if (len > buf.length) {\r\n      // Not enough space for last written object, need to resize.\r\n      tap.buf = utils.newBuffer(2 * len);\r\n    }\r\n    tap.pos = 0;\r\n    this._writeValue(tap, val); // Rewrite last failed write.\r\n  }\r\n\r\n  cb();\r\n};\r\n\r\nRawEncoder.prototype._flush = function (cb) {\r\n  var tap = this._tap;\r\n  var pos = tap.pos;\r\n  if (pos) {\r\n    // This should only ever be false if nothing is written to the stream.\r\n    this.push(tap.buf.slice(0, pos));\r\n  }\r\n  cb();\r\n};\r\n\r\n\r\n/**\r\n * Duplex stream to write object container files.\r\n *\r\n * @param schema\r\n * @param opts {Object}\r\n *\r\n *  + `blockSize`, uncompressed.\r\n *  + `codec`\r\n *  + `codecs`\r\n *  + `metadata``\r\n *  + `noCheck`\r\n *  + `omitHeader`, useful to append to an existing block file.\r\n */\r\nfunction BlockEncoder(schema, opts) {\r\n  opts = opts || {};\r\n\r\n  stream.Duplex.call(this, {\r\n    allowHalfOpen: true, // To support async compressors.\r\n    writableObjectMode: true\r\n  });\r\n\r\n  var type;\r\n  if (types.Type.isType(schema)) {\r\n    type = schema;\r\n    schema = undefined;\r\n  } else {\r\n    // Keep full schema to be able to write it to the header later.\r\n    type = types.Type.forSchema(schema);\r\n  }\r\n\r\n  this._schema = schema;\r\n  this._type = type;\r\n  this._writeValue = function (tap, val) {\r\n    try {\r\n      this._type._write(tap, val);\r\n    } catch (err) {\r\n      this.emit('typeError', err, val, this._type);\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n  this._blockSize = opts.blockSize || 65536;\r\n  this._tap = new Tap(utils.newBuffer(this._blockSize));\r\n  this._codecs = opts.codecs;\r\n  this._codec = opts.codec || 'null';\r\n  this._blockCount = 0;\r\n  this._syncMarker = opts.syncMarker || new utils.Lcg().nextBuffer(16);\r\n  this._queue = new utils.OrderedQueue();\r\n  this._pending = 0;\r\n  this._finished = false;\r\n  this._needHeader = false;\r\n  this._needPush = false;\r\n\r\n  this._metadata = opts.metadata || {};\r\n  if (!MAP_BYTES_TYPE.isValid(this._metadata)) {\r\n    throw new Error('invalid metadata');\r\n  }\r\n\r\n  var codec = this._codec;\r\n  this._compress = (this._codecs || BlockEncoder.getDefaultCodecs())[codec];\r\n  if (!this._compress) {\r\n    throw new Error(f('unsupported codec: %s', codec));\r\n  }\r\n\r\n  if (opts.omitHeader !== undefined) { // Legacy option.\r\n    opts.writeHeader = opts.omitHeader ? 'never' : 'auto';\r\n  }\r\n  switch (opts.writeHeader) {\r\n    case false:\r\n    case 'never':\r\n      break;\r\n    case undefined: // Backwards-compatibility (eager default would be better).\r\n    case 'auto':\r\n      this._needHeader = true;\r\n      break;\r\n    default:\r\n      this._writeHeader();\r\n  }\r\n\r\n  this.on('finish', function () {\r\n    this._finished = true;\r\n    if (this._blockCount) {\r\n      this._flushChunk();\r\n    } else if (this._finished && this._needPush) {\r\n      // We don't need to check `_isPending` since `_blockCount` is always\r\n      // positive after the first flush.\r\n      this.push(null);\r\n    }\r\n  });\r\n\r\n  this.on('typeError', function (err) { this.emit('error', err); });\r\n}\r\nutil.inherits(BlockEncoder, stream.Duplex);\r\n\r\nBlockEncoder.defaultCodecs = function () {\r\n  return {\r\n    'null': function (buf, cb) { cb(null, buf); },\r\n    'deflate': zlib.deflateRaw\r\n  };\r\n};\r\n\r\nBlockEncoder.getDefaultCodecs = BlockEncoder.defaultCodecs;\r\n\r\nBlockEncoder.prototype._writeHeader = function () {\r\n  var schema = JSON.stringify(\r\n    this._schema ? this._schema : this._type.getSchema({exportAttrs: true})\r\n  );\r\n  var meta = utils.copyOwnProperties(\r\n    this._metadata,\r\n    {'avro.schema': utils.bufferFrom(schema), 'avro.codec': utils.bufferFrom(this._codec)},\r\n    true // Overwrite.\r\n  );\r\n  var Header = HEADER_TYPE.getRecordConstructor();\r\n  var header = new Header(MAGIC_BYTES, meta, this._syncMarker);\r\n  this.push(header.toBuffer());\r\n};\r\n\r\nBlockEncoder.prototype._write = function (val, encoding, cb) {\r\n  if (this._needHeader) {\r\n    this._writeHeader();\r\n    this._needHeader = false;\r\n  }\r\n\r\n  var tap = this._tap;\r\n  var pos = tap.pos;\r\n  var flushing = false;\r\n\r\n  if (this._writeValue(tap, val)) {\r\n    if (!tap.isValid()) {\r\n      if (pos) {\r\n        this._flushChunk(pos, cb);\r\n        flushing = true;\r\n      }\r\n      var len = tap.pos - pos;\r\n      if (len > this._blockSize) {\r\n        // Not enough space for last written object, need to resize.\r\n        this._blockSize = len * 2;\r\n      }\r\n      tap.buf = utils.newBuffer(this._blockSize);\r\n      tap.pos = 0;\r\n      this._writeValue(tap, val); // Rewrite last failed write.\r\n    }\r\n    this._blockCount++;\r\n  } else {\r\n    tap.pos = pos;\r\n  }\r\n\r\n  if (!flushing) {\r\n    cb();\r\n  }\r\n};\r\n\r\nBlockEncoder.prototype._flushChunk = function (pos, cb) {\r\n  var tap = this._tap;\r\n  pos = pos || tap.pos;\r\n  this._compress(tap.buf.slice(0, pos), this._createBlockCallback(pos, cb));\r\n  this._blockCount = 0;\r\n};\r\n\r\nBlockEncoder.prototype._read = function () {\r\n  var self = this;\r\n  var data = this._queue.pop();\r\n  if (!data) {\r\n    if (this._finished && !this._pending) {\r\n      process.nextTick(function () { self.push(null); });\r\n    } else {\r\n      this._needPush = true;\r\n    }\r\n    return;\r\n  }\r\n\r\n  this.push(LONG_TYPE.toBuffer(data.count, true));\r\n  this.push(LONG_TYPE.toBuffer(data.buf.length, true));\r\n  this.push(data.buf);\r\n  this.push(this._syncMarker);\r\n\r\n  if (!this._finished) {\r\n    data.cb();\r\n  }\r\n};\r\n\r\nBlockEncoder.prototype._createBlockCallback = function (size, cb) {\r\n  var self = this;\r\n  var index = this._index++;\r\n  var count = this._blockCount;\r\n  this._pending++;\r\n\r\n  return function (cause, data) {\r\n    if (cause) {\r\n      var err = new Error(f('%s codec compression error', self._codec));\r\n      err.cause = cause;\r\n      self.emit('error', err);\r\n      return;\r\n    }\r\n    self._pending--;\r\n    self.emit('block', new BlockInfo(count, size, data.length));\r\n    self._queue.push(new BlockData(index, data, cb, count));\r\n    if (self._needPush) {\r\n      self._needPush = false;\r\n      self._read();\r\n    }\r\n  };\r\n};\r\n\r\n\r\n// Helpers.\r\n\r\n/** Summary information about a block. */\r\nfunction BlockInfo(count, raw, compressed) {\r\n  this.valueCount = count;\r\n  this.rawDataLength = raw;\r\n  this.compressedDataLength = compressed;\r\n}\r\n\r\n/**\r\n * An indexed block.\r\n *\r\n * This can be used to preserve block order since compression and decompression\r\n * can cause some some blocks to be returned out of order.\r\n */\r\nfunction BlockData(index, buf, cb, count) {\r\n  this.index = index;\r\n  this.buf = buf;\r\n  this.cb = cb;\r\n  this.count = count | 0;\r\n}\r\n\r\n/** Maybe get a block. */\r\nfunction tryReadBlock(tap) {\r\n  var pos = tap.pos;\r\n  var block = BLOCK_TYPE._read(tap);\r\n  if (!tap.isValid()) {\r\n    tap.pos = pos;\r\n    return null;\r\n  }\r\n  return block;\r\n}\r\n\r\n/** Create bytes consumer, either reading or skipping records. */\r\nfunction createReader(noDecode, writerType, readerType) {\r\n  if (noDecode) {\r\n    return (function (skipper) {\r\n      return function (tap) {\r\n        var pos = tap.pos;\r\n        skipper(tap);\r\n        return tap.buf.slice(pos, tap.pos);\r\n      };\r\n    })(writerType._skip);\r\n  } else if (readerType) {\r\n    var resolver = readerType.createResolver(writerType);\r\n    return function (tap) { return resolver._read(tap); };\r\n  } else {\r\n    return function (tap) { return writerType._read(tap); };\r\n  }\r\n}\r\n\r\n/** Copy a buffer. This avoids creating a slice of the original buffer. */\r\nfunction copyBuffer(buf, pos, len) {\r\n  var copy = utils.newBuffer(len);\r\n  buf.copy(copy, 0, pos, pos + len);\r\n  return copy;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  BLOCK_TYPE: BLOCK_TYPE, // For tests.\r\n  HEADER_TYPE: HEADER_TYPE, // Idem.\r\n  MAGIC_BYTES: MAGIC_BYTES, // Idem.\r\n  streams: {\r\n    BlockDecoder: BlockDecoder,\r\n    BlockEncoder: BlockEncoder,\r\n    RawDecoder: RawDecoder,\r\n    RawEncoder: RawEncoder\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/containers.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/services.js":
/*!*******************************************!*\
  !*** ./node_modules/avsc/lib/services.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* jshint node: true */\r\n\r\n// TODO: Add broadcast option to client `_emitMessage`, accessible for one-way\r\n// messages.\r\n// TODO: Add `server.mount` method to allow combining servers. The API is as\r\n// follows: a mounted server's (i.e. the method's argument) handlers have lower\r\n// precedence than the original server (i.e. `this`); the mounted server's\r\n// middlewares are only invoked for its handlers.\r\n// TODO: Change `objectMode` client and server channel option to `encoding`\r\n// (accepting `'netty'`, `'standard'`, and `null` or `undefined`). Perhaps also\r\n// expose encoders (API TBD).\r\n\r\n\r\n\r\n/** This module implements Avro's IPC/RPC logic. */\r\n\r\nvar types = __webpack_require__(/*! ./types */ \"./node_modules/avsc/lib/types.js\"),\r\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\"),\r\n    stream = __webpack_require__(/*! stream */ \"?5399\"),\r\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\n\r\n\r\n// A few convenience imports.\r\nvar Tap = utils.Tap;\r\nvar Type = types.Type;\r\nvar debug = util.debuglog('avsc:services');\r\nvar f = util.format;\r\n\r\n// Various useful types. We instantiate options once, to share the registry.\r\nvar OPTS = {namespace: 'org.apache.avro.ipc'};\r\n\r\nvar BOOLEAN_TYPE = Type.forSchema('boolean', OPTS);\r\n\r\nvar MAP_BYTES_TYPE = Type.forSchema({type: 'map', values: 'bytes'}, OPTS);\r\n\r\nvar STRING_TYPE = Type.forSchema('string', OPTS);\r\n\r\nvar HANDSHAKE_REQUEST_TYPE = Type.forSchema({\r\n  name: 'HandshakeRequest',\r\n  type: 'record',\r\n  fields: [\r\n    {name: 'clientHash', type: {name: 'MD5', type: 'fixed', size: 16}},\r\n    {name: 'clientProtocol', type: ['null', 'string'], 'default': null},\r\n    {name: 'serverHash', type: 'MD5'},\r\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\r\n  ]\r\n}, OPTS);\r\n\r\nvar HANDSHAKE_RESPONSE_TYPE = Type.forSchema({\r\n  name: 'HandshakeResponse',\r\n  type: 'record',\r\n  fields: [\r\n    {\r\n      name: 'match',\r\n      type: {\r\n        name: 'HandshakeMatch',\r\n        type: 'enum',\r\n        symbols: ['BOTH', 'CLIENT', 'NONE']\r\n      }\r\n    },\r\n    {name: 'serverProtocol', type: ['null', 'string'], 'default': null},\r\n    {name: 'serverHash', type: ['null', 'MD5'], 'default': null},\r\n    {name: 'meta', type: ['null', MAP_BYTES_TYPE], 'default': null}\r\n  ]\r\n}, OPTS);\r\n\r\n// Prefix used to differentiate between messages when sharing a stream. This\r\n// length should be smaller than 16. The remainder is used for disambiguating\r\n// between concurrent messages (the current value, 16, therefore supports ~64k\r\n// concurrent messages).\r\nvar PREFIX_LENGTH = 16;\r\n\r\n// Internal message, used to check protocol compatibility.\r\nvar PING_MESSAGE = new Message(\r\n  '', // Empty name (invalid for other \"normal\" messages).\r\n  Type.forSchema({name: 'PingRequest', type: 'record', fields: []}, OPTS),\r\n  Type.forSchema(['string'], OPTS),\r\n  Type.forSchema('null', OPTS)\r\n);\r\n\r\n/** An Avro message, containing its request, response, etc. */\r\nfunction Message(name, reqType, errType, resType, oneWay, doc) {\r\n  this.name = name;\r\n  if (!Type.isType(reqType, 'record')) {\r\n    throw new Error('invalid request type');\r\n  }\r\n  this.requestType = reqType;\r\n  if (\r\n    !Type.isType(errType, 'union') ||\r\n    !Type.isType(errType.getTypes()[0], 'string')\r\n  ) {\r\n    throw new Error('invalid error type');\r\n  }\r\n  this.errorType = errType;\r\n  if (oneWay) {\r\n    if (!Type.isType(resType, 'null') || errType.getTypes().length > 1) {\r\n      throw new Error('inapplicable one-way parameter');\r\n    }\r\n  }\r\n  this.responseType = resType;\r\n  this.oneWay = !!oneWay;\r\n  this.doc = doc !== undefined ? '' + doc : undefined;\r\n  Object.freeze(this);\r\n}\r\n\r\nMessage.forSchema = function (name, schema, opts) {\r\n  opts = opts || {};\r\n  if (!utils.isValidName(name)) {\r\n    throw new Error(f('invalid message name: %s', name));\r\n  }\r\n  // We use a record with a placeholder name here (the user might have set\r\n  // `noAnonymousTypes`, so we can't use an anonymous one). We remove it from\r\n  // the registry afterwards to avoid exposing it outside.\r\n  if (!Array.isArray(schema.request)) {\r\n    throw new Error(f('invalid message request: %s', name));\r\n  }\r\n  var recordName = f('%s.%sRequest', OPTS.namespace, utils.capitalize(name));\r\n  var reqType = Type.forSchema({\r\n    name: recordName,\r\n    type: 'record',\r\n    namespace: opts.namespace || '', // Don't leak request namespace.\r\n    fields: schema.request\r\n  }, opts);\r\n  delete opts.registry[recordName];\r\n  if (!schema.response) {\r\n    throw new Error(f('invalid message response: %s', name));\r\n  }\r\n  var resType = Type.forSchema(schema.response, opts);\r\n  if (schema.errors !== undefined && !Array.isArray(schema.errors)) {\r\n    throw new Error(f('invalid message errors: %s', name));\r\n  }\r\n  var errType = Type.forSchema(['string'].concat(schema.errors || []), opts);\r\n  var oneWay = !!schema['one-way'];\r\n  return new Message(name, reqType, errType, resType, oneWay, schema.doc);\r\n};\r\n\r\nMessage.prototype.schema = Type.prototype.getSchema;\r\n\r\nMessage.prototype._attrs = function (opts) {\r\n  var reqSchema = this.requestType._attrs(opts);\r\n  var schema = {\r\n    request: reqSchema.fields,\r\n    response: this.responseType._attrs(opts)\r\n  };\r\n  var msgDoc = this.doc;\r\n  if (msgDoc !== undefined) {\r\n    schema.doc = msgDoc;\r\n  }\r\n  var errSchema = this.errorType._attrs(opts);\r\n  if (errSchema.length > 1) {\r\n    schema.errors = errSchema.slice(1);\r\n  }\r\n  if (this.oneWay) {\r\n    schema['one-way'] = true;\r\n  }\r\n  return schema;\r\n};\r\n\r\n// Deprecated.\r\n\r\nutils.addDeprecatedGetters(\r\n  Message,\r\n  ['name', 'errorType', 'requestType', 'responseType']\r\n);\r\n\r\nMessage.prototype.isOneWay = util.deprecate(\r\n  function () { return this.oneWay; },\r\n  'use `.oneWay` directly instead of `.isOneWay()`'\r\n);\r\n\r\n/**\r\n * An Avro RPC service.\r\n *\r\n * This constructor shouldn't be called directly, but via the\r\n * `Service.forProtocol` method. This function performs little logic to better\r\n * support efficient copy.\r\n */\r\nfunction Service(name, messages, types, ptcl, server) {\r\n  if (typeof name != 'string') {\r\n    // Let's be helpful in case this class is instantiated directly.\r\n    return Service.forProtocol(name, messages);\r\n  }\r\n\r\n  this.name = name;\r\n  this._messagesByName = messages || {};\r\n  this.messages = Object.freeze(utils.objectValues(this._messagesByName));\r\n\r\n  this._typesByName = types || {};\r\n  this.types = Object.freeze(utils.objectValues(this._typesByName));\r\n\r\n  this.protocol = ptcl;\r\n  // We cache a string rather than a buffer to not retain an entire slab.\r\n  this._hashStr = utils.getHash(JSON.stringify(ptcl)).toString('binary');\r\n  this.doc = ptcl.doc ? '' + ptcl.doc : undefined;\r\n\r\n  // We add a server to each protocol for backwards-compatibility (to allow the\r\n  // use of `protocol.on`). This covers all cases except the use of the\r\n  // `strictErrors` option, which requires moving to the new API.\r\n  this._server = server || this.createServer({silent: true});\r\n  Object.freeze(this);\r\n}\r\n\r\nService.Client = Client;\r\n\r\nService.Server = Server;\r\n\r\nService.compatible = function (clientSvc, serverSvc) {\r\n  try {\r\n    createReaders(clientSvc, serverSvc);\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n  return true;\r\n};\r\n\r\nService.forProtocol = function (ptcl, opts) {\r\n  opts = opts || {};\r\n\r\n  var name = ptcl.protocol;\r\n  if (!name) {\r\n    throw new Error('missing protocol name');\r\n  }\r\n  if (ptcl.namespace !== undefined) {\r\n    opts.namespace = ptcl.namespace;\r\n  } else {\r\n    var match = /^(.*)\\.[^.]+$/.exec(name);\r\n    if (match) {\r\n      opts.namespace = match[1];\r\n    }\r\n  }\r\n  name = utils.qualify(name, opts.namespace);\r\n\r\n  if (ptcl.types) {\r\n    ptcl.types.forEach(function (obj) { Type.forSchema(obj, opts); });\r\n  }\r\n  var msgs;\r\n  if (ptcl.messages) {\r\n    msgs = {};\r\n    Object.keys(ptcl.messages).forEach(function (key) {\r\n      msgs[key] = Message.forSchema(key, ptcl.messages[key], opts);\r\n    });\r\n  }\r\n\r\n  return new Service(name, msgs, opts.registry, ptcl);\r\n};\r\n\r\nService.isService = function (any) {\r\n  // Not fool-proof but likely sufficient.\r\n  return !!any && any.hasOwnProperty('_hashStr');\r\n};\r\n\r\nService.prototype.createClient = function (opts) {\r\n  var client = new Client(this, opts);\r\n  process.nextTick(function () {\r\n    // We delay this processing such that we can attach handlers to the client\r\n    // before any channels get created.\r\n    if (opts && opts.server) {\r\n      // Convenience in-memory client. This can be useful to make requests\r\n      // relatively efficiently to an in-process server. Note that it is still\r\n      // is less efficient than direct method calls (because of the\r\n      // serialization, which does provide \"type-safety\" though).\r\n      var obj = {objectMode: true};\r\n      var pts = [new stream.PassThrough(obj), new stream.PassThrough(obj)];\r\n      opts.server.createChannel({readable: pts[0], writable: pts[1]}, obj);\r\n      client.createChannel({readable: pts[1], writable: pts[0]}, obj);\r\n    } else if (opts && opts.transport) {\r\n      // Convenience functionality for the common single channel use-case: we\r\n      // add a single channel using default options to the client.\r\n      client.createChannel(opts.transport);\r\n    }\r\n  });\r\n  return client;\r\n};\r\n\r\nService.prototype.createServer = function (opts) {\r\n  return new Server(this, opts);\r\n};\r\n\r\nObject.defineProperty(Service.prototype, 'hash', {\r\n  enumerable: true,\r\n  get: function () { return utils.bufferFrom(this._hashStr, 'binary'); }\r\n});\r\n\r\nService.prototype.message = function (name) {\r\n  return this._messagesByName[name];\r\n};\r\n\r\nService.prototype.type = function (name) {\r\n  return this._typesByName[name];\r\n};\r\n\r\nService.prototype.inspect = function () {\r\n  return f('<Service %j>', this.name);\r\n};\r\n\r\n// Deprecated methods.\r\n\r\nutils.addDeprecatedGetters(\r\n  Service,\r\n  ['message', 'messages', 'name', 'type', 'types']\r\n);\r\n\r\nService.prototype.createEmitter = util.deprecate(\r\n  function (transport, opts) {\r\n    opts = opts || {};\r\n    var client = this.createClient({\r\n      cache: opts.cache,\r\n      buffering: false,\r\n      strictTypes: opts.strictErrors,\r\n      timeout: opts.timeout\r\n    });\r\n    var channel = client.createChannel(transport, opts);\r\n    forwardErrors(client, channel);\r\n    return channel;\r\n  },\r\n  'use `.createClient()` instead of `.createEmitter()`'\r\n);\r\n\r\nService.prototype.createListener = util.deprecate(\r\n  function (transport, opts) {\r\n    if (opts && opts.strictErrors) {\r\n      throw new Error('use `.createServer()` to support strict errors');\r\n    }\r\n    return this._server.createChannel(transport, opts);\r\n  },\r\n  'use `.createServer().createChannel()` instead of `.createListener()`'\r\n);\r\n\r\nService.prototype.emit = util.deprecate(\r\n  function (name, req, channel, cb) {\r\n    if (!channel || !this.equals(channel.client._svc$)) {\r\n      throw new Error('invalid emitter');\r\n    }\r\n\r\n    var client = channel.client;\r\n    // In case the method is overridden.\r\n    Client.prototype.emitMessage.call(client, name, req, cb && cb.bind(this));\r\n    return channel.getPending();\r\n  },\r\n  'create a client via `.createClient()` to emit messages instead of `.emit()`'\r\n);\r\n\r\nService.prototype.equals = util.deprecate(\r\n  function (any) {\r\n    return (\r\n      Service.isService(any) &&\r\n      this.getFingerprint().equals(any.getFingerprint())\r\n    );\r\n  },\r\n  'equality testing is deprecated, compare the `.protocol`s instead'\r\n);\r\n\r\nService.prototype.getFingerprint = util.deprecate(\r\n  function (algorithm) {\r\n    return utils.getHash(JSON.stringify(this.protocol), algorithm);\r\n  },\r\n  'use `.hash` instead of `.getFingerprint()`'\r\n);\r\n\r\nService.prototype.getSchema = util.deprecate(\r\n  Type.prototype.getSchema,\r\n  'use `.protocol` instead of `.getSchema()`'\r\n);\r\n\r\nService.prototype.on = util.deprecate(\r\n  function (name, handler) {\r\n    var self = this; // This protocol.\r\n    this._server.onMessage(name, function (req, cb) {\r\n      return handler.call(self, req, this.channel, cb);\r\n    });\r\n    return this;\r\n  },\r\n  'use `.createServer().onMessage()` instead of `.on()`'\r\n);\r\n\r\nService.prototype.subprotocol = util.deprecate(\r\n  function () {\r\n    var parent = this._server;\r\n    var opts = {strictTypes: parent._strict, cache: parent._cache};\r\n    var server = new Server(parent.service, opts);\r\n    server._handlers = Object.create(parent._handlers);\r\n    return new Service(\r\n      this.name,\r\n      this._messagesByName,\r\n      this._typesByName,\r\n      this.protocol,\r\n      server\r\n    );\r\n  },\r\n  '`.subprotocol()` will be removed in 5.1'\r\n);\r\n\r\nService.prototype._attrs = function (opts) {\r\n  var ptcl = {protocol: this.name};\r\n\r\n  var types = [];\r\n  this.types.forEach(function (t) {\r\n    if (t.getName() === undefined) {\r\n      // Don't include any unnamed types (e.g. primitives).\r\n      return;\r\n    }\r\n    var typeSchema = t._attrs(opts);\r\n    if (typeof typeSchema != 'string') {\r\n      // Some of the named types might already have been defined in a\r\n      // previous type, in this case we don't include its reference.\r\n      types.push(typeSchema);\r\n    }\r\n  });\r\n  if (types.length) {\r\n    ptcl.types = types;\r\n  }\r\n\r\n  var msgNames = Object.keys(this._messagesByName);\r\n  if (msgNames.length) {\r\n    ptcl.messages = {};\r\n    msgNames.forEach(function (name) {\r\n      ptcl.messages[name] = this._messagesByName[name]._attrs(opts);\r\n    }, this);\r\n  }\r\n\r\n  if (opts && opts.exportAttrs && this.doc !== undefined) {\r\n    ptcl.doc = this.doc;\r\n  }\r\n  return ptcl;\r\n};\r\n\r\n/** Function to retrieve a remote service's protocol. */\r\nfunction discoverProtocol(transport, opts, cb) {\r\n  if (cb === undefined && typeof opts == 'function') {\r\n    cb = opts;\r\n    opts = undefined;\r\n  }\r\n\r\n  var svc = new Service({protocol: 'Empty'}, OPTS);\r\n  var ptclStr;\r\n  svc.createClient({timeout: opts && opts.timeout})\r\n    .createChannel(transport, {\r\n      scope: opts && opts.scope,\r\n      endWritable: typeof transport == 'function' // Stateless transports only.\r\n    }).once('handshake', function (hreq, hres) {\r\n        ptclStr = hres.serverProtocol;\r\n        this.destroy(true);\r\n      })\r\n      .once('eot', function (pending, err) {\r\n        // Stateless transports will throw an interrupted error when the\r\n        // channel is destroyed, we ignore it here.\r\n        if (err && !/interrupted/.test(err)) {\r\n          cb(err); // Likely timeout.\r\n        } else {\r\n          cb(null, JSON.parse(ptclStr));\r\n        }\r\n      });\r\n}\r\n\r\n/** Load-balanced message sender. */\r\nfunction Client(svc, opts) {\r\n  opts = opts || {};\r\n  events.EventEmitter.call(this);\r\n\r\n  // We have to suffix all client properties to be safe, since the message\r\n  // names aren't prefixed with clients (unlike servers).\r\n  this._svc$ = svc;\r\n  this._channels$ = []; // Active channels.\r\n  this._fns$ = []; // Middleware functions.\r\n\r\n  this._buffering$ = !!opts.buffering;\r\n  this._cache$ = opts.cache || {}; // For backwards compatibility.\r\n  this._policy$ = opts.channelPolicy;\r\n  this._strict$ = !!opts.strictTypes;\r\n  this._timeout$ = utils.getOption(opts, 'timeout', 10000);\r\n\r\n  if (opts.remoteProtocols) {\r\n    insertRemoteProtocols(this._cache$, opts.remoteProtocols, svc, true);\r\n  }\r\n\r\n  this._svc$.messages.forEach(function (msg) {\r\n    this[msg.name] = this._createMessageHandler$(msg);\r\n  }, this);\r\n}\r\nutil.inherits(Client, events.EventEmitter);\r\n\r\nClient.prototype.activeChannels = function () {\r\n  return this._channels$.slice();\r\n};\r\n\r\nClient.prototype.createChannel = function (transport, opts) {\r\n  var objectMode = opts && opts.objectMode;\r\n  var channel;\r\n  if (typeof transport == 'function') {\r\n    var writableFactory;\r\n    if (objectMode) {\r\n      writableFactory = transport;\r\n    } else {\r\n      // We provide a default standard-compliant codec. This should support\r\n      // most use-cases (for example when speaking to the official Java and\r\n      // Python implementations over HTTP, or when this library is used for\r\n      // both the emitting and listening sides).\r\n      writableFactory = function (cb) {\r\n        var encoder = new FrameEncoder();\r\n        var writable = transport(function (err, readable) {\r\n          if (err) {\r\n            cb(err);\r\n            return;\r\n          }\r\n          // Since the decoder isn't exposed (so can't have an error handler\r\n          // attached, we forward any errors to the client). Since errors would\r\n          // only get thrown when the decoder flushes (if there is trailing\r\n          // data), at which point the source will have ended, there is no need\r\n          // to add re-piping logic (destination errors trigger an unpipe).\r\n          var decoder = new FrameDecoder()\r\n            .once('error', function (err) { channel.destroy(err); });\r\n          cb(null, readable.pipe(decoder));\r\n        });\r\n        if (writable) {\r\n          encoder.pipe(writable);\r\n          return encoder;\r\n        }\r\n      };\r\n    }\r\n    channel = new StatelessClientChannel(this, writableFactory, opts);\r\n  } else {\r\n    var readable, writable;\r\n    if (isStream(transport)) {\r\n      readable = writable = transport;\r\n    } else {\r\n      readable = transport.readable;\r\n      writable = transport.writable;\r\n    }\r\n    if (!objectMode) {\r\n      // To ease communication with Java servers, we provide a default codec\r\n      // compatible with Java servers' `NettyTransportCodec`'s implementation.\r\n      var decoder = new NettyDecoder();\r\n      readable = readable.pipe(decoder);\r\n      var encoder = new NettyEncoder();\r\n      encoder.pipe(writable);\r\n      writable = encoder;\r\n    }\r\n    channel = new StatefulClientChannel(this, readable, writable, opts);\r\n    if (!objectMode) {\r\n      // Since we never expose the automatically created encoder and decoder,\r\n      // we release them ourselves here when the channel ends. (Unlike for\r\n      // stateless channels, it is conceivable for the underlying stream to be\r\n      // reused afterwards).\r\n      channel.once('eot', function () {\r\n        readable.unpipe(decoder);\r\n        encoder.unpipe(writable);\r\n      });\r\n      // We also forward any (trailing data) error.\r\n      decoder.once('error', function (err) { channel.destroy(err); });\r\n    }\r\n  }\r\n  var channels = this._channels$;\r\n  channels.push(channel);\r\n  channel.once('_drain', function () {\r\n    // Remove the channel from the list of active ones.\r\n    channels.splice(channels.indexOf(this), 1);\r\n  });\r\n  // We restrict buffering to startup, otherwise we risk silently hiding errors\r\n  // (especially since channel timeouts don't apply yet).\r\n  this._buffering$ = false;\r\n  this.emit('channel', channel);\r\n  return channel;\r\n};\r\n\r\nClient.prototype.destroyChannels = function (opts) {\r\n  this._channels$.forEach(function (channel) {\r\n    channel.destroy(opts && opts.noWait);\r\n  });\r\n};\r\n\r\nClient.prototype.emitMessage = function (name, req, opts, cb) {\r\n  var msg = getExistingMessage(this._svc$, name);\r\n  var wreq = new WrappedRequest(msg, {}, req);\r\n  this._emitMessage$(wreq, opts, cb);\r\n};\r\n\r\nClient.prototype.remoteProtocols = function () {\r\n  return getRemoteProtocols(this._cache$, true);\r\n};\r\n\r\nObject.defineProperty(Client.prototype, 'service', {\r\n  enumerable: true,\r\n  get: function () { return this._svc$; }\r\n});\r\n\r\nClient.prototype.use = function (/* fn ... */) {\r\n  var i, l, fn;\r\n  for (i = 0, l = arguments.length; i < l; i++) {\r\n    fn = arguments[i];\r\n    this._fns$.push(fn.length < 3 ? fn(this) : fn);\r\n  }\r\n  return this;\r\n};\r\n\r\nClient.prototype._emitMessage$ = function (wreq, opts, cb) {\r\n  // Common logic between `client.emitMessage` and the \"named\" message methods.\r\n  if (!cb && typeof opts === 'function') {\r\n    cb = opts;\r\n    opts = undefined;\r\n  }\r\n  var self = this;\r\n  var channels = this._channels$;\r\n  var numChannels = channels.length;\r\n  if (!numChannels) {\r\n    if (this._buffering$) {\r\n      debug('no active client channels, buffering call');\r\n      this.once('channel', function () {\r\n        this._emitMessage$(wreq, opts, cb);\r\n      });\r\n    } else {\r\n      var err = new Error('no active channels');\r\n      process.nextTick(function () {\r\n        if (cb) {\r\n          cb.call(new CallContext(wreq._msg), err);\r\n        } else {\r\n          self.emit('error', err);\r\n        }\r\n      });\r\n    }\r\n    return;\r\n  }\r\n\r\n  opts = opts || {};\r\n  if (opts.timeout === undefined) {\r\n    opts.timeout = this._timeout$;\r\n  }\r\n\r\n  var channel;\r\n  if (numChannels === 1) {\r\n    // Common case, optimized away.\r\n    channel = channels[0];\r\n  } else if (this._policy$) {\r\n    channel = this._policy$(this._channels$.slice());\r\n    if (!channel) {\r\n      debug('policy returned no channel, skipping call');\r\n      return;\r\n    }\r\n  } else {\r\n    // Random selection, cheap and likely good enough for most use-cases.\r\n    channel = channels[Math.floor(Math.random() * numChannels)];\r\n  }\r\n\r\n  channel._emit(wreq, opts, function (err, wres) {\r\n    var ctx = this; // Call context.\r\n    var errType = ctx.message.errorType;\r\n    if (err) {\r\n      // System error, likely the message wasn't sent (or an error occurred\r\n      // while decoding the response).\r\n      if (self._strict$) {\r\n        err = errType.clone(err.message, {wrapUnions: true});\r\n      }\r\n      done(err);\r\n      return;\r\n    }\r\n    if (!wres) {\r\n      // This is a one way message.\r\n      done();\r\n      return;\r\n    }\r\n    // Message transmission succeeded, we transmit the message data; massaging\r\n    // any error strings into actual `Error` objects in non-strict mode.\r\n    err = wres.error;\r\n    if (!self._strict$) {\r\n      // Try to coerce an eventual error into more idiomatic JavaScript types:\r\n      // `undefined` becomes `null` and a remote string \"system\" error is\r\n      // wrapped inside an actual `Error` object.\r\n      if (err === undefined) {\r\n        err = null;\r\n      } else {\r\n        if (Type.isType(errType, 'union:unwrapped')) {\r\n          if (typeof err == 'string') {\r\n            err = new Error(err);\r\n          }\r\n        } else if (err && err.string && typeof err.string == 'string') {\r\n          err = new Error(err.string);\r\n        }\r\n      }\r\n    }\r\n    done(err, wres.response);\r\n\r\n    function done(err, res) {\r\n      if (cb) {\r\n        cb.call(ctx, err, res);\r\n      } else if (err) {\r\n        self.emit('error', err);\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nClient.prototype._createMessageHandler$ = function (msg) {\r\n  // jshint -W054\r\n  var fields = msg.requestType.getFields();\r\n  var names = fields.map(function (f) { return f.getName(); });\r\n  var body = 'return function ' + msg.name + '(';\r\n  if (names.length) {\r\n    body += names.join(', ') + ', ';\r\n  }\r\n  body += 'opts, cb) {\\n';\r\n  body += '  var req = {';\r\n  body += names.map(function (n) { return n + ': ' + n; }).join(', ');\r\n  body += '};\\n';\r\n  body += '  return this.emitMessage(\\'' + msg.name + '\\', req, opts, cb);\\n';\r\n  body += '};';\r\n  return (new Function(body))();\r\n};\r\n\r\n/** Message receiver. */\r\nfunction Server(svc, opts) {\r\n  opts = opts || {};\r\n  events.EventEmitter.call(this);\r\n\r\n  this.service = svc;\r\n  this._handlers = {};\r\n  this._fns = []; // Middleware functions.\r\n  this._channels = {}; // Active channels.\r\n  this._nextChannelId = 1;\r\n\r\n  this._cache = opts.cache || {}; // Deprecated.\r\n  this._defaultHandler = opts.defaultHandler;\r\n  this._sysErrFormatter = opts.systemErrorFormatter;\r\n  this._silent = !!opts.silent;\r\n  this._strict = !!opts.strictTypes;\r\n\r\n  if (opts.remoteProtocols) {\r\n    insertRemoteProtocols(this._cache, opts.remoteProtocols, svc, false);\r\n  }\r\n\r\n  svc.messages.forEach(function (msg) {\r\n    var name = msg.name;\r\n    if (!opts.noCapitalize) {\r\n      name = utils.capitalize(name);\r\n    }\r\n    this['on' + name] = this._createMessageHandler(msg);\r\n  }, this);\r\n}\r\nutil.inherits(Server, events.EventEmitter);\r\n\r\nServer.prototype.activeChannels = function () {\r\n  return utils.objectValues(this._channels);\r\n};\r\n\r\nServer.prototype.createChannel = function (transport, opts) {\r\n  var objectMode = opts && opts.objectMode;\r\n  var channel;\r\n  if (typeof transport == 'function') {\r\n    var readableFactory;\r\n    if (objectMode) {\r\n      readableFactory = transport;\r\n    } else {\r\n      readableFactory = function (cb) {\r\n        var decoder = new FrameDecoder()\r\n          .once('error', function (err) { channel.destroy(err); });\r\n        return transport(function (err, writable) {\r\n          if (err) {\r\n            cb(err);\r\n            return;\r\n          }\r\n          var encoder = new FrameEncoder();\r\n          encoder.pipe(writable);\r\n          cb(null, encoder);\r\n        }).pipe(decoder);\r\n      };\r\n    }\r\n    channel = new StatelessServerChannel(this, readableFactory, opts);\r\n  } else {\r\n    var readable, writable;\r\n    if (isStream(transport)) {\r\n      readable = writable = transport;\r\n    } else {\r\n      readable = transport.readable;\r\n      writable = transport.writable;\r\n    }\r\n    if (!objectMode) {\r\n      var decoder = new NettyDecoder();\r\n      readable = readable.pipe(decoder);\r\n      var encoder = new NettyEncoder();\r\n      encoder.pipe(writable);\r\n      writable = encoder;\r\n    }\r\n    channel = new StatefulServerChannel(this, readable, writable, opts);\r\n    if (!objectMode) {\r\n      // Similar to client channels, since we never expose the encoder and\r\n      // decoder, we must release them ourselves here.\r\n      channel.once('eot', function () {\r\n        readable.unpipe(decoder);\r\n        encoder.unpipe(writable);\r\n      });\r\n      decoder.once('error', function (err) { channel.destroy(err); });\r\n    }\r\n  }\r\n\r\n  if (!this.listeners('error').length) {\r\n    this.on('error', this._onError);\r\n  }\r\n  var channelId = this._nextChannelId++;\r\n  var channels = this._channels;\r\n  channels[channelId] = channel\r\n    .once('eot', function () { delete channels[channelId]; });\r\n  this.emit('channel', channel);\r\n  return channel;\r\n};\r\n\r\nServer.prototype.onMessage = function (name, handler) {\r\n  getExistingMessage(this.service, name); // Check message existence.\r\n  this._handlers[name] = handler;\r\n  return this;\r\n};\r\n\r\nServer.prototype.remoteProtocols = function () {\r\n  return getRemoteProtocols(this._cache, false);\r\n};\r\n\r\nServer.prototype.use = function (/* fn ... */) {\r\n  var i, l, fn;\r\n  for (i = 0, l = arguments.length; i < l; i++) {\r\n    fn = arguments[i];\r\n    this._fns.push(fn.length < 3 ? fn(this) : fn);\r\n  }\r\n  return this;\r\n};\r\n\r\nServer.prototype._createMessageHandler = function (msg) {\r\n  // jshint -W054\r\n  var name = msg.name;\r\n  var fields = msg.requestType.fields;\r\n  var numArgs = fields.length;\r\n  var args = fields.length ?\r\n    ', ' + fields.map(function (f) { return 'req.' + f.name; }).join(', ') :\r\n    '';\r\n  // We are careful to not lose the initial handler's number of arguments (or\r\n  // more specifically whether it would have access to the callback or not).\r\n  // This is useful to implement \"smart promisification\" logic downstream.\r\n  var body = 'return function (handler) {\\n';\r\n  body += '  if (handler.length > ' + numArgs + ') {\\n';\r\n  body += '    return this.onMessage(\\'' + name + '\\', function (req, cb) {\\n';\r\n  body += '      return handler.call(this' + args + ', cb);\\n';\r\n  body += '    });\\n';\r\n  body += '  } else {\\n';\r\n  body += '    return this.onMessage(\\'' + name + '\\', function (req) {\\n';\r\n  body += '      return handler.call(this' + args + ');\\n';\r\n  body += '    });\\n';\r\n  body += '  }\\n';\r\n  body += '};\\n';\r\n  return (new Function(body))();\r\n};\r\n\r\nServer.prototype._onError = function (err) {\r\n  /* istanbul ignore if */\r\n  if (!this._silent && err.rpcCode !== 'UNKNOWN_PROTOCOL') {\r\n    console.error();\r\n    if (err.rpcCode) {\r\n      console.error(err.rpcCode);\r\n      console.error(err.cause);\r\n    } else {\r\n      console.error('INTERNAL_SERVER_ERROR');\r\n      console.error(err);\r\n    }\r\n  }\r\n};\r\n\r\n/** Base message emitter class. See below for the two available variants. */\r\nfunction ClientChannel(client, opts) {\r\n  opts = opts || {};\r\n  events.EventEmitter.call(this);\r\n\r\n  this.client = client;\r\n  this.timeout = utils.getOption(opts, 'timeout', client._timeout$);\r\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\r\n  this._prefix = normalizedPrefix(opts.scope);\r\n\r\n  var cache = client._cache$;\r\n  var clientSvc = client._svc$;\r\n  var hash = opts.serverHash;\r\n  if (!hash) {\r\n    hash = clientSvc.hash;\r\n  }\r\n  var adapter = cache[hash];\r\n  if (!adapter) {\r\n    // This might happen even if the server hash option was set if the cache\r\n    // doesn't contain the corresponding adapter. In this case we fall back to\r\n    // the client's protocol (as mandated by the spec).\r\n    hash = clientSvc.hash;\r\n    adapter = cache[hash] = new Adapter(clientSvc, clientSvc, hash);\r\n  }\r\n  this._adapter = adapter;\r\n\r\n  this._registry = new Registry(this, PREFIX_LENGTH);\r\n  this.pending = 0;\r\n  this.destroyed = false;\r\n  this.draining = false;\r\n  this.once('_eot', function (pending, err) {\r\n    // Since this listener is only run once, we will only forward an error if\r\n    // it is present during the initial `destroy` call, which is OK.\r\n    debug('client channel EOT');\r\n    this.destroyed = true;\r\n    this.emit('eot', pending, err);\r\n  });\r\n}\r\nutil.inherits(ClientChannel, events.EventEmitter);\r\n\r\nClientChannel.prototype.destroy = function (noWait) {\r\n  debug('destroying client channel');\r\n  if (!this.draining) {\r\n    this.draining = true;\r\n    this.emit('_drain');\r\n  }\r\n  var registry = this._registry;\r\n  var pending = this.pending;\r\n  if (noWait) {\r\n    registry.clear();\r\n  }\r\n  if (noWait || !pending) {\r\n    if (isError(noWait)) {\r\n      debug('fatal client channel error: %s', noWait);\r\n      this.emit('_eot', pending, noWait);\r\n    } else {\r\n      this.emit('_eot', pending);\r\n    }\r\n  } else {\r\n    debug('client channel entering drain mode (%s pending)', pending);\r\n  }\r\n};\r\n\r\nClientChannel.prototype.ping = function (timeout, cb) {\r\n  if (!cb && typeof timeout == 'function') {\r\n    cb = timeout;\r\n    timeout = undefined;\r\n  }\r\n  var self = this;\r\n  var wreq = new WrappedRequest(PING_MESSAGE);\r\n  this._emit(wreq, {timeout: timeout}, function (err) {\r\n    if (cb) {\r\n      cb.call(self, err);\r\n    } else if (err) {\r\n      self.destroy(err);\r\n    }\r\n  });\r\n};\r\n\r\nClientChannel.prototype._createHandshakeRequest = function (adapter, noSvc) {\r\n  var svc = this.client._svc$;\r\n  return {\r\n    clientHash: svc.hash,\r\n    clientProtocol: noSvc ? null : JSON.stringify(svc.protocol),\r\n    serverHash: adapter._hash\r\n  };\r\n};\r\n\r\nClientChannel.prototype._emit = function (wreq, opts, cb) {\r\n  var msg = wreq._msg;\r\n  var wres = msg.oneWay ? undefined : new WrappedResponse(msg, {});\r\n  var ctx = new CallContext(msg, this);\r\n  var self = this;\r\n  this.pending++;\r\n  process.nextTick(function () {\r\n    if (!msg.name) {\r\n      // Ping request, bypass middleware.\r\n      onTransition(wreq, wres, onCompletion);\r\n    } else {\r\n      self.emit('outgoingCall', ctx, opts);\r\n      var fns = self.client._fns$;\r\n      debug('starting client middleware chain (%s middleware)', fns.length);\r\n      chainMiddleware({\r\n        fns: fns,\r\n        ctx: ctx,\r\n        wreq: wreq,\r\n        wres: wres,\r\n        onTransition: onTransition,\r\n        onCompletion: onCompletion,\r\n        onError: onError\r\n      });\r\n    }\r\n  });\r\n\r\n  function onTransition(wreq, wres, prev) {\r\n    // Serialize the message.\r\n    var err, reqBuf;\r\n    if (self.destroyed) {\r\n      err = new Error('channel destroyed');\r\n    } else {\r\n      try {\r\n        reqBuf = wreq.toBuffer();\r\n      } catch (cause) {\r\n        err = serializationError(\r\n          f('invalid %j request', msg.name),\r\n          wreq,\r\n          [\r\n            {name: 'headers', type: MAP_BYTES_TYPE},\r\n            {name: 'request', type: msg.requestType}\r\n          ]\r\n        );\r\n      }\r\n    }\r\n    if (err) {\r\n      prev(err);\r\n      return;\r\n    }\r\n\r\n    // Generate the response callback.\r\n    var timeout = (opts && opts.timeout !== undefined) ?\r\n      opts.timeout :\r\n      self.timeout;\r\n    var id = self._registry.add(timeout, function (err, resBuf, adapter) {\r\n      if (!err && !msg.oneWay) {\r\n        try {\r\n          adapter._decodeResponse(resBuf, wres, msg);\r\n        } catch (cause) {\r\n          err = cause;\r\n        }\r\n      }\r\n      prev(err);\r\n    });\r\n    id |= self._prefix;\r\n\r\n    debug('sending message %s', id);\r\n    self._send(id, reqBuf, !!msg && msg.oneWay);\r\n  }\r\n\r\n  function onCompletion(err) {\r\n    self.pending--;\r\n    cb.call(ctx, err, wres);\r\n    if (self.draining && !self.destroyed && !self.pending) {\r\n      self.destroy();\r\n    }\r\n  }\r\n\r\n  function onError(err) {\r\n    // This will happen if a middleware callback is called multiple times. We\r\n    // forward the error to the client rather than emit it on the channel since\r\n    // middleware are a client-level abstraction, so better handled there.\r\n    self.client.emit('error', err, self);\r\n  }\r\n};\r\n\r\nClientChannel.prototype._getAdapter = function (hres) {\r\n  var hash = hres.serverHash;\r\n  var cache = this.client._cache$;\r\n  var adapter = cache[hash];\r\n  if (adapter) {\r\n    return adapter;\r\n  }\r\n  var ptcl = JSON.parse(hres.serverProtocol);\r\n  var serverSvc = Service.forProtocol(ptcl);\r\n  adapter = new Adapter(this.client._svc$, serverSvc, hash, true);\r\n  return cache[hash] = adapter;\r\n};\r\n\r\nClientChannel.prototype._matchesPrefix = function (id) {\r\n  return matchesPrefix(id, this._prefix);\r\n};\r\n\r\nClientChannel.prototype._send = utils.abstractFunction;\r\n\r\n// Deprecated.\r\n\r\nutils.addDeprecatedGetters(ClientChannel, ['pending', 'timeout']);\r\n\r\nClientChannel.prototype.getCache = util.deprecate(\r\n  function () { return this.client._cache$; },\r\n  'use `.remoteProtocols()` instead of `.getCache()`'\r\n);\r\n\r\nClientChannel.prototype.getProtocol = util.deprecate(\r\n  function () {\r\n    return this.client._svc$;\r\n  },\r\n  'use `.service` instead or `.getProtocol()`'\r\n);\r\n\r\nClientChannel.prototype.isDestroyed = util.deprecate(\r\n  function () { return this.destroyed; },\r\n  'use `.destroyed` instead of `.isDestroyed`'\r\n);\r\n\r\n/**\r\n * Factory-based client channel.\r\n *\r\n * This channel doesn't keep a persistent connection to the server and requires\r\n * prepending a handshake to each message emitted. Usage examples include\r\n * talking to an HTTP server (where the factory returns an HTTP request).\r\n *\r\n * Since each message will use its own writable/readable stream pair, the\r\n * advantage of this channel is that it is able to keep track of which response\r\n * corresponds to each request without relying on transport ordering. In\r\n * particular, this means these channels are compatible with any server\r\n * implementation.\r\n */\r\nfunction StatelessClientChannel(client, writableFactory, opts) {\r\n  ClientChannel.call(this, client, opts);\r\n  this._writableFactory = writableFactory;\r\n\r\n  if (!opts || !opts.noPing) {\r\n    // Ping the server to check whether the remote protocol is compatible.\r\n    // If not, this will throw an error on the channel.\r\n    debug('emitting ping request');\r\n    this.ping();\r\n  }\r\n}\r\nutil.inherits(StatelessClientChannel, ClientChannel);\r\n\r\nStatelessClientChannel.prototype._send = function (id, reqBuf) {\r\n  var cb = this._registry.get(id);\r\n  var adapter = this._adapter;\r\n  var self = this;\r\n  process.nextTick(emit);\r\n  return true;\r\n\r\n  function emit(retry) {\r\n    if (self.destroyed) {\r\n      // The request's callback will already have been called.\r\n      return;\r\n    }\r\n\r\n    var hreq = self._createHandshakeRequest(adapter, !retry);\r\n\r\n    var writable = self._writableFactory.call(self, function (err, readable) {\r\n      if (err) {\r\n        cb(err);\r\n        return;\r\n      }\r\n      readable.on('data', function (obj) {\r\n        debug('received response %s', obj.id);\r\n        // We don't check that the prefix matches since the ID likely hasn't\r\n        // been propagated to the response (see default stateless codec).\r\n        var buf = Buffer.concat(obj.payload);\r\n        try {\r\n          var parts = readHead(HANDSHAKE_RESPONSE_TYPE, buf);\r\n          var hres = parts.head;\r\n          if (hres.serverHash) {\r\n            adapter = self._getAdapter(hres);\r\n          }\r\n        } catch (cause) {\r\n          cb(cause);\r\n          return;\r\n        }\r\n        var match = hres.match;\r\n        debug('handshake match: %s', match);\r\n        self.emit('handshake', hreq, hres);\r\n        if (match === 'NONE') {\r\n          // Try again, including the full protocol this time.\r\n          process.nextTick(function() { emit(true); });\r\n        } else {\r\n          // Change the default adapter.\r\n          self._adapter = adapter;\r\n          cb(null, parts.tail, adapter);\r\n        }\r\n      });\r\n    });\r\n    if (!writable) {\r\n      cb(new Error('invalid writable stream'));\r\n      return;\r\n    }\r\n    writable.write({\r\n      id: id,\r\n      payload: [HANDSHAKE_REQUEST_TYPE.toBuffer(hreq), reqBuf]\r\n    });\r\n    if (self._endWritable) {\r\n      writable.end();\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Multiplexing client channel.\r\n *\r\n * These channels reuse the same streams (both readable and writable) for all\r\n * messages. This avoids a lot of overhead (e.g. creating new connections,\r\n * re-issuing handshakes) but requires the underlying transport to support\r\n * forwarding message IDs.\r\n */\r\nfunction StatefulClientChannel(client, readable, writable, opts) {\r\n  ClientChannel.call(this, client, opts);\r\n  this._readable = readable;\r\n  this._writable = writable;\r\n  this._connected = !!(opts && opts.noPing);\r\n  this._readable.on('end', onEnd);\r\n  this._writable.on('finish', onFinish);\r\n\r\n  var self = this;\r\n  var timer = null;\r\n  this.once('eot', function () {\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n      timer = null;\r\n    }\r\n    if (!self._connected) {\r\n      // Clear any buffered calls (they are guaranteed to error out when\r\n      // reaching the transition phase).\r\n      self.emit('_ready');\r\n    }\r\n    // Remove references to this channel to avoid potential memory leaks.\r\n    this._writable.removeListener('finish', onFinish);\r\n    if (this._endWritable) {\r\n      debug('ending transport');\r\n      this._writable.end();\r\n    }\r\n    this._readable\r\n      .removeListener('data', onPing)\r\n      .removeListener('data', onMessage)\r\n      .removeListener('end', onEnd);\r\n  });\r\n\r\n  var hreq; // For handshake events.\r\n  if (this._connected) {\r\n    this._readable.on('data', onMessage);\r\n  } else {\r\n    this._readable.on('data', onPing);\r\n    process.nextTick(ping);\r\n    if (self.timeout) {\r\n      timer = setTimeout(function () {\r\n        self.destroy(new Error('timeout'));\r\n      }, self.timeout);\r\n    }\r\n  }\r\n\r\n  function ping(retry) {\r\n    if (self.destroyed) {\r\n      return;\r\n    }\r\n    hreq = self._createHandshakeRequest(self._adapter, !retry);\r\n    var payload = [\r\n      HANDSHAKE_REQUEST_TYPE.toBuffer(hreq),\r\n      utils.bufferFrom([0, 0]) // No header, no data (empty message name).\r\n    ];\r\n    // We can use a static ID here since we are guaranteed that this message is\r\n    // the only one on the channel (for this scope at least).\r\n    self._writable.write({id: self._prefix, payload: payload});\r\n  }\r\n\r\n  function onPing(obj) {\r\n    if (!self._matchesPrefix(obj.id)) {\r\n      debug('discarding unscoped response %s (still connecting)', obj.id);\r\n      return;\r\n    }\r\n    var buf = Buffer.concat(obj.payload);\r\n    try {\r\n      var hres = readHead(HANDSHAKE_RESPONSE_TYPE, buf).head;\r\n      if (hres.serverHash) {\r\n        self._adapter = self._getAdapter(hres);\r\n      }\r\n    } catch (cause) {\r\n      // This isn't a recoverable error.\r\n      self.destroy(cause);\r\n      return;\r\n    }\r\n    var match = hres.match;\r\n    debug('handshake match: %s', match);\r\n    self.emit('handshake', hreq, hres);\r\n    if (match === 'NONE') {\r\n      process.nextTick(function () { ping(true); });\r\n    } else {\r\n      debug('successfully connected');\r\n      if (timer) {\r\n        clearTimeout(timer);\r\n        timer = null;\r\n      }\r\n      self._readable.removeListener('data', onPing).on('data', onMessage);\r\n      self._connected = true;\r\n      self.emit('_ready');\r\n      hreq = null; // Release reference.\r\n    }\r\n  }\r\n\r\n  // Callback used after a connection has been established.\r\n  function onMessage(obj) {\r\n    var id = obj.id;\r\n    if (!self._matchesPrefix(id)) {\r\n      debug('discarding unscoped message %s', id);\r\n      return;\r\n    }\r\n    var cb = self._registry.get(id);\r\n    if (cb) {\r\n      process.nextTick(function () {\r\n        debug('received message %s', id);\r\n        // Ensure that the initial callback gets called asynchronously, even\r\n        // for completely synchronous transports (otherwise the number of\r\n        // pending requests will sometimes be inconsistent between stateful and\r\n        // stateless transports).\r\n        cb(null, Buffer.concat(obj.payload), self._adapter);\r\n      });\r\n    }\r\n  }\r\n\r\n  function onEnd() { self.destroy(true); }\r\n  function onFinish() { self.destroy(); }\r\n}\r\nutil.inherits(StatefulClientChannel, ClientChannel);\r\n\r\nStatefulClientChannel.prototype._emit = function () {\r\n  // Override this method to allow calling `_emit` even before the channel is\r\n  // connected. Note that we don't perform this logic in `_send` since we want\r\n  // to guarantee that `'handshake'` events are emitted before any\r\n  // `'outgoingCall'` events.\r\n  if (this._connected || this.draining) {\r\n    ClientChannel.prototype._emit.apply(this, arguments);\r\n  } else {\r\n    debug('queuing request');\r\n    var args = [];\r\n    var i, l;\r\n    for (i = 0, l = arguments.length; i < l; i++) {\r\n      args.push(arguments[i]);\r\n    }\r\n    this.once('_ready', function () { this._emit.apply(this, args); });\r\n  }\r\n};\r\n\r\nStatefulClientChannel.prototype._send = function (id, reqBuf, oneWay) {\r\n  if (oneWay) {\r\n    var self = this;\r\n    // Clear the callback, passing in an empty header.\r\n    process.nextTick(function () {\r\n      self._registry.get(id)(null, utils.bufferFrom([0, 0, 0]), self._adapter);\r\n    });\r\n  }\r\n  return this._writable.write({id: id, payload: [reqBuf]});\r\n};\r\n\r\n/** The server-side emitter equivalent. */\r\nfunction ServerChannel(server, opts) {\r\n  opts = opts || {};\r\n  events.EventEmitter.call(this);\r\n\r\n  this.server = server;\r\n  this._endWritable = !!utils.getOption(opts, 'endWritable', true);\r\n  this._prefix = normalizedPrefix(opts.scope);\r\n\r\n  var cache = server._cache;\r\n  var svc = server.service;\r\n  var hash = svc.hash;\r\n  if (!cache[hash]) {\r\n    // Add the channel's protocol to the cache if it isn't already there. This\r\n    // will save a handshake the first time on channels with the same protocol.\r\n    cache[hash] = new Adapter(svc, svc, hash);\r\n  }\r\n  this._adapter = null;\r\n\r\n  this.destroyed = false;\r\n  this.draining = false;\r\n  this.pending = 0;\r\n  this.once('_eot', function (pending, err) {\r\n    debug('server channel EOT');\r\n    this.emit('eot', pending, err);\r\n  });\r\n}\r\nutil.inherits(ServerChannel, events.EventEmitter);\r\n\r\nServerChannel.prototype.destroy = function (noWait) {\r\n  if (!this.draining) {\r\n    this.draining = true;\r\n    this.emit('_drain');\r\n  }\r\n  if (noWait || !this.pending) {\r\n    this.destroyed = true;\r\n    if (isError(noWait)) {\r\n      debug('fatal server channel error: %s', noWait);\r\n      this.emit('_eot', this.pending, noWait);\r\n    } else {\r\n      this.emit('_eot', this.pending);\r\n    }\r\n  }\r\n};\r\n\r\nServerChannel.prototype._createHandshakeResponse = function (err, hreq) {\r\n  var svc = this.server.service;\r\n  var buf = svc.hash;\r\n  var serverMatch = hreq && hreq.serverHash.equals(buf);\r\n  return {\r\n    match: err ? 'NONE' : (serverMatch ? 'BOTH' : 'CLIENT'),\r\n    serverProtocol: serverMatch ? null : JSON.stringify(svc.protocol),\r\n    serverHash: serverMatch ? null : buf\r\n  };\r\n};\r\n\r\nServerChannel.prototype._getAdapter = function (hreq) {\r\n  var hash = hreq.clientHash;\r\n  var adapter = this.server._cache[hash];\r\n  if (adapter) {\r\n    return adapter;\r\n  }\r\n  if (!hreq.clientProtocol) {\r\n    throw toRpcError('UNKNOWN_PROTOCOL');\r\n  }\r\n  var ptcl = JSON.parse(hreq.clientProtocol);\r\n  var clientSvc = Service.forProtocol(ptcl);\r\n  adapter = new Adapter(clientSvc, this.server.service, hash, true);\r\n  return this.server._cache[hash] = adapter;\r\n};\r\n\r\nServerChannel.prototype._matchesPrefix = function (id) {\r\n  return matchesPrefix(id, this._prefix);\r\n};\r\n\r\nServerChannel.prototype._receive = function (reqBuf, adapter, cb) {\r\n  var self = this;\r\n  var wreq;\r\n  try {\r\n    wreq = adapter._decodeRequest(reqBuf);\r\n  } catch (cause) {\r\n    cb(self._encodeSystemError(toRpcError('INVALID_REQUEST', cause)));\r\n    return;\r\n  }\r\n\r\n  var msg = wreq._msg;\r\n  var wres = new WrappedResponse(msg, {});\r\n  if (!msg.name) {\r\n    // Ping message, we don't invoke middleware logic in this case.\r\n    wres.response = null;\r\n    cb(wres.toBuffer(), false);\r\n    return;\r\n  }\r\n\r\n  var ctx = new CallContext(msg, this);\r\n  self.emit('incomingCall', ctx);\r\n  var fns = this.server._fns;\r\n  debug('starting server middleware chain (%s middleware)', fns.length);\r\n  self.pending++;\r\n  chainMiddleware({\r\n    fns: fns,\r\n    ctx: ctx,\r\n    wreq: wreq,\r\n    wres: wres,\r\n    onTransition: onTransition,\r\n    onCompletion: onCompletion,\r\n    onError: onError\r\n  });\r\n\r\n  function onTransition(wreq, wres, prev) {\r\n    var handler = self.server._handlers[msg.name];\r\n    if (!handler) {\r\n      // The underlying service hasn't implemented a handler.\r\n      var defaultHandler = self.server._defaultHandler;\r\n      if (defaultHandler) {\r\n        // We call the default handler with arguments similar (slightly\r\n        // simpler, there are no phases here) to middleware such that it can\r\n        // easily access the message name (useful to implement proxies).\r\n        defaultHandler.call(ctx, wreq, wres, prev);\r\n      } else {\r\n        var cause = new Error(f('no handler for %s', msg.name));\r\n        prev(toRpcError('NOT_IMPLEMENTED', cause));\r\n      }\r\n    } else {\r\n      var pending = !msg.oneWay;\r\n      try {\r\n        if (pending) {\r\n          handler.call(ctx, wreq.request, function (err, res) {\r\n            pending = false;\r\n            wres.error = err;\r\n            wres.response = res;\r\n            prev();\r\n          });\r\n        } else {\r\n          handler.call(ctx, wreq.request);\r\n          prev();\r\n        }\r\n      } catch (err) {\r\n        // We catch synchronous failures (same as express) and return the\r\n        // failure. Note that the server process can still crash if an error\r\n        // is thrown after the handler returns but before the response is\r\n        // sent (again, same as express). We are careful to only trigger the\r\n        // response callback once, emitting the errors afterwards instead.\r\n        if (pending) {\r\n          pending = false;\r\n          prev(err);\r\n        } else {\r\n          onError(err);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function onCompletion(err) {\r\n    self.pending--;\r\n    var server = self.server;\r\n    var resBuf;\r\n    if (!err) {\r\n      var resErr = wres.error;\r\n      var isStrict = server._strict;\r\n      if (!isStrict) {\r\n        if (isError(resErr)) {\r\n          // If the error type is wrapped, we must wrap the error too.\r\n          wres.error = msg.errorType.clone(resErr.message, {wrapUnions: true});\r\n        } else if (resErr === null) {\r\n          // We also allow `null`'s as error in this mode, converting them to\r\n          // the Avro-compatible `undefined`.\r\n          resErr = wres.error = undefined;\r\n        }\r\n        if (\r\n          resErr === undefined &&\r\n          wres.response === undefined &&\r\n          msg.responseType.isValid(null)\r\n        ) {\r\n          // Finally, for messages with `null` as acceptable response type, we\r\n          // allow `undefined`; converting them to `null`. This allows users to\r\n          // write a more natural `cb()` instead of `cb(null, null)`.\r\n          wres.response = null;\r\n        }\r\n      }\r\n      try {\r\n        resBuf = wres.toBuffer();\r\n      } catch (cause) {\r\n        // Note that we don't add an RPC code here such that the client\r\n        // receives the default `INTERNAL_SERVER_ERROR` one.\r\n        if (wres.error !== undefined) {\r\n          err = serializationError(\r\n            f('invalid %j error', msg.name), // Sic.\r\n            wres,\r\n            [\r\n              {name: 'headers', type: MAP_BYTES_TYPE},\r\n              {name: 'error', type: msg.errorType}\r\n            ]\r\n          );\r\n        } else {\r\n          err = serializationError(\r\n            f('invalid %j response', msg.name),\r\n            wres,\r\n            [\r\n              {name: 'headers', type: MAP_BYTES_TYPE},\r\n              {name: 'response', type: msg.responseType}\r\n            ]\r\n          );\r\n        }\r\n      }\r\n    }\r\n    if (!resBuf) {\r\n      // The headers are only available if the message isn't one-way.\r\n      resBuf = self._encodeSystemError(err, wres.headers);\r\n    } else if (resErr !== undefined) {\r\n      server.emit('error', toRpcError('APPLICATION_ERROR', resErr));\r\n    }\r\n    cb(resBuf, msg.oneWay);\r\n    if (self.draining && !self.pending) {\r\n      self.destroy();\r\n    }\r\n  }\r\n\r\n  function onError(err) {\r\n    // Similar to the client equivalent, we redirect this error to the server\r\n    // since middleware are defined at server-level.\r\n    self.server.emit('error', err, self);\r\n  }\r\n};\r\n\r\n// Deprecated.\r\n\r\nutils.addDeprecatedGetters(ServerChannel, ['pending']);\r\n\r\nServerChannel.prototype.getCache = util.deprecate(\r\n  function () { return this.server._cache; },\r\n  'use `.remoteProtocols()` instead of `.getCache()`'\r\n);\r\n\r\nServerChannel.prototype.getProtocol = util.deprecate(\r\n  function () {\r\n    return this.server.service;\r\n  },\r\n  'use `.service` instead of `.getProtocol()`'\r\n);\r\n\r\nServerChannel.prototype.isDestroyed = util.deprecate(\r\n  function () { return this.destroyed; },\r\n  'use `.destroyed` instead of `.isDestroyed`'\r\n);\r\n\r\n/**\r\n * Encode an error and optional header into a valid Avro response.\r\n *\r\n * @param err {Error} Error to encode.\r\n * @param header {Object} Optional response header.\r\n */\r\nServerChannel.prototype._encodeSystemError = function (err, header) {\r\n  var server = this.server;\r\n  server.emit('error', err, this);\r\n  var errStr;\r\n  if (server._sysErrFormatter) {\r\n    // Format the error into a string to send over the wire.\r\n    errStr = server._sysErrFormatter.call(this, err);\r\n  } else if (err.rpcCode) {\r\n    // By default, only forward the error's message when the RPC code is set\r\n    // (i.e. when this isn't an internal server error).\r\n    errStr = err.message;\r\n  }\r\n  var hdrBuf;\r\n  if (header) {\r\n    try {\r\n      // Propagate the header if possible.\r\n      hdrBuf = MAP_BYTES_TYPE.toBuffer(header);\r\n    } catch (cause) {\r\n      server.emit('error', cause, this);\r\n    }\r\n  }\r\n  return Buffer.concat([\r\n    hdrBuf || utils.bufferFrom([0]),\r\n    utils.bufferFrom([1, 0]), // Error flag and first union index.\r\n    STRING_TYPE.toBuffer(errStr || 'internal server error')\r\n  ]);\r\n};\r\n\r\n/**\r\n * Server channel for stateless transport.\r\n *\r\n * This channel expect a handshake to precede each message.\r\n */\r\nfunction StatelessServerChannel(server, readableFactory, opts) {\r\n  ServerChannel.call(this, server, opts);\r\n\r\n  this._writable = undefined;\r\n  var self = this;\r\n  var readable;\r\n\r\n  process.nextTick(function () {\r\n    // Delay listening to allow handlers to be attached even if the factory is\r\n    // purely synchronous.\r\n    readable = readableFactory.call(self, function (err, writable) {\r\n      process.nextTick(function () {\r\n        // We delay once more here in case this call is synchronous, to allow\r\n        // the readable to always be populated first.\r\n        if (err) {\r\n          onFinish(err);\r\n          return;\r\n        }\r\n        self._writable = writable.on('finish', onFinish);\r\n        self.emit('_writable');\r\n      });\r\n    }).on('data', onRequest).on('end', onEnd);\r\n  });\r\n\r\n\r\n  function onRequest(obj) {\r\n    var id = obj.id;\r\n    var buf = Buffer.concat(obj.payload);\r\n    var err;\r\n    try {\r\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\r\n      var hreq = parts.head;\r\n      var adapter = self._getAdapter(hreq);\r\n    } catch (cause) {\r\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\r\n    }\r\n\r\n    var hres = self._createHandshakeResponse(err, hreq);\r\n    self.emit('handshake', hreq, hres);\r\n    if (err) {\r\n      done(self._encodeSystemError(err));\r\n    } else {\r\n      self._receive(parts.tail, adapter, done);\r\n    }\r\n\r\n    function done(resBuf) {\r\n      if (!self.destroyed) {\r\n        if (!self._writable) {\r\n          self.once('_writable', function () { done(resBuf); });\r\n          return;\r\n        }\r\n        self._writable.write({\r\n          id: id,\r\n          payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\r\n        });\r\n      }\r\n      if (self._writable && self._endWritable) {\r\n        self._writable.end();\r\n      }\r\n    }\r\n  }\r\n\r\n  function onEnd() { self.destroy(); }\r\n\r\n  function onFinish(err) {\r\n    readable\r\n      .removeListener('data', onRequest)\r\n      .removeListener('end', onEnd);\r\n    self.destroy(err || true);\r\n  }\r\n}\r\nutil.inherits(StatelessServerChannel, ServerChannel);\r\n\r\n/**\r\n * Stateful transport listener.\r\n *\r\n * A handshake is done when the channel first receives a message, then all\r\n * messages are sent without.\r\n */\r\nfunction StatefulServerChannel(server, readable, writable, opts) {\r\n  ServerChannel.call(this, server, opts);\r\n  this._adapter = undefined;\r\n  this._writable = writable.on('finish', onFinish);\r\n  this._readable = readable.on('data', onHandshake).on('end', onEnd);\r\n\r\n  this\r\n    .once('_drain', function () {\r\n      // Stop listening to incoming events.\r\n      this._readable\r\n        .removeListener('data', onHandshake)\r\n        .removeListener('data', onRequest)\r\n        .removeListener('end', onEnd);\r\n    })\r\n    .once('eot', function () {\r\n      // Clean up any references to the channel on the underlying streams.\r\n      this._writable.removeListener('finish', onFinish);\r\n      if (this._endWritable) {\r\n        this._writable.end();\r\n      }\r\n    });\r\n\r\n  var self = this;\r\n\r\n  function onHandshake(obj) {\r\n    var id = obj.id;\r\n    if (!self._matchesPrefix(id)) {\r\n      return;\r\n    }\r\n    var buf = Buffer.concat(obj.payload);\r\n    var err;\r\n    try {\r\n      var parts = readHead(HANDSHAKE_REQUEST_TYPE, buf);\r\n      var hreq = parts.head;\r\n      self._adapter = self._getAdapter(hreq);\r\n    } catch (cause) {\r\n      err = toRpcError('INVALID_HANDSHAKE_REQUEST', cause);\r\n    }\r\n    var hres = self._createHandshakeResponse(err, hreq);\r\n    self.emit('handshake', hreq, hres);\r\n    if (err) {\r\n      // Either the client's protocol was unknown or it isn't compatible.\r\n      done(self._encodeSystemError(err));\r\n    } else {\r\n      self._readable\r\n        .removeListener('data', onHandshake)\r\n        .on('data', onRequest);\r\n      self._receive(parts.tail, self._adapter, done);\r\n    }\r\n\r\n    function done(resBuf) {\r\n      if (self.destroyed) {\r\n        return;\r\n      }\r\n      self._writable.write({\r\n        id: id,\r\n        payload: [HANDSHAKE_RESPONSE_TYPE.toBuffer(hres), resBuf]\r\n      });\r\n    }\r\n  }\r\n\r\n  function onRequest(obj) {\r\n    // These requests are not prefixed with handshakes.\r\n    var id = obj.id;\r\n    if (!self._matchesPrefix(id)) {\r\n      return;\r\n    }\r\n    var reqBuf = Buffer.concat(obj.payload);\r\n    self._receive(reqBuf, self._adapter, function (resBuf, oneWay) {\r\n      if (self.destroyed || oneWay) {\r\n        return;\r\n      }\r\n      self._writable.write({id: id, payload: [resBuf]});\r\n    });\r\n  }\r\n\r\n  function onEnd() { self.destroy(); }\r\n\r\n  function onFinish() { self.destroy(true); }\r\n}\r\nutil.inherits(StatefulServerChannel, ServerChannel);\r\n\r\n// Helpers.\r\n\r\n/** Enhanced request, used inside forward middleware functions. */\r\nfunction WrappedRequest(msg, hdrs, req) {\r\n  this._msg = msg;\r\n  this.headers = hdrs || {};\r\n  this.request = req || {};\r\n}\r\n\r\nWrappedRequest.prototype.toBuffer = function () {\r\n  var msg = this._msg;\r\n  return Buffer.concat([\r\n    MAP_BYTES_TYPE.toBuffer(this.headers),\r\n    STRING_TYPE.toBuffer(msg.name),\r\n    msg.requestType.toBuffer(this.request)\r\n  ]);\r\n};\r\n\r\n/** Enhanced response, used inside forward middleware functions. */\r\nfunction WrappedResponse(msg, hdr, err, res) {\r\n  this._msg = msg;\r\n  this.headers = hdr;\r\n  this.error = err;\r\n  this.response = res;\r\n}\r\n\r\nWrappedResponse.prototype.toBuffer = function () {\r\n  var hdr = MAP_BYTES_TYPE.toBuffer(this.headers);\r\n  var hasError = this.error !== undefined;\r\n  return Buffer.concat([\r\n    hdr,\r\n    BOOLEAN_TYPE.toBuffer(hasError),\r\n    hasError ?\r\n      this._msg.errorType.toBuffer(this.error) :\r\n      this._msg.responseType.toBuffer(this.response)\r\n  ]);\r\n};\r\n\r\n/**\r\n * Context for all middleware and handlers.\r\n *\r\n * It exposes a `locals` object which can be used to pass information between\r\n * each other during a given call.\r\n */\r\nfunction CallContext(msg, channel) {\r\n  this.channel = channel;\r\n  this.locals = {};\r\n  this.message = msg;\r\n  Object.freeze(this);\r\n}\r\n\r\n/**\r\n * Callback registry.\r\n *\r\n * Callbacks added must accept an error as first argument. This is used by\r\n * client channels to store pending calls. This class isn't exposed by the\r\n * public API.\r\n */\r\nfunction Registry(ctx, prefixLength) {\r\n  this._ctx = ctx; // Context for all callbacks.\r\n  this._mask = ~0 >>> (prefixLength | 0); // 16 bits by default.\r\n  this._id = 0; // Unique integer ID for each call.\r\n  this._n = 0; // Number of pending calls.\r\n  this._cbs = {};\r\n}\r\n\r\nRegistry.prototype.get = function (id) { return this._cbs[id & this._mask]; };\r\n\r\nRegistry.prototype.add = function (timeout, fn) {\r\n  this._id = (this._id + 1) & this._mask;\r\n\r\n  var self = this;\r\n  var id = this._id;\r\n  var timer;\r\n  if (timeout > 0) {\r\n    timer = setTimeout(function () { cb(new Error('timeout')); }, timeout);\r\n  }\r\n\r\n  this._cbs[id] = cb;\r\n  this._n++;\r\n  return id;\r\n\r\n  function cb() {\r\n    if (!self._cbs[id]) {\r\n      // The callback has already run.\r\n      return;\r\n    }\r\n    delete self._cbs[id];\r\n    self._n--;\r\n    if (timer) {\r\n      clearTimeout(timer);\r\n    }\r\n    fn.apply(self._ctx, arguments);\r\n  }\r\n};\r\n\r\nRegistry.prototype.clear = function () {\r\n  Object.keys(this._cbs).forEach(function (id) {\r\n    this._cbs[id](new Error('interrupted'));\r\n  }, this);\r\n};\r\n\r\n/**\r\n * Service resolution helper.\r\n *\r\n * It is used both by client and server channels, to respectively decode errors\r\n * and responses, or requests.\r\n */\r\nfunction Adapter(clientSvc, serverSvc, hash, isRemote) {\r\n  this._clientSvc = clientSvc;\r\n  this._serverSvc = serverSvc;\r\n  this._hash = hash; // Convenience to access it when creating handshakes.\r\n  this._isRemote = !!isRemote;\r\n  this._readers = createReaders(clientSvc, serverSvc);\r\n}\r\n\r\nAdapter.prototype._decodeRequest = function (buf) {\r\n  var tap = new Tap(buf);\r\n  var hdr = MAP_BYTES_TYPE._read(tap);\r\n  var name = STRING_TYPE._read(tap);\r\n  var msg, req;\r\n  if (name) {\r\n    msg = this._serverSvc.message(name);\r\n    req = this._readers[name + '?']._read(tap);\r\n  } else {\r\n    msg = PING_MESSAGE;\r\n  }\r\n  if (!tap.isValid()) {\r\n    throw new Error(f('truncated %s request', name || 'ping$'));\r\n  }\r\n  return new WrappedRequest(msg, hdr, req);\r\n};\r\n\r\nAdapter.prototype._decodeResponse = function (buf, wres, msg) {\r\n  var tap = new Tap(buf);\r\n  utils.copyOwnProperties(MAP_BYTES_TYPE._read(tap), wres.headers, true);\r\n  var isError = BOOLEAN_TYPE._read(tap);\r\n  var name = msg.name;\r\n  if (name) {\r\n    var reader = this._readers[name + (isError ? '*' : '!')];\r\n    msg = this._clientSvc.message(name);\r\n    if (isError) {\r\n      wres.error = reader._read(tap);\r\n    } else {\r\n      wres.response = reader._read(tap);\r\n    }\r\n    if (!tap.isValid()) {\r\n      throw new Error(f('truncated %s response', name));\r\n    }\r\n  } else {\r\n    msg = PING_MESSAGE;\r\n  }\r\n};\r\n\r\n/** Standard \"un-framing\" stream. */\r\nfunction FrameDecoder() {\r\n  stream.Transform.call(this, {readableObjectMode: true});\r\n  this._id = undefined;\r\n  this._buf = utils.newBuffer(0);\r\n  this._bufs = [];\r\n\r\n  this.on('finish', function () { this.push(null); });\r\n}\r\nutil.inherits(FrameDecoder, stream.Transform);\r\n\r\nFrameDecoder.prototype._transform = function (buf, encoding, cb) {\r\n  buf = Buffer.concat([this._buf, buf]);\r\n  var frameLength;\r\n  while (\r\n    buf.length >= 4 &&\r\n    buf.length >= (frameLength = buf.readInt32BE(0)) + 4\r\n  ) {\r\n    if (frameLength) {\r\n      this._bufs.push(buf.slice(4, frameLength + 4));\r\n    } else {\r\n      var bufs = this._bufs;\r\n      this._bufs = [];\r\n      this.push({id: null, payload: bufs});\r\n    }\r\n    buf = buf.slice(frameLength + 4);\r\n  }\r\n  this._buf = buf;\r\n  cb();\r\n};\r\n\r\nFrameDecoder.prototype._flush = function (cb) {\r\n  if (this._buf.length || this._bufs.length) {\r\n    var bufs = this._bufs.slice();\r\n    bufs.unshift(this._buf);\r\n    var err = toRpcError('TRAILING_DATA');\r\n    // Attach the data to help debugging (e.g. if the encoded bytes contain a\r\n    // human-readable protocol like HTTP).\r\n    err.trailingData = Buffer.concat(bufs).toString();\r\n    this.emit('error', err);\r\n  }\r\n  cb();\r\n};\r\n\r\n/** Standard framing stream. */\r\nfunction FrameEncoder() {\r\n  stream.Transform.call(this, {writableObjectMode: true});\r\n  this.on('finish', function () { this.push(null); });\r\n}\r\nutil.inherits(FrameEncoder, stream.Transform);\r\n\r\nFrameEncoder.prototype._transform = function (obj, encoding, cb) {\r\n  var bufs = obj.payload;\r\n  var i, l, buf;\r\n  for (i = 0, l = bufs.length; i < l; i++) {\r\n    buf = bufs[i];\r\n    this.push(intBuffer(buf.length));\r\n    this.push(buf);\r\n  }\r\n  this.push(intBuffer(0));\r\n  cb();\r\n};\r\n\r\n/** Netty-compatible decoding stream. */\r\nfunction NettyDecoder() {\r\n  stream.Transform.call(this, {readableObjectMode: true});\r\n  this._id = undefined;\r\n  this._frameCount = 0;\r\n  this._buf = utils.newBuffer(0);\r\n  this._bufs = [];\r\n\r\n  this.on('finish', function () { this.push(null); });\r\n}\r\nutil.inherits(NettyDecoder, stream.Transform);\r\n\r\nNettyDecoder.prototype._transform = function (buf, encoding, cb) {\r\n  buf = Buffer.concat([this._buf, buf]);\r\n\r\n  while (true) {\r\n    if (this._id === undefined) {\r\n      if (buf.length < 8) {\r\n        this._buf = buf;\r\n        cb();\r\n        return;\r\n      }\r\n      this._id = buf.readInt32BE(0);\r\n      this._frameCount = buf.readInt32BE(4);\r\n      buf = buf.slice(8);\r\n    }\r\n\r\n    var frameLength;\r\n    while (\r\n      this._frameCount &&\r\n      buf.length >= 4 &&\r\n      buf.length >= (frameLength = buf.readInt32BE(0)) + 4\r\n    ) {\r\n      this._frameCount--;\r\n      this._bufs.push(buf.slice(4, frameLength + 4));\r\n      buf = buf.slice(frameLength + 4);\r\n    }\r\n\r\n    if (this._frameCount) {\r\n      this._buf = buf;\r\n      cb();\r\n      return;\r\n    } else {\r\n      var obj = {id: this._id, payload: this._bufs};\r\n      this._bufs = [];\r\n      this._id = undefined;\r\n      this.push(obj);\r\n    }\r\n  }\r\n};\r\n\r\nNettyDecoder.prototype._flush = FrameDecoder.prototype._flush;\r\n\r\n/** Netty-compatible encoding stream. */\r\nfunction NettyEncoder() {\r\n  stream.Transform.call(this, {writableObjectMode: true});\r\n  this.on('finish', function () { this.push(null); });\r\n}\r\nutil.inherits(NettyEncoder, stream.Transform);\r\n\r\nNettyEncoder.prototype._transform = function (obj, encoding, cb) {\r\n  var bufs = obj.payload;\r\n  var l = bufs.length;\r\n  var buf;\r\n  // Header: [ ID, number of frames ]\r\n  buf = utils.newBuffer(8);\r\n  buf.writeInt32BE(obj.id, 0);\r\n  buf.writeInt32BE(l, 4);\r\n  this.push(buf);\r\n  // Frames, each: [ length, bytes ]\r\n  var i;\r\n  for (i = 0; i < l; i++) {\r\n    buf = bufs[i];\r\n    this.push(intBuffer(buf.length));\r\n    this.push(buf);\r\n  }\r\n  cb();\r\n};\r\n\r\n/**\r\n * Returns a buffer containing an integer's big-endian representation.\r\n *\r\n * @param n {Number} Integer.\r\n */\r\nfunction intBuffer(n) {\r\n  var buf = utils.newBuffer(4);\r\n  buf.writeInt32BE(n);\r\n  return buf;\r\n}\r\n\r\n/**\r\n * Decode a type used as prefix inside a buffer.\r\n *\r\n * @param type {Type} The type of the prefix.\r\n * @param buf {Buffer} Encoded bytes.\r\n *\r\n * This function will return an object `{head, tail}` where head contains the\r\n * decoded value and tail the rest of the buffer. An error will be thrown if\r\n * the prefix cannot be decoded.\r\n */\r\nfunction readHead(type, buf) {\r\n  var tap = new Tap(buf);\r\n  var head = type._read(tap);\r\n  if (!tap.isValid()) {\r\n    throw new Error(f('truncated %j', type.schema()));\r\n  }\r\n  return {head: head, tail: tap.buf.slice(tap.pos)};\r\n}\r\n\r\n/**\r\n * Generate a decoder, optimizing the case where reader and writer are equal.\r\n *\r\n * @param rtype {Type} Reader's type.\r\n * @param wtype {Type} Writer's type.\r\n */\r\nfunction createReader(rtype, wtype) {\r\n  return rtype.equals(wtype) ? rtype : rtype.createResolver(wtype);\r\n}\r\n\r\n/**\r\n * Generate all readers for a given protocol combination.\r\n *\r\n * @param clientSvc {Service} Client service.\r\n * @param serverSvc {Service} Client service.\r\n */\r\nfunction createReaders(clientSvc, serverSvc) {\r\n  var obj = {};\r\n  clientSvc.messages.forEach(function (c) {\r\n    var n = c.name;\r\n    var s = serverSvc.message(n);\r\n    try {\r\n      if (!s) {\r\n        throw new Error(f('missing server message: %s', n));\r\n      }\r\n      if (s.oneWay !== c.oneWay) {\r\n        throw new Error(f('inconsistent one-way message: %s', n));\r\n      }\r\n      obj[n + '?'] = createReader(s.requestType, c.requestType);\r\n      obj[n + '*'] = createReader(c.errorType, s.errorType);\r\n      obj[n + '!'] = createReader(c.responseType, s.responseType);\r\n    } catch (cause) {\r\n      throw toRpcError('INCOMPATIBLE_PROTOCOL', cause);\r\n    }\r\n  });\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Populate a cache from a list of protocols.\r\n *\r\n * @param cache {Object} Cache of adapters.\r\n * @param svc {Service} The local service (either client or server).\r\n * @param ptcls {Array} Array of protocols to insert.\r\n * @param isClient {Boolean} Whether the local service is a client's or\r\n * server's.\r\n */\r\nfunction insertRemoteProtocols(cache, ptcls, svc, isClient) {\r\n  Object.keys(ptcls).forEach(function (hash) {\r\n    var ptcl = ptcls[hash];\r\n    var clientSvc, serverSvc;\r\n    if (isClient) {\r\n      clientSvc = svc;\r\n      serverSvc = Service.forProtocol(ptcl);\r\n    } else {\r\n      clientSvc = Service.forProtocol(ptcl);\r\n      serverSvc = svc;\r\n    }\r\n    cache[hash] = new Adapter(clientSvc, serverSvc, hash, true);\r\n  });\r\n}\r\n\r\n/**\r\n * Extract remote protocols from a cache\r\n *\r\n * @param cache {Object} Cache of adapters.\r\n * @param isClient {Boolean} Whether the remote protocols extracted should be\r\n * the servers' or clients'.\r\n */\r\nfunction getRemoteProtocols(cache, isClient) {\r\n  var ptcls = {};\r\n  Object.keys(cache).forEach(function (hs) {\r\n    var adapter = cache[hs];\r\n    if (adapter._isRemote) {\r\n      var svc = isClient ? adapter._serverSvc : adapter._clientSvc;\r\n      ptcls[hs] = svc.protocol;\r\n    }\r\n  });\r\n  return ptcls;\r\n}\r\n\r\n/**\r\n * Check whether something is an `Error`.\r\n *\r\n * @param any {Object} Any object.\r\n */\r\nfunction isError(any) {\r\n  // Also not ideal, but avoids brittle `instanceof` checks.\r\n  return !!any && Object.prototype.toString.call(any) === '[object Error]';\r\n}\r\n\r\n/**\r\n * Forward any errors emitted on the source to the destination.\r\n *\r\n * @param src {EventEmitter} The initial source of error events.\r\n * @param dst {EventEmitter} The new target of the source's error events. The\r\n * original source will be provided as second argument (the error being the\r\n * first).\r\n *\r\n * As a convenience, the source will be returned.\r\n */\r\nfunction forwardErrors(src, dst) {\r\n  return src.on('error', function (err) {\r\n    dst.emit('error', err, src);\r\n  });\r\n}\r\n\r\n/**\r\n * Create an error.\r\n *\r\n * @param msg {String} Error message.\r\n * @param cause {Error} The cause of the error. It is available as `cause`\r\n * field on the outer error.\r\n */\r\nfunction toError(msg, cause) {\r\n  var err = new Error(msg);\r\n  err.cause = cause;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Mark an error.\r\n *\r\n * @param rpcCode {String} Code representing the failure.\r\n * @param cause {Error} The cause of the error. It is available as `cause`\r\n * field on the outer error.\r\n *\r\n * This is used to keep the argument of channels' `'error'` event errors.\r\n */\r\nfunction toRpcError(rpcCode, cause) {\r\n  var err = toError(rpcCode.toLowerCase().replace(/_/g, ' '), cause);\r\n  err.rpcCode = (cause && cause.rpcCode) ? cause.rpcCode : rpcCode;\r\n  return err;\r\n}\r\n\r\n/**\r\n * Provide a helpful error to identify why serialization failed.\r\n *\r\n * @param err {Error} The error to decorate.\r\n * @param obj {...} The object containing fields to validated.\r\n * @param fields {Array} Information about the fields to validate.\r\n */\r\nfunction serializationError(msg, obj, fields) {\r\n  var details = [];\r\n  var i, l, field;\r\n  for (i = 0, l = fields.length; i < l; i++) {\r\n    field = fields[i];\r\n    field.type.isValid(obj[field.name], {errorHook: errorHook});\r\n  }\r\n  var detailsStr = details\r\n    .map(function (obj) {\r\n      return f('%s = %j but expected %s', obj.path, obj.value, obj.type);\r\n    })\r\n    .join(', ');\r\n  var err = new Error(f('%s (%s)', msg, detailsStr));\r\n  err.details = details;\r\n  return err;\r\n\r\n  function errorHook(parts, any, type) {\r\n    var strs = [];\r\n    var i, l, part;\r\n    for (i = 0, l = parts.length; i < l; i++) {\r\n      part = parts[i];\r\n      if (isNaN(part)) {\r\n        strs.push('.' + part);\r\n      } else {\r\n        strs.push('[' + part + ']');\r\n      }\r\n    }\r\n    details.push({\r\n      path: field.name + strs.join(''),\r\n      value: any,\r\n      type: type\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Compute a prefix of fixed length from a string.\r\n *\r\n * @param scope {String} Namespace to be hashed.\r\n */\r\nfunction normalizedPrefix(scope) {\r\n  return scope ?\r\n    utils.getHash(scope).readInt16BE(0) << (32 - PREFIX_LENGTH) :\r\n    0;\r\n}\r\n\r\n/**\r\n * Check whether an ID matches the prefix.\r\n *\r\n * @param id {Integer} Number to check.\r\n * @param prefix {Integer} Already shifted prefix.\r\n */\r\nfunction matchesPrefix(id, prefix) {\r\n  return ((id ^ prefix) >> (32 - PREFIX_LENGTH)) === 0;\r\n}\r\n\r\n/**\r\n * Check whether something is a stream.\r\n *\r\n * @param any {Object} Any object.\r\n */\r\nfunction isStream(any) {\r\n  // This is a hacky way of checking that the transport is a stream-like\r\n  // object. We unfortunately can't use `instanceof Stream` checks since\r\n  // some libraries (e.g. websocket-stream) return streams which don't\r\n  // inherit from it.\r\n  return !!(any && any.pipe);\r\n}\r\n\r\n/**\r\n * Get a message, asserting that it exists.\r\n *\r\n * @param svc {Service} The protocol to look into.\r\n * @param name {String} The message's name.\r\n */\r\nfunction getExistingMessage(svc, name) {\r\n  var msg = svc.message(name);\r\n  if (!msg) {\r\n    throw new Error(f('unknown message: %s', name));\r\n  }\r\n  return msg;\r\n}\r\n\r\n/**\r\n * Middleware logic.\r\n *\r\n * This is used both in clients and servers to intercept call handling (e.g. to\r\n * populate headers, do access control).\r\n *\r\n * @param params {Object} The following parameters:\r\n *  + fns {Array} Array of middleware functions.\r\n *  + ctx {Object} Context used to call the middleware functions, onTransition,\r\n *    and onCompletion.\r\n *  + wreq {WrappedRequest}\r\n *  + wres {WrappedResponse}\r\n *  + onTransition {Function} End of forward phase callback. It accepts an\r\n *    eventual error as single argument. This will be used for the backward\r\n *    phase. This function is guaranteed to be called at most once.\r\n *  + onCompletion {Function} Final handler, it takes an error as unique\r\n *    argument. This function is guaranteed to be only at most once.\r\n *  + onError {Function} Error handler, called if an intermediate callback is\r\n *    called multiple times.\r\n */\r\nfunction chainMiddleware(params) {\r\n  var args = [params.wreq, params.wres];\r\n  var cbs = [];\r\n  var cause; // Backpropagated error.\r\n  forward(0);\r\n\r\n  function forward(pos) {\r\n    var isDone = false;\r\n    if (pos < params.fns.length) {\r\n      params.fns[pos].apply(params.ctx, args.concat(function (err, cb) {\r\n        if (isDone) {\r\n          params.onError(toError('duplicate forward middleware call', err));\r\n          return;\r\n        }\r\n        isDone = true;\r\n        if (\r\n          err || (\r\n            params.wres && ( // Non one-way messages.\r\n              params.wres.error !== undefined ||\r\n              params.wres.response !== undefined\r\n            )\r\n          )\r\n        ) {\r\n          // Stop the forward phase, bypass the handler, and start the backward\r\n          // phase. Note that we ignore any callback argument in this case.\r\n          cause = err;\r\n          backward();\r\n          return;\r\n        }\r\n        if (cb) {\r\n          cbs.push(cb);\r\n        }\r\n        forward(++pos);\r\n      }));\r\n    } else {\r\n      // Done with the middleware forward functions, call the handler.\r\n      params.onTransition.apply(params.ctx, args.concat(function (err) {\r\n        if (isDone) {\r\n          params.onError(toError('duplicate handler call', err));\r\n          return;\r\n        }\r\n        isDone = true;\r\n        cause = err;\r\n        process.nextTick(backward);\r\n      }));\r\n    }\r\n  }\r\n\r\n  function backward() {\r\n    var cb = cbs.pop();\r\n    if (cb) {\r\n      var isDone = false;\r\n      cb.call(params.ctx, cause, function (err) {\r\n        if (isDone) {\r\n          params.onError(toError('duplicate backward middleware call', err));\r\n          return;\r\n        }\r\n        // Substitute the error.\r\n        cause = err;\r\n        isDone = true;\r\n        backward();\r\n      });\r\n    } else {\r\n      // Done with all middleware calls.\r\n      params.onCompletion.call(params.ctx, cause);\r\n    }\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  Adapter: Adapter,\r\n  HANDSHAKE_REQUEST_TYPE: HANDSHAKE_REQUEST_TYPE,\r\n  HANDSHAKE_RESPONSE_TYPE: HANDSHAKE_RESPONSE_TYPE,\r\n  Message: Message,\r\n  Registry: Registry,\r\n  Service: Service,\r\n  discoverProtocol: discoverProtocol,\r\n  streams: {\r\n    FrameDecoder: FrameDecoder,\r\n    FrameEncoder: FrameEncoder,\r\n    NettyDecoder: NettyDecoder,\r\n    NettyEncoder: NettyEncoder\r\n  }\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/services.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/specs.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/specs.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* jshint node: true */\r\n\r\n// TODO: Add minimal templating.\r\n// TODO: Add option to prefix nested type declarations with the outer types'\r\n// names.\r\n\r\n\r\n\r\n/** IDL to protocol (services) and schema (types) parsing logic. */\r\n\r\nvar files = __webpack_require__(/*! ./files */ \"./node_modules/avsc/etc/browser/lib/files.js\"),\r\n    utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    path = __webpack_require__(/*! path */ \"./node_modules/path/path.js\"),\r\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\n\r\n\r\nvar f = util.format;\r\n\r\n\r\n// Default type references defined by Avro.\r\nvar TYPE_REFS = {\r\n  date: {type: 'int', logicalType: 'date'},\r\n  decimal: {type: 'bytes', logicalType: 'decimal'},\r\n  time_ms: {type: 'long', logicalType: 'time-millis'},\r\n  timestamp_ms: {type: 'long', logicalType: 'timestamp-millis'}\r\n};\r\n\r\n\r\n/** Assemble an IDL file into a decoded protocol. */\r\nfunction assembleProtocol(fpath, opts, cb) {\r\n  if (!cb && typeof opts == 'function') {\r\n    cb = opts;\r\n    opts = undefined;\r\n  }\r\n  opts = opts || {};\r\n  if (!opts.importHook) {\r\n    opts.importHook = files.createImportHook();\r\n  }\r\n\r\n  importFile(fpath, function (err, protocol) {\r\n    if (err) {\r\n      cb(err);\r\n      return;\r\n    }\r\n    if (!protocol) {\r\n      cb(new Error('empty root import'));\r\n      return;\r\n    }\r\n    var schemas = protocol.types;\r\n    if (schemas) {\r\n      // Strip redundant namespaces from types before returning the protocol.\r\n      // Note that we keep empty (`''`) nested namespaces when the outer one is\r\n      // non-empty. This allows figuring out whether unqualified imported names\r\n      // should be qualified by the protocol's namespace: they should if their\r\n      // namespace is `undefined` and should not if it is empty.\r\n      var namespace = protocolNamespace(protocol) || '';\r\n      schemas.forEach(function (schema) {\r\n        if (schema.namespace === namespace) {\r\n          delete schema.namespace;\r\n        }\r\n      });\r\n    }\r\n    cb(null, protocol);\r\n  });\r\n\r\n  function importFile(fpath, cb) {\r\n    opts.importHook(fpath, 'idl', function (err, str) {\r\n      if (err) {\r\n        cb(err);\r\n        return;\r\n      }\r\n      if (str === undefined) {\r\n        // This signals an already imported file by the default import hooks.\r\n        // Implementors who wish to disallow duplicate imports should provide a\r\n        // custom hook which throws an error when a duplicate is detected.\r\n        cb();\r\n        return;\r\n      }\r\n      try {\r\n        var reader = new Reader(str, opts);\r\n        var obj = reader._readProtocol(str, opts);\r\n      } catch (err) {\r\n        err.path = fpath; // To help debug which file caused the error.\r\n        cb(err);\r\n        return;\r\n      }\r\n      fetchImports(obj.protocol, obj.imports, path.dirname(fpath), cb);\r\n    });\r\n  }\r\n\r\n  function fetchImports(protocol, imports, dpath, cb) {\r\n    var importedProtocols = [];\r\n    next();\r\n\r\n    function next() {\r\n      var info = imports.shift();\r\n      if (!info) {\r\n        // We are done with this file. We prepend all imported types to this\r\n        // file's and we can return the final result.\r\n        importedProtocols.reverse();\r\n        try {\r\n          importedProtocols.forEach(function (imported) {\r\n            mergeImport(protocol, imported);\r\n          });\r\n        } catch (err) {\r\n          cb(err);\r\n          return;\r\n        }\r\n        cb(null, protocol);\r\n        return;\r\n      }\r\n      var importPath = path.join(dpath, info.name);\r\n      if (info.kind === 'idl') {\r\n        importFile(importPath, function (err, imported) {\r\n          if (err) {\r\n            cb(err);\r\n            return;\r\n          }\r\n          if (imported) {\r\n            importedProtocols.push(imported);\r\n          }\r\n          next();\r\n        });\r\n      } else {\r\n        // We are importing a protocol or schema file.\r\n        opts.importHook(importPath, info.kind, function (err, str) {\r\n          if (err) {\r\n            cb(err);\r\n            return;\r\n          }\r\n          switch (info.kind) {\r\n            case 'protocol':\r\n            case 'schema':\r\n              if (str === undefined) {\r\n                // Skip duplicate import (see related comment above).\r\n                next();\r\n                return;\r\n              }\r\n              try {\r\n                var obj = JSON.parse(str);\r\n              } catch (err) {\r\n                err.path = importPath;\r\n                cb(err);\r\n                return;\r\n              }\r\n              var imported = info.kind === 'schema' ? {types: [obj]} : obj;\r\n              importedProtocols.push(imported);\r\n              next();\r\n              return;\r\n            default:\r\n              cb(new Error(f('invalid import kind: %s', info.kind)));\r\n          }\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  function mergeImport(protocol, imported) {\r\n    // Merge first the types (where we don't need to check for duplicates\r\n    // since instantiating the service will take care of it), then the messages\r\n    // (where we need to, as duplicates will overwrite each other).\r\n    var schemas = imported.types || [];\r\n    schemas.reverse();\r\n    schemas.forEach(function (schema) {\r\n      if (!protocol.types) {\r\n        protocol.types = [];\r\n      }\r\n      // Ensure the imported protocol's namespace is inherited correctly (it\r\n      // might be different from the current one).\r\n      if (schema.namespace === undefined) {\r\n        schema.namespace = protocolNamespace(imported) || '';\r\n      }\r\n      protocol.types.unshift(schema);\r\n    });\r\n    Object.keys(imported.messages || {}).forEach(function (name) {\r\n      if (!protocol.messages) {\r\n        protocol.messages = {};\r\n      }\r\n      if (protocol.messages[name]) {\r\n        throw new Error(f('duplicate message: %s', name));\r\n      }\r\n      protocol.messages[name] = imported.messages[name];\r\n    });\r\n  }\r\n}\r\n\r\n// Parsing functions.\r\n\r\n/**\r\n * Convenience function to parse multiple inputs into protocols and schemas.\r\n *\r\n * It should cover most basic use-cases but has a few limitations:\r\n *\r\n * + It doesn't allow passing options to the parsing step.\r\n * + The protocol/type inference logic can be deceived.\r\n *\r\n * The parsing logic is as follows:\r\n *\r\n * + If `str` contains `path.sep` (on windows `\\`, otherwise `/`) and is a path\r\n *   to an existing file, it will first be read as JSON, then as an IDL\r\n *   specification if JSON parsing failed. If either succeeds, the result is\r\n *   returned, otherwise the next steps are run using the file's content\r\n *   instead of the input path.\r\n * + If `str` is a valid JSON string, it is parsed then returned.\r\n * + If `str` is a valid IDL protocol specification, it is parsed and returned\r\n *   if no imports are present (and an error is thrown if there are any\r\n *   imports).\r\n * + If `str` is a valid IDL type specification, it is parsed and returned.\r\n * + If neither of the above cases apply, `str` is returned.\r\n */\r\nfunction read(str) {\r\n  var schema;\r\n  if (typeof str == 'string' && ~str.indexOf(path.sep) && files.existsSync(str)) {\r\n    // Try interpreting `str` as path to a file contain a JSON schema or an IDL\r\n    // protocol. Note that we add the second check to skip primitive references\r\n    // (e.g. `\"int\"`, the most common use-case for `avro.parse`).\r\n    var contents = files.readFileSync(str, {encoding: 'utf8'});\r\n    try {\r\n      return JSON.parse(contents);\r\n    } catch (err) {\r\n      var opts = {importHook: files.createSyncImportHook()};\r\n      assembleProtocol(str, opts, function (err, protocolSchema) {\r\n        schema = err ? contents : protocolSchema;\r\n      });\r\n    }\r\n  } else {\r\n    schema = str;\r\n  }\r\n  if (typeof schema != 'string' || schema === 'null') {\r\n    // This last predicate is to allow `read('null')` to work similarly to\r\n    // `read('int')` and other primitives (null needs to be handled separately\r\n    // since it is also a valid JSON identifier).\r\n    return schema;\r\n  }\r\n  try {\r\n    return JSON.parse(schema);\r\n  } catch (err) {\r\n    try {\r\n      return Reader.readProtocol(schema);\r\n    } catch (err) {\r\n      try {\r\n        return Reader.readSchema(schema);\r\n      } catch (err) {\r\n        return schema;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction Reader(str, opts) {\r\n  opts = opts || {};\r\n\r\n  this._tk = new Tokenizer(str);\r\n  this._ackVoidMessages = !!opts.ackVoidMessages;\r\n  this._implicitTags = !opts.delimitedCollections;\r\n  this._typeRefs = opts.typeRefs || TYPE_REFS;\r\n}\r\n\r\nReader.readProtocol = function (str, opts) {\r\n  var reader = new Reader(str, opts);\r\n  var protocol = reader._readProtocol();\r\n  if (protocol.imports.length) {\r\n    // Imports can only be resolved when the IDL file is provided via its\r\n    // path, we fail rather than silently ignore imports.\r\n    throw new Error('unresolvable import');\r\n  }\r\n  return protocol.protocol;\r\n};\r\n\r\nReader.readSchema = function (str, opts) {\r\n  var reader = new Reader(str, opts);\r\n  var doc = reader._readJavadoc();\r\n  var schema = reader._readType(doc === undefined ? {} : {doc: doc}, true);\r\n  reader._tk.next({id: '(eof)'}); // Check that we have read everything.\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readProtocol = function () {\r\n  var tk = this._tk;\r\n  var imports = [];\r\n  var types = [];\r\n  var messages = {};\r\n  var pos;\r\n\r\n  // Outer declarations (outside of the protocol block).\r\n  this._readImports(imports);\r\n  var protocolSchema = {};\r\n  var protocolJavadoc = this._readJavadoc();\r\n  if (protocolJavadoc !== undefined) {\r\n    protocolSchema.doc = protocolJavadoc;\r\n  }\r\n  this._readAnnotations(protocolSchema);\r\n  tk.next({val: 'protocol'});\r\n  if (!tk.next({val: '{', silent: true})) {\r\n    // Named protocol.\r\n    protocolSchema.protocol = tk.next({id: 'name'}).val;\r\n    tk.next({val: '{'});\r\n  }\r\n\r\n  // Inner declarations.\r\n  while (!tk.next({val: '}', silent: true})) {\r\n    if (!this._readImports(imports)) {\r\n      var javadoc = this._readJavadoc();\r\n      var typeSchema = this._readType({}, true);\r\n      var numImports = this._readImports(imports, true);\r\n      var message = undefined;\r\n      // We mark our position and try to parse a message from here.\r\n      pos = tk.pos;\r\n      if (!numImports && (message = this._readMessage(typeSchema))) {\r\n        // Note that if any imports were found, we cannot be parsing a message.\r\n        if (javadoc !== undefined && message.schema.doc === undefined) {\r\n          message.schema.doc = javadoc;\r\n        }\r\n        var oneWay = false;\r\n        if (\r\n          message.schema.response === 'void' ||\r\n          message.schema.response.type === 'void'\r\n        ) {\r\n          oneWay = !this._ackVoidMessages && !message.schema.errors;\r\n          if (message.schema.response === 'void') {\r\n            message.schema.response = 'null';\r\n          } else {\r\n            message.schema.response.type = 'null';\r\n          }\r\n        }\r\n        if (oneWay) {\r\n          message.schema['one-way'] = true;\r\n        }\r\n        if (messages[message.name]) {\r\n          // We have to do this check here otherwise the duplicate will be\r\n          // overwritten (and service instantiation won't be able to catch it).\r\n          throw new Error(f('duplicate message: %s', message.name));\r\n        }\r\n        messages[message.name] = message.schema;\r\n      } else {\r\n        // This was a standalone type definition.\r\n        if (javadoc) {\r\n          if (typeof typeSchema == 'string') {\r\n            typeSchema = {doc: javadoc, type: typeSchema};\r\n          } else if (typeSchema.doc === undefined) {\r\n            typeSchema.doc = javadoc;\r\n          }\r\n        }\r\n        types.push(typeSchema);\r\n        // We backtrack until just before the type's type name and swallow an\r\n        // eventual semi-colon (to make type declarations more consistent).\r\n        tk.pos = pos;\r\n        tk.next({val: ';', silent: true});\r\n      }\r\n      javadoc = undefined;\r\n    }\r\n  }\r\n  tk.next({id: '(eof)'});\r\n  if (types.length) {\r\n    protocolSchema.types = types;\r\n  }\r\n  if (Object.keys(messages).length) {\r\n    protocolSchema.messages = messages;\r\n  }\r\n  return {protocol: protocolSchema, imports: imports};\r\n};\r\n\r\nReader.prototype._readAnnotations = function (schema) {\r\n  var tk = this._tk;\r\n  while (tk.next({val: '@', silent: true})) {\r\n    // Annotations are allowed to have names which aren't valid Avro names,\r\n    // we must advance until we hit the first left parenthesis.\r\n    var parts = [];\r\n    while (!tk.next({val: '(', silent: true})) {\r\n      parts.push(tk.next().val);\r\n    }\r\n    schema[parts.join('')] = tk.next({id: 'json'}).val;\r\n    tk.next({val: ')'});\r\n  }\r\n};\r\n\r\nReader.prototype._readMessage = function (responseSchema) {\r\n  var tk = this._tk;\r\n  var schema = {request: [], response: responseSchema};\r\n  this._readAnnotations(schema);\r\n  var name = tk.next().val;\r\n  if (tk.next().val !== '(') {\r\n    // This isn't a message.\r\n    return;\r\n  }\r\n  if (!tk.next({val: ')', silent: true})) {\r\n    do {\r\n      schema.request.push(this._readField());\r\n    } while (!tk.next({val: ')', silent: true}) && tk.next({val: ','}));\r\n  }\r\n  var token = tk.next();\r\n  switch (token.val) {\r\n    case 'throws':\r\n      // It doesn't seem like the IDL is explicit about which syntax to used\r\n      // for multiple errors. We will assume a comma-separated list.\r\n      schema.errors = [];\r\n      do {\r\n        schema.errors.push(this._readType());\r\n      } while (!tk.next({val: ';', silent: true}) && tk.next({val: ','}));\r\n      break;\r\n    case 'oneway':\r\n      schema['one-way'] = true;\r\n      tk.next({val: ';'});\r\n      break;\r\n    case ';':\r\n      break;\r\n    default:\r\n      throw tk.error('invalid message suffix', token);\r\n  }\r\n  return {name: name, schema: schema};\r\n};\r\n\r\nReader.prototype._readJavadoc = function () {\r\n  var token = this._tk.next({id: 'javadoc', emitJavadoc: true, silent: true});\r\n  if (token) {\r\n    return token.val;\r\n  }\r\n};\r\n\r\nReader.prototype._readField = function () {\r\n  var tk = this._tk;\r\n  var javadoc = this._readJavadoc();\r\n  var schema = {type: this._readType()};\r\n  if (javadoc !== undefined && schema.doc === undefined) {\r\n    schema.doc = javadoc;\r\n  }\r\n  this._readAnnotations(schema);\r\n  schema.name = tk.next({id: 'name'}).val;\r\n  if (tk.next({val: '=', silent: true})) {\r\n    schema['default'] = tk.next({id: 'json'}).val;\r\n  }\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readType = function (schema, top) {\r\n  schema = schema || {};\r\n  this._readAnnotations(schema);\r\n  schema.type = this._tk.next({id: 'name'}).val;\r\n  switch (schema.type) {\r\n    case 'record':\r\n    case 'error':\r\n      return this._readRecord(schema);\r\n    case 'fixed':\r\n      return this._readFixed(schema);\r\n    case 'enum':\r\n      return this._readEnum(schema, top);\r\n    case 'map':\r\n      return this._readMap(schema);\r\n    case 'array':\r\n      return this._readArray(schema);\r\n    case 'union':\r\n      if (Object.keys(schema).length > 1) {\r\n        throw new Error('union annotations are not supported');\r\n      }\r\n      return this._readUnion();\r\n    default:\r\n      // Reference.\r\n      var ref = this._typeRefs[schema.type];\r\n      if (ref) {\r\n        delete schema.type; // Always overwrite the type.\r\n        utils.copyOwnProperties(ref, schema);\r\n      }\r\n      return Object.keys(schema).length > 1 ? schema : schema.type;\r\n  }\r\n};\r\n\r\nReader.prototype._readFixed = function (schema) {\r\n  var tk = this._tk;\r\n  if (!tk.next({val: '(', silent: true})) {\r\n    schema.name = tk.next({id: 'name'}).val;\r\n    tk.next({val: '('});\r\n  }\r\n  schema.size = parseInt(tk.next({id: 'number'}).val);\r\n  tk.next({val: ')'});\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readMap = function (schema) {\r\n  var tk = this._tk;\r\n  // Brackets are unwieldy when declaring inline types. We allow for them to be\r\n  // omitted (but we keep the consistency that if the entry bracket is present,\r\n  // the exit one must be as well). Note that this is non-standard.\r\n  var silent = this._implicitTags;\r\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\r\n  schema.values = this._readType();\r\n  tk.next({val: '>', silent: implicitTags});\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readArray = function (schema) {\r\n  var tk = this._tk;\r\n  var silent = this._implicitTags;\r\n  var implicitTags = tk.next({val: '<', silent: silent}) === undefined;\r\n  schema.items = this._readType();\r\n  tk.next({val: '>', silent: implicitTags});\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readEnum = function (schema, top) {\r\n  var tk = this._tk;\r\n  if (!tk.next({val: '{', silent: true})) {\r\n    schema.name = tk.next({id: 'name'}).val;\r\n    tk.next({val: '{'});\r\n  }\r\n  schema.symbols = [];\r\n  do {\r\n    schema.symbols.push(tk.next().val);\r\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\r\n  // To avoid confusing syntax, reader enums (i.e. enums with a default value)\r\n  // can only be defined top-level.\r\n  if (top && tk.next({val: '=', silent: true})) {\r\n    schema.default = tk.next().val;\r\n    tk.next({val: ';'});\r\n  }\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readUnion = function () {\r\n  var tk = this._tk;\r\n  var arr = [];\r\n  tk.next({val: '{'});\r\n  do {\r\n    arr.push(this._readType());\r\n  } while (!tk.next({val: '}', silent: true}) && tk.next({val: ','}));\r\n  return arr;\r\n};\r\n\r\nReader.prototype._readRecord = function (schema) {\r\n  var tk = this._tk;\r\n  if (!tk.next({val: '{', silent: true})) {\r\n    schema.name = tk.next({id: 'name'}).val;\r\n    tk.next({val: '{'});\r\n  }\r\n  schema.fields = [];\r\n  while (!tk.next({val: '}', silent: true})) {\r\n    schema.fields.push(this._readField());\r\n    tk.next({val: ';'});\r\n  }\r\n  return schema;\r\n};\r\n\r\nReader.prototype._readImports = function (imports, maybeMessage) {\r\n  var tk = this._tk;\r\n  var numImports = 0;\r\n  var pos = tk.pos;\r\n  while (tk.next({val: 'import', silent: true})) {\r\n    if (!numImports && maybeMessage && tk.next({val: '(', silent: true})) {\r\n      // This will happen if a message is named import.\r\n      tk.pos = pos;\r\n      return;\r\n    }\r\n    var kind = tk.next({id: 'name'}).val;\r\n    var fname = JSON.parse(tk.next({id: 'string'}).val);\r\n    tk.next({val: ';'});\r\n    imports.push({kind: kind, name: fname});\r\n    numImports++;\r\n  }\r\n  return numImports;\r\n};\r\n\r\n// Helpers.\r\n\r\n/**\r\n * Simple class to split an input string into tokens.\r\n *\r\n * There are different types of tokens, characterized by their `id`:\r\n *\r\n * + `number` numbers.\r\n * + `name` references.\r\n * + `string` double-quoted.\r\n * + `operator`, anything else, always single character.\r\n * + `javadoc`, only emitted when `next` is called with `emitJavadoc` set.\r\n * + `json`, only emitted when `next` is called with `'json'` as `id` (the\r\n *   tokenizer doesn't have enough context to predict these).\r\n */\r\nfunction Tokenizer(str) {\r\n  this._str = str;\r\n  this.pos = 0;\r\n}\r\n\r\nTokenizer.prototype.next = function (opts) {\r\n  var token = {pos: this.pos, id: undefined, val: undefined};\r\n  var javadoc = this._skip(opts && opts.emitJavadoc);\r\n  if (javadoc) {\r\n    token.id = 'javadoc';\r\n    token.val = javadoc;\r\n  } else {\r\n    var pos = this.pos;\r\n    var str = this._str;\r\n    var c = str.charAt(pos);\r\n    if (!c) {\r\n      token.id = '(eof)';\r\n    } else {\r\n      if (opts && opts.id === 'json') {\r\n        token.id = 'json';\r\n        this.pos = this._endOfJson();\r\n      } else if (c === '\"') {\r\n        token.id = 'string';\r\n        this.pos = this._endOfString();\r\n      } else if (/[0-9]/.test(c)) {\r\n        token.id = 'number';\r\n        this.pos = this._endOf(/[0-9]/);\r\n      } else if (/[`A-Za-z_.]/.test(c)) {\r\n        token.id = 'name';\r\n        this.pos = this._endOf(/[`A-Za-z0-9_.]/);\r\n      } else {\r\n        token.id = 'operator';\r\n        this.pos = pos + 1;\r\n      }\r\n      token.val = str.slice(pos, this.pos);\r\n      if (token.id === 'json') {\r\n        // Let's be nice and give a more helpful error message when this occurs\r\n        // (JSON parsing errors wouldn't let us find the location otherwise).\r\n        try {\r\n          token.val = JSON.parse(token.val);\r\n        } catch (err) {\r\n          throw this.error('invalid JSON', token);\r\n        }\r\n      } else if (token.id === 'name') {\r\n        // Unescape names (our parser doesn't need them).\r\n        token.val = token.val.replace(/`/g, '');\r\n      }\r\n    }\r\n  }\r\n\r\n  var err;\r\n  if (opts && opts.id && opts.id !== token.id) {\r\n    err = this.error(f('expected ID %s', opts.id), token);\r\n  } else if (opts && opts.val && opts.val !== token.val) {\r\n    err = this.error(f('expected value %s', opts.val), token);\r\n  }\r\n  if (!err) {\r\n    return token;\r\n  } else if (opts && opts.silent) {\r\n    this.pos = token.pos; // Backtrack to start of token.\r\n    return undefined;\r\n  } else {\r\n    throw err;\r\n  }\r\n};\r\n\r\nTokenizer.prototype.error = function (reason, context) {\r\n  // Context must be either a token or a position.\r\n  var isToken = typeof context != 'number';\r\n  var pos = isToken ? context.pos : context;\r\n  var str = this._str;\r\n  var lineNum = 1;\r\n  var lineStart = 0;\r\n  var i;\r\n  for (i = 0; i < pos; i++) {\r\n    if (str.charAt(i) === '\\n') {\r\n      lineNum++;\r\n      lineStart = i;\r\n    }\r\n  }\r\n  var msg = isToken ? f('invalid token %j: %s', context, reason) : reason;\r\n  var err = new Error(msg);\r\n  err.token = isToken ? context : undefined;\r\n  err.lineNum = lineNum;\r\n  err.colNum = pos - lineStart;\r\n  return err;\r\n};\r\n\r\n/** Skip whitespace and comments. */\r\nTokenizer.prototype._skip = function (emitJavadoc) {\r\n  var str = this._str;\r\n  var isJavadoc = false;\r\n  var pos, c;\r\n\r\n  while ((c = str.charAt(this.pos)) && /\\s/.test(c)) {\r\n    this.pos++;\r\n  }\r\n  pos = this.pos;\r\n  if (c === '/') {\r\n    switch (str.charAt(this.pos + 1)) {\r\n    case '/':\r\n      this.pos += 2;\r\n      while ((c = str.charAt(this.pos)) && c !== '\\n') {\r\n        this.pos++;\r\n      }\r\n      return this._skip(emitJavadoc);\r\n    case '*':\r\n      this.pos += 2;\r\n      if (str.charAt(this.pos) === '*') {\r\n        isJavadoc = true;\r\n      }\r\n      while ((c = str.charAt(this.pos++))) {\r\n        if (c === '*' && str.charAt(this.pos) === '/') {\r\n          this.pos++;\r\n          if (isJavadoc && emitJavadoc) {\r\n            return extractJavadoc(str.slice(pos + 3, this.pos - 2));\r\n          }\r\n          return this._skip(emitJavadoc);\r\n        }\r\n      }\r\n      throw this.error('unterminated comment', pos);\r\n    }\r\n  }\r\n};\r\n\r\n/** Generic end of method. */\r\nTokenizer.prototype._endOf = function (pat) {\r\n  var pos = this.pos;\r\n  var str = this._str;\r\n  while (pat.test(str.charAt(pos))) {\r\n    pos++;\r\n  }\r\n  return pos;\r\n};\r\n\r\n/** Find end of a string. */\r\nTokenizer.prototype._endOfString = function () {\r\n  var pos = this.pos + 1; // Skip first double quote.\r\n  var str = this._str;\r\n  var c;\r\n  while ((c = str.charAt(pos))) {\r\n    if (c === '\"') {\r\n      // The spec doesn't explicitly say so, but IDLs likely only\r\n      // allow double quotes for strings (C- and Java-style).\r\n      return pos + 1;\r\n    }\r\n    if (c === '\\\\') {\r\n      pos += 2;\r\n    } else {\r\n      pos++;\r\n    }\r\n  }\r\n  throw this.error('unterminated string', pos - 1);\r\n};\r\n\r\n/** Find end of JSON object, throwing an error if the end is reached first. */\r\nTokenizer.prototype._endOfJson = function () {\r\n  var pos = utils.jsonEnd(this._str, this.pos);\r\n  if (pos < 0) {\r\n    throw this.error('invalid JSON', pos);\r\n  }\r\n  return pos;\r\n};\r\n\r\n/**\r\n * Extract Javadoc contents from the comment.\r\n *\r\n * The parsing done is very simple and simply removes the line prefixes and\r\n * leading / trailing empty lines. It's better to be conservative with\r\n * formatting rather than risk losing information.\r\n */\r\nfunction extractJavadoc(str) {\r\n  var lines = str\r\n    .replace(/^[ \\t]+|[ \\t]+$/g, '') // Trim whitespace.\r\n    .split('\\n').map(function (line, i) {\r\n      return i ? line.replace(/^\\s*\\*\\s?/, '') : line;\r\n    });\r\n  while (!lines[0]) {\r\n    lines.shift();\r\n  }\r\n  while (!lines[lines.length - 1]) {\r\n    lines.pop();\r\n  }\r\n  return lines.join('\\n');\r\n}\r\n\r\n/** Returns the namespace generated by a protocol. */\r\nfunction protocolNamespace(protocol) {\r\n  if (protocol.namespace) {\r\n    return protocol.namespace;\r\n  }\r\n  var match = /^(.*)\\.[^.]+$/.exec(protocol.protocol);\r\n  return match ? match[1] : undefined;\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  Tokenizer: Tokenizer,\r\n  assembleProtocol: assembleProtocol,\r\n  read: read,\r\n  readProtocol: Reader.readProtocol,\r\n  readSchema: Reader.readSchema\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/specs.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/types.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/types.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* jshint node: true */\r\n\r\n// TODO: Make it easier to implement custom types. This will likely require\r\n// exposing the `Tap` object, perhaps under another name. Probably worth a\r\n// major release.\r\n// TODO: Allow configuring when to write the size when writing arrays and maps,\r\n// and customizing their block size.\r\n// TODO: Code-generate `compare` and `clone` record and union methods.\r\n\r\n\r\n\r\n/**\r\n * This module defines all Avro data types and their serialization logic.\r\n *\r\n */\r\n\r\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/avsc/lib/utils.js\"),\r\n    buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"), // For `SlowBuffer`.\r\n    util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\n\r\n\r\n// Convenience imports.\r\nvar Tap = utils.Tap;\r\nvar debug = util.debuglog('avsc:types');\r\nvar f = util.format;\r\n\r\n// All non-union concrete (i.e. non-logical) Avro types.\r\nvar TYPES = {\r\n  'array': ArrayType,\r\n  'boolean': BooleanType,\r\n  'bytes': BytesType,\r\n  'double': DoubleType,\r\n  'enum': EnumType,\r\n  'error': RecordType,\r\n  'fixed': FixedType,\r\n  'float': FloatType,\r\n  'int': IntType,\r\n  'long': LongType,\r\n  'map': MapType,\r\n  'null': NullType,\r\n  'record': RecordType,\r\n  'string': StringType\r\n};\r\n\r\n// Random generator.\r\nvar RANDOM = new utils.Lcg();\r\n\r\n// Encoding tap (shared for performance).\r\nvar TAP = new Tap(new buffer.SlowBuffer(1024));\r\n\r\n// Currently active logical type, used for name redirection.\r\nvar LOGICAL_TYPE = null;\r\n\r\n// Underlying types of logical types currently being instantiated. This is used\r\n// to be able to reference names (i.e. for branches) during instantiation.\r\nvar UNDERLYING_TYPES = [];\r\n\r\n/**\r\n * \"Abstract\" base Avro type.\r\n *\r\n * This class' constructor will register any named types to support recursive\r\n * schemas. All type values are represented in memory similarly to their JSON\r\n * representation, except for:\r\n *\r\n * + `bytes` and `fixed` which are represented as `Buffer`s.\r\n * + `union`s which will be \"unwrapped\" unless the `wrapUnions` option is set.\r\n *\r\n *  See individual subclasses for details.\r\n */\r\nfunction Type(schema, opts) {\r\n  var type;\r\n  if (LOGICAL_TYPE) {\r\n    type = LOGICAL_TYPE;\r\n    UNDERLYING_TYPES.push([LOGICAL_TYPE, this]);\r\n    LOGICAL_TYPE = null;\r\n  } else {\r\n    type = this;\r\n  }\r\n\r\n  // Lazily instantiated hash string. It will be generated the first time the\r\n  // type's default fingerprint is computed (for example when using `equals`).\r\n  // We use a mutable object since types are frozen after instantiation.\r\n  this._hash = new Hash();\r\n  this.name = undefined;\r\n  this.aliases = undefined;\r\n  this.doc = (schema && schema.doc) ? '' + schema.doc : undefined;\r\n\r\n  if (schema) {\r\n    // This is a complex (i.e. non-primitive) type.\r\n    var name = schema.name;\r\n    var namespace = schema.namespace === undefined ?\r\n      opts && opts.namespace :\r\n      schema.namespace;\r\n    if (name !== undefined) {\r\n      // This isn't an anonymous type.\r\n      name = maybeQualify(name, namespace);\r\n      if (isPrimitive(name)) {\r\n        // Avro doesn't allow redefining primitive names.\r\n        throw new Error(f('cannot rename primitive type: %j', name));\r\n      }\r\n      var registry = opts && opts.registry;\r\n      if (registry) {\r\n        if (registry[name] !== undefined) {\r\n          throw new Error(f('duplicate type name: %s', name));\r\n        }\r\n        registry[name] = type;\r\n      }\r\n    } else if (opts && opts.noAnonymousTypes) {\r\n      throw new Error(f('missing name property in schema: %j', schema));\r\n    }\r\n    this.name = name;\r\n    this.aliases = schema.aliases ?\r\n      schema.aliases.map(function (s) { return maybeQualify(s, namespace); }) :\r\n      [];\r\n  }\r\n}\r\n\r\nType.forSchema = function (schema, opts) {\r\n  opts = opts || {};\r\n  opts.registry = opts.registry || {};\r\n\r\n  var UnionType = (function (wrapUnions) {\r\n    if (wrapUnions === true) {\r\n      wrapUnions = 'always';\r\n    } else if (wrapUnions === false) {\r\n      wrapUnions = 'never';\r\n    } else if (wrapUnions === undefined) {\r\n      wrapUnions = 'auto';\r\n    } else if (typeof wrapUnions == 'string') {\r\n      wrapUnions = wrapUnions.toLowerCase();\r\n    }\r\n    switch (wrapUnions) {\r\n      case 'always':\r\n        return WrappedUnionType;\r\n      case 'never':\r\n        return UnwrappedUnionType;\r\n      case 'auto':\r\n        return undefined; // Determined dynamically later on.\r\n      default:\r\n        throw new Error(f('invalid wrap unions option: %j', wrapUnions));\r\n    }\r\n  })(opts.wrapUnions);\r\n\r\n  if (schema === null) {\r\n    // Let's be helpful for this common error.\r\n    throw new Error('invalid type: null (did you mean \"null\"?)');\r\n  }\r\n\r\n  if (Type.isType(schema)) {\r\n    return schema;\r\n  }\r\n\r\n  var type;\r\n  if (opts.typeHook && (type = opts.typeHook(schema, opts))) {\r\n    if (!Type.isType(type)) {\r\n      throw new Error(f('invalid typehook return value: %j', type));\r\n    }\r\n    return type;\r\n  }\r\n\r\n  if (typeof schema == 'string') { // Type reference.\r\n    schema = maybeQualify(schema, opts.namespace);\r\n    type = opts.registry[schema];\r\n    if (type) {\r\n      // Type was already defined, return it.\r\n      return type;\r\n    }\r\n    if (isPrimitive(schema)) {\r\n      // Reference to a primitive type. These are also defined names by default\r\n      // so we create the appropriate type and it to the registry for future\r\n      // reference.\r\n      return opts.registry[schema] = Type.forSchema({type: schema}, opts);\r\n    }\r\n    throw new Error(f('undefined type name: %s', schema));\r\n  }\r\n\r\n  if (schema.logicalType && opts.logicalTypes && !LOGICAL_TYPE) {\r\n    var DerivedType = opts.logicalTypes[schema.logicalType];\r\n    if (DerivedType) {\r\n      var namespace = opts.namespace;\r\n      var registry = {};\r\n      Object.keys(opts.registry).forEach(function (key) {\r\n        registry[key] = opts.registry[key];\r\n      });\r\n      try {\r\n        debug('instantiating logical type for %s', schema.logicalType);\r\n        return new DerivedType(schema, opts);\r\n      } catch (err) {\r\n        debug('failed to instantiate logical type for %s', schema.logicalType);\r\n        if (opts.assertLogicalTypes) {\r\n          // The spec mandates that we fall through to the underlying type if\r\n          // the logical type is invalid. We provide this option to ease\r\n          // debugging.\r\n          throw err;\r\n        }\r\n        LOGICAL_TYPE = null;\r\n        opts.namespace = namespace;\r\n        opts.registry = registry;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (Array.isArray(schema)) { // Union.\r\n    // We temporarily clear the logical type since we instantiate the branch's\r\n    // types before the underlying union's type (necessary to decide whether the\r\n    // union is ambiguous or not).\r\n    var logicalType = LOGICAL_TYPE;\r\n    LOGICAL_TYPE = null;\r\n    var types = schema.map(function (obj) {\r\n      return Type.forSchema(obj, opts);\r\n    });\r\n    if (!UnionType) {\r\n      UnionType = isAmbiguous(types) ? WrappedUnionType : UnwrappedUnionType;\r\n    }\r\n    LOGICAL_TYPE = logicalType;\r\n    type = new UnionType(types, opts);\r\n  } else { // New type definition.\r\n    type = (function (typeName) {\r\n      var Type = TYPES[typeName];\r\n      if (Type === undefined) {\r\n        throw new Error(f('unknown type: %j', typeName));\r\n      }\r\n      return new Type(schema, opts);\r\n    })(schema.type);\r\n  }\r\n  return type;\r\n};\r\n\r\nType.forValue = function (val, opts) {\r\n  opts = opts || {};\r\n\r\n  // Sentinel used when inferring the types of empty arrays.\r\n  opts.emptyArrayType = opts.emptyArrayType || Type.forSchema({\r\n    type: 'array', items: 'null'\r\n  });\r\n\r\n  // Optional custom inference hook.\r\n  if (opts.valueHook) {\r\n    var type = opts.valueHook(val, opts);\r\n    if (type !== undefined) {\r\n      if (!Type.isType(type)) {\r\n        throw new Error(f('invalid value hook return value: %j', type));\r\n      }\r\n      return type;\r\n    }\r\n  }\r\n\r\n  // Default inference logic.\r\n  switch (typeof val) {\r\n    case 'string':\r\n      return Type.forSchema('string', opts);\r\n    case 'boolean':\r\n      return Type.forSchema('boolean', opts);\r\n    case 'number':\r\n      if ((val | 0) === val) {\r\n        return Type.forSchema('int', opts);\r\n      } else if (Math.abs(val) < 9007199254740991) {\r\n        return Type.forSchema('float', opts);\r\n      }\r\n      return Type.forSchema('double', opts);\r\n    case 'object':\r\n      if (val === null) {\r\n        return Type.forSchema('null', opts);\r\n      } else if (Array.isArray(val)) {\r\n        if (!val.length) {\r\n          return opts.emptyArrayType;\r\n        }\r\n        return Type.forSchema({\r\n          type: 'array',\r\n          items: Type.forTypes(\r\n            val.map(function (v) { return Type.forValue(v, opts); }),\r\n            opts\r\n          )\r\n        }, opts);\r\n      } else if (Buffer.isBuffer(val)) {\r\n        return Type.forSchema('bytes', opts);\r\n      }\r\n      var fieldNames = Object.keys(val);\r\n      if (fieldNames.some(function (s) { return !utils.isValidName(s); })) {\r\n        // We have to fall back to a map.\r\n        return Type.forSchema({\r\n          type: 'map',\r\n          values: Type.forTypes(fieldNames.map(function (s) {\r\n            return Type.forValue(val[s], opts);\r\n          }), opts)\r\n        }, opts);\r\n      }\r\n      return Type.forSchema({\r\n        type: 'record',\r\n        fields: fieldNames.map(function (s) {\r\n          return {name: s, type: Type.forValue(val[s], opts)};\r\n        })\r\n      }, opts);\r\n    default:\r\n      throw new Error(f('cannot infer type from: %j', val));\r\n  }\r\n};\r\n\r\nType.forTypes = function (types, opts) {\r\n  if (!types.length) {\r\n    throw new Error('no types to combine');\r\n  }\r\n  if (types.length === 1) {\r\n    return types[0]; // Nothing to do.\r\n  }\r\n  opts = opts || {};\r\n\r\n  // Extract any union types, with special care for wrapped unions (see below).\r\n  var expanded = [];\r\n  var numWrappedUnions = 0;\r\n  var isValidWrappedUnion = true;\r\n  types.forEach(function (type) {\r\n    switch (type.typeName) {\r\n      case 'union:unwrapped':\r\n        isValidWrappedUnion = false;\r\n        expanded = expanded.concat(type.types);\r\n        break;\r\n      case 'union:wrapped':\r\n        numWrappedUnions++;\r\n        expanded = expanded.concat(type.types);\r\n        break;\r\n      case 'null':\r\n        expanded.push(type);\r\n        break;\r\n      default:\r\n        isValidWrappedUnion = false;\r\n        expanded.push(type);\r\n    }\r\n  });\r\n  if (numWrappedUnions) {\r\n    if (!isValidWrappedUnion) {\r\n      // It is only valid to combine wrapped unions when no other type is\r\n      // present other than wrapped unions and nulls (otherwise the values of\r\n      // others wouldn't be valid in the resulting union).\r\n      throw new Error('cannot combine wrapped union');\r\n    }\r\n    var branchTypes = {};\r\n    expanded.forEach(function (type) {\r\n      var name = type.branchName;\r\n      var branchType = branchTypes[name];\r\n      if (!branchType) {\r\n        branchTypes[name] = type;\r\n      } else if (!type.equals(branchType)) {\r\n        throw new Error('inconsistent branch type');\r\n      }\r\n    });\r\n    var wrapUnions = opts.wrapUnions;\r\n    var unionType;\r\n    opts.wrapUnions = true;\r\n    try {\r\n      unionType = Type.forSchema(Object.keys(branchTypes).map(function (name) {\r\n        return branchTypes[name];\r\n      }), opts);\r\n    } catch (err) {\r\n      opts.wrapUnions = wrapUnions;\r\n      throw err;\r\n    }\r\n    opts.wrapUnions = wrapUnions;\r\n    return unionType;\r\n  }\r\n\r\n  // Group types by category, similar to the logic for unwrapped unions.\r\n  var bucketized = {};\r\n  expanded.forEach(function (type) {\r\n    var bucket = getTypeBucket(type);\r\n    var bucketTypes = bucketized[bucket];\r\n    if (!bucketTypes) {\r\n      bucketized[bucket] = bucketTypes = [];\r\n    }\r\n    bucketTypes.push(type);\r\n  });\r\n\r\n  // Generate the \"augmented\" type for each group.\r\n  var buckets = Object.keys(bucketized);\r\n  var augmented = buckets.map(function (bucket) {\r\n    var bucketTypes = bucketized[bucket];\r\n    if (bucketTypes.length === 1) {\r\n      return bucketTypes[0];\r\n    } else {\r\n      switch (bucket) {\r\n        case 'null':\r\n        case 'boolean':\r\n          return bucketTypes[0];\r\n        case 'number':\r\n          return combineNumbers(bucketTypes);\r\n        case 'string':\r\n          return combineStrings(bucketTypes, opts);\r\n        case 'buffer':\r\n          return combineBuffers(bucketTypes, opts);\r\n        case 'array':\r\n          // Remove any sentinel arrays (used when inferring from empty arrays)\r\n          // to avoid making things nullable when they shouldn't be.\r\n          bucketTypes = bucketTypes.filter(function (t) {\r\n            return t !== opts.emptyArrayType;\r\n          });\r\n          if (!bucketTypes.length) {\r\n            // We still don't have a real type, just return the sentinel.\r\n            return opts.emptyArrayType;\r\n          }\r\n          return Type.forSchema({\r\n            type: 'array',\r\n            items: Type.forTypes(bucketTypes.map(function (t) {\r\n              return t.itemsType;\r\n            }), opts)\r\n          }, opts);\r\n        default:\r\n          return combineObjects(bucketTypes, opts);\r\n      }\r\n    }\r\n  });\r\n\r\n  if (augmented.length === 1) {\r\n    return augmented[0];\r\n  } else {\r\n    // We return an (unwrapped) union of all augmented types.\r\n    return Type.forSchema(augmented, opts);\r\n  }\r\n};\r\n\r\nType.isType = function (/* any, [prefix] ... */) {\r\n  var l = arguments.length;\r\n  if (!l) {\r\n    return false;\r\n  }\r\n\r\n  var any = arguments[0];\r\n  if (\r\n    !any ||\r\n    typeof any._update != 'function' ||\r\n    typeof any.fingerprint != 'function'\r\n  ) {\r\n    // Not fool-proof, but most likely good enough.\r\n    return false;\r\n  }\r\n\r\n  if (l === 1) {\r\n    // No type names specified, we are done.\r\n    return true;\r\n  }\r\n\r\n  // We check if at least one of the prefixes matches.\r\n  var typeName = any.typeName;\r\n  var i;\r\n  for (i = 1; i < l; i++) {\r\n    if (typeName.indexOf(arguments[i]) === 0) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\nType.__reset = function (size) {\r\n  debug('resetting type buffer to %d', size);\r\n  TAP.buf = new buffer.SlowBuffer(size);\r\n};\r\n\r\nObject.defineProperty(Type.prototype, 'branchName', {\r\n  enumerable: true,\r\n  get: function () {\r\n    var type = Type.isType(this, 'logical') ? this.underlyingType : this;\r\n    if (type.name) {\r\n      return type.name;\r\n    }\r\n    if (Type.isType(type, 'abstract')) {\r\n      return type._concreteTypeName;\r\n    }\r\n    return Type.isType(type, 'union') ? undefined : type.typeName;\r\n  }\r\n});\r\n\r\nType.prototype.clone = function (val, opts) {\r\n  if (opts) {\r\n    opts = {\r\n      coerce: !!opts.coerceBuffers | 0, // Coerce JSON to Buffer.\r\n      fieldHook: opts.fieldHook,\r\n      qualifyNames: !!opts.qualifyNames,\r\n      skip: !!opts.skipMissingFields,\r\n      wrap: !!opts.wrapUnions | 0 // Wrap first match into union.\r\n    };\r\n    return this._copy(val, opts);\r\n  } else {\r\n    // If no modifications are required, we can get by with a serialization\r\n    // roundtrip (generally much faster than a standard deep copy).\r\n    return this.fromBuffer(this.toBuffer(val));\r\n  }\r\n};\r\n\r\nType.prototype.compare = utils.abstractFunction;\r\n\r\nType.prototype.compareBuffers = function (buf1, buf2) {\r\n  return this._match(new Tap(buf1), new Tap(buf2));\r\n};\r\n\r\nType.prototype.createResolver = function (type, opts) {\r\n  if (!Type.isType(type)) {\r\n    // More explicit error message than the \"incompatible type\" thrown\r\n    // otherwise (especially because of the overridden `toJSON` method).\r\n    throw new Error(f('not a type: %j', type));\r\n  }\r\n\r\n  if (!Type.isType(this, 'union', 'logical') && Type.isType(type, 'logical')) {\r\n    // Trying to read a logical type as a built-in: unwrap the logical type.\r\n    // Note that we exclude unions to support resolving into unions containing\r\n    // logical types.\r\n    return this.createResolver(type.underlyingType, opts);\r\n  }\r\n\r\n  opts = opts || {};\r\n  opts.registry = opts.registry || {};\r\n\r\n  var resolver, key;\r\n  if (\r\n    Type.isType(this, 'record', 'error') &&\r\n    Type.isType(type, 'record', 'error')\r\n  ) {\r\n    // We allow conversions between records and errors.\r\n    key = this.name + ':' + type.name; // ':' is illegal in Avro type names.\r\n    resolver = opts.registry[key];\r\n    if (resolver) {\r\n      return resolver;\r\n    }\r\n  }\r\n\r\n  resolver = new Resolver(this);\r\n  if (key) { // Register resolver early for recursive schemas.\r\n    opts.registry[key] = resolver;\r\n  }\r\n\r\n  if (Type.isType(type, 'union')) {\r\n    var resolvers = type.types.map(function (t) {\r\n      return this.createResolver(t, opts);\r\n    }, this);\r\n    resolver._read = function (tap) {\r\n      var index = tap.readLong();\r\n      var resolver = resolvers[index];\r\n      if (resolver === undefined) {\r\n        throw new Error(f('invalid union index: %s', index));\r\n      }\r\n      return resolvers[index]._read(tap);\r\n    };\r\n  } else {\r\n    this._update(resolver, type, opts);\r\n  }\r\n\r\n  if (!resolver._read) {\r\n    throw new Error(f('cannot read %s as %s', type, this));\r\n  }\r\n  return Object.freeze(resolver);\r\n};\r\n\r\nType.prototype.decode = function (buf, pos, resolver) {\r\n  var tap = new Tap(buf, pos);\r\n  var val = readValue(this, tap, resolver);\r\n  if (!tap.isValid()) {\r\n    return {value: undefined, offset: -1};\r\n  }\r\n  return {value: val, offset: tap.pos};\r\n};\r\n\r\nType.prototype.encode = function (val, buf, pos) {\r\n  var tap = new Tap(buf, pos);\r\n  this._write(tap, val);\r\n  if (!tap.isValid()) {\r\n    // Don't throw as there is no way to predict this. We also return the\r\n    // number of missing bytes to ease resizing.\r\n    return buf.length - tap.pos;\r\n  }\r\n  return tap.pos;\r\n};\r\n\r\nType.prototype.equals = function (type, opts) {\r\n  var canon = ( // Canonical equality.\r\n    Type.isType(type) &&\r\n    this.fingerprint().equals(type.fingerprint())\r\n  );\r\n  if (!canon || !(opts && opts.strict)) {\r\n    return canon;\r\n  }\r\n  return (\r\n    JSON.stringify(this.schema({exportAttrs: true})) ===\r\n    JSON.stringify(type.schema({exportAttrs: true}))\r\n  );\r\n};\r\n\r\nType.prototype.fingerprint = function (algorithm) {\r\n  if (!algorithm) {\r\n    if (!this._hash.str) {\r\n      var schemaStr = JSON.stringify(this.schema());\r\n      this._hash.str = utils.getHash(schemaStr).toString('binary');\r\n    }\r\n    return utils.bufferFrom(this._hash.str, 'binary');\r\n  } else {\r\n    return utils.getHash(JSON.stringify(this.schema()), algorithm);\r\n  }\r\n};\r\n\r\nType.prototype.fromBuffer = function (buf, resolver, noCheck) {\r\n  var tap = new Tap(buf);\r\n  var val = readValue(this, tap, resolver, noCheck);\r\n  if (!tap.isValid()) {\r\n    throw new Error('truncated buffer');\r\n  }\r\n  if (!noCheck && tap.pos < buf.length) {\r\n    throw new Error('trailing data');\r\n  }\r\n  return val;\r\n};\r\n\r\nType.prototype.fromString = function (str) {\r\n  return this._copy(JSON.parse(str), {coerce: 2});\r\n};\r\n\r\nType.prototype.inspect = function () {\r\n  var typeName = this.typeName;\r\n  var className = getClassName(typeName);\r\n  if (isPrimitive(typeName)) {\r\n    // The class name is sufficient to identify the type.\r\n    return f('<%s>', className);\r\n  } else {\r\n    // We add a little metadata for convenience.\r\n    var obj = this.schema({exportAttrs: true, noDeref: true});\r\n    if (typeof obj == 'object' && !Type.isType(this, 'logical')) {\r\n      obj.type = undefined; // Would be redundant with constructor name.\r\n    }\r\n    return f('<%s %j>', className, obj);\r\n  }\r\n};\r\n\r\nType.prototype.isValid = function (val, opts) {\r\n  // We only have a single flag for now, so no need to complicate things.\r\n  var flags = (opts && opts.noUndeclaredFields) | 0;\r\n  var errorHook = opts && opts.errorHook;\r\n  var hook, path;\r\n  if (errorHook) {\r\n    path = [];\r\n    hook = function (any, type) {\r\n      errorHook.call(this, path.slice(), any, type, val);\r\n    };\r\n  }\r\n  return this._check(val, flags, hook, path);\r\n};\r\n\r\nType.prototype.random = utils.abstractFunction;\r\n\r\nType.prototype.schema = function (opts) {\r\n  // Copy the options to avoid mutating the original options object when we add\r\n  // the registry of dereferenced types.\r\n  return this._attrs({\r\n    exportAttrs: !!(opts && opts.exportAttrs),\r\n    noDeref: !!(opts && opts.noDeref)\r\n  });\r\n};\r\n\r\nType.prototype.toBuffer = function (val) {\r\n  TAP.pos = 0;\r\n  this._write(TAP, val);\r\n  var buf = utils.newBuffer(TAP.pos);\r\n  if (TAP.isValid()) {\r\n    TAP.buf.copy(buf, 0, 0, TAP.pos);\r\n  } else {\r\n    this._write(new Tap(buf), val);\r\n  }\r\n  return buf;\r\n};\r\n\r\nType.prototype.toJSON = function () {\r\n  // Convenience to allow using `JSON.stringify(type)` to get a type's schema.\r\n  return this.schema({exportAttrs: true});\r\n};\r\n\r\nType.prototype.toString = function (val) {\r\n  if (val === undefined) {\r\n    // Consistent behavior with standard `toString` expectations.\r\n    return JSON.stringify(this.schema({noDeref: true}));\r\n  }\r\n  return JSON.stringify(this._copy(val, {coerce: 3}));\r\n};\r\n\r\nType.prototype.wrap = function (val) {\r\n  var Branch = this._branchConstructor;\r\n  return Branch === null ? null : new Branch(val);\r\n};\r\n\r\nType.prototype._attrs = function (opts) {\r\n  // This function handles a lot of the common logic to schema generation\r\n  // across types, for example keeping track of which types have already been\r\n  // de-referenced (i.e. derefed).\r\n  opts.derefed = opts.derefed || {};\r\n  var name = this.name;\r\n  if (name !== undefined) {\r\n    if (opts.noDeref || opts.derefed[name]) {\r\n      return name;\r\n    }\r\n    opts.derefed[name] = true;\r\n  }\r\n  var schema = {};\r\n  // The order in which we add fields to the `schema` object matters here.\r\n  // Since JS objects are unordered, this implementation (unfortunately) relies\r\n  // on engines returning properties in the same order that they are inserted\r\n  // in. This is not in the JS spec, but can be \"somewhat\" safely assumed (see\r\n  // http://stackoverflow.com/q/5525795/1062617).\r\n  if (this.name !== undefined) {\r\n    schema.name = name;\r\n  }\r\n  schema.type = this.typeName;\r\n  var derefedSchema = this._deref(schema, opts);\r\n  if (derefedSchema !== undefined) {\r\n    // We allow the original schema to be overridden (this will happen for\r\n    // primitive types and logical types).\r\n    schema = derefedSchema;\r\n  }\r\n  if (opts.exportAttrs) {\r\n    if (this.aliases && this.aliases.length) {\r\n      schema.aliases = this.aliases;\r\n    }\r\n    if (this.doc !== undefined) {\r\n      schema.doc = this.doc;\r\n    }\r\n  }\r\n  return schema;\r\n};\r\n\r\nType.prototype._createBranchConstructor = function () {\r\n  // jshint -W054\r\n  var name = this.branchName;\r\n  if (name === 'null') {\r\n    return null;\r\n  }\r\n  var attr = ~name.indexOf('.') ? 'this[\\'' + name + '\\']' : 'this.' + name;\r\n  var body = 'return function Branch$(val) { ' + attr + ' = val; };';\r\n  var Branch = (new Function(body))();\r\n  Branch.type = this;\r\n  Branch.prototype.unwrap = new Function('return ' + attr + ';');\r\n  Branch.prototype.unwrapped = Branch.prototype.unwrap; // Deprecated.\r\n  return Branch;\r\n};\r\n\r\nType.prototype._peek = function (tap) {\r\n  var pos = tap.pos;\r\n  var val = this._read(tap);\r\n  tap.pos = pos;\r\n  return val;\r\n};\r\n\r\nType.prototype._check = utils.abstractFunction;\r\nType.prototype._copy = utils.abstractFunction;\r\nType.prototype._deref = utils.abstractFunction;\r\nType.prototype._match = utils.abstractFunction;\r\nType.prototype._read = utils.abstractFunction;\r\nType.prototype._skip = utils.abstractFunction;\r\nType.prototype._update = utils.abstractFunction;\r\nType.prototype._write = utils.abstractFunction;\r\n\r\n// \"Deprecated\" getters (will be explicitly deprecated in 5.1).\r\n\r\nType.prototype.getAliases = function () { return this.aliases; };\r\n\r\nType.prototype.getFingerprint = Type.prototype.fingerprint;\r\n\r\nType.prototype.getName = function (asBranch) {\r\n  return (this.name || !asBranch) ? this.name : this.branchName;\r\n};\r\n\r\nType.prototype.getSchema = Type.prototype.schema;\r\n\r\nType.prototype.getTypeName = function () { return this.typeName; };\r\n\r\n// Implementations.\r\n\r\n/**\r\n * Base primitive Avro type.\r\n *\r\n * Most of the primitive types share the same cloning and resolution\r\n * mechanisms, provided by this class. This class also lets us conveniently\r\n * check whether a type is a primitive using `instanceof`.\r\n */\r\nfunction PrimitiveType(noFreeze) {\r\n  Type.call(this);\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  if (!noFreeze) {\r\n    // Abstract long types can't be frozen at this stage.\r\n    Object.freeze(this);\r\n  }\r\n}\r\nutil.inherits(PrimitiveType, Type);\r\n\r\nPrimitiveType.prototype._update = function (resolver, type) {\r\n  if (type.typeName === this.typeName) {\r\n    resolver._read = this._read;\r\n  }\r\n};\r\n\r\nPrimitiveType.prototype._copy = function (val) {\r\n  this._check(val, undefined, throwInvalidError);\r\n  return val;\r\n};\r\n\r\nPrimitiveType.prototype._deref = function () { return this.typeName; };\r\n\r\nPrimitiveType.prototype.compare = utils.compare;\r\n\r\n/** Nulls. */\r\nfunction NullType() { PrimitiveType.call(this); }\r\nutil.inherits(NullType, PrimitiveType);\r\n\r\nNullType.prototype._check = function (val, flags, hook) {\r\n  var b = val === null;\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nNullType.prototype._read = function () { return null; };\r\n\r\nNullType.prototype._skip = function () {};\r\n\r\nNullType.prototype._write = function (tap, val) {\r\n  if (val !== null) {\r\n    throwInvalidError(val, this);\r\n  }\r\n};\r\n\r\nNullType.prototype._match = function () { return 0; };\r\n\r\nNullType.prototype.compare = NullType.prototype._match;\r\n\r\nNullType.prototype.typeName = 'null';\r\n\r\nNullType.prototype.random = NullType.prototype._read;\r\n\r\n/** Booleans. */\r\nfunction BooleanType() { PrimitiveType.call(this); }\r\nutil.inherits(BooleanType, PrimitiveType);\r\n\r\nBooleanType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'boolean';\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nBooleanType.prototype._read = function (tap) { return tap.readBoolean(); };\r\n\r\nBooleanType.prototype._skip = function (tap) { tap.skipBoolean(); };\r\n\r\nBooleanType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'boolean') {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeBoolean(val);\r\n};\r\n\r\nBooleanType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchBoolean(tap2);\r\n};\r\n\r\nBooleanType.prototype.typeName = 'boolean';\r\n\r\nBooleanType.prototype.random = function () { return RANDOM.nextBoolean(); };\r\n\r\n/** Integers. */\r\nfunction IntType() { PrimitiveType.call(this); }\r\nutil.inherits(IntType, PrimitiveType);\r\n\r\nIntType.prototype._check = function (val, flags, hook) {\r\n  var b = val === (val | 0);\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nIntType.prototype._read = function (tap) { return tap.readInt(); };\r\n\r\nIntType.prototype._skip = function (tap) { tap.skipInt(); };\r\n\r\nIntType.prototype._write = function (tap, val) {\r\n  if (val !== (val | 0)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeInt(val);\r\n};\r\n\r\nIntType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchInt(tap2);\r\n};\r\n\r\nIntType.prototype.typeName = 'int';\r\n\r\nIntType.prototype.random = function () { return RANDOM.nextInt(1000) | 0; };\r\n\r\n/**\r\n * Longs.\r\n *\r\n * We can't capture all the range unfortunately since JavaScript represents all\r\n * numbers internally as `double`s, so the default implementation plays safe\r\n * and throws rather than potentially silently change the data. See `__with` or\r\n * `AbstractLongType` below for a way to implement a custom long type.\r\n */\r\nfunction LongType() { PrimitiveType.call(this); }\r\nutil.inherits(LongType, PrimitiveType);\r\n\r\nLongType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'number' && val % 1 === 0 && isSafeLong(val);\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nLongType.prototype._read = function (tap) {\r\n  var n = tap.readLong();\r\n  if (!isSafeLong(n)) {\r\n    throw new Error('potential precision loss');\r\n  }\r\n  return n;\r\n};\r\n\r\nLongType.prototype._skip = function (tap) { tap.skipLong(); };\r\n\r\nLongType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'number' || val % 1 || !isSafeLong(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeLong(val);\r\n};\r\n\r\nLongType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchLong(tap2);\r\n};\r\n\r\nLongType.prototype._update = function (resolver, type) {\r\n  switch (type.typeName) {\r\n    case 'int':\r\n      resolver._read = type._read;\r\n      break;\r\n    case 'abstract:long':\r\n    case 'long':\r\n      resolver._read = this._read; // In case `type` is an `AbstractLongType`.\r\n  }\r\n};\r\n\r\nLongType.prototype.typeName = 'long';\r\n\r\nLongType.prototype.random = function () { return RANDOM.nextInt(); };\r\n\r\nLongType.__with = function (methods, noUnpack) {\r\n  methods = methods || {}; // Will give a more helpful error message.\r\n  // We map some of the methods to a different name to be able to intercept\r\n  // their input and output (otherwise we wouldn't be able to perform any\r\n  // unpacking logic, and the type wouldn't work when nested).\r\n  var mapping = {\r\n    toBuffer: '_toBuffer',\r\n    fromBuffer: '_fromBuffer',\r\n    fromJSON: '_fromJSON',\r\n    toJSON: '_toJSON',\r\n    isValid: '_isValid',\r\n    compare: 'compare'\r\n  };\r\n  var type = new AbstractLongType(noUnpack);\r\n  Object.keys(mapping).forEach(function (name) {\r\n    if (methods[name] === undefined) {\r\n      throw new Error(f('missing method implementation: %s', name));\r\n    }\r\n    type[mapping[name]] = methods[name];\r\n  });\r\n  return Object.freeze(type);\r\n};\r\n\r\n/** Floats. */\r\nfunction FloatType() { PrimitiveType.call(this); }\r\nutil.inherits(FloatType, PrimitiveType);\r\n\r\nFloatType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'number';\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nFloatType.prototype._read = function (tap) { return tap.readFloat(); };\r\n\r\nFloatType.prototype._skip = function (tap) { tap.skipFloat(); };\r\n\r\nFloatType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'number') {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeFloat(val);\r\n};\r\n\r\nFloatType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchFloat(tap2);\r\n};\r\n\r\nFloatType.prototype._update = function (resolver, type) {\r\n  switch (type.typeName) {\r\n    case 'float':\r\n    case 'int':\r\n      resolver._read = type._read;\r\n      break;\r\n    case 'abstract:long':\r\n    case 'long':\r\n      // No need to worry about precision loss here since we're always rounding\r\n      // to float anyway.\r\n      resolver._read = function (tap) { return tap.readLong(); };\r\n  }\r\n};\r\n\r\nFloatType.prototype.typeName = 'float';\r\n\r\nFloatType.prototype.random = function () { return RANDOM.nextFloat(1e3); };\r\n\r\n/** Doubles. */\r\nfunction DoubleType() { PrimitiveType.call(this); }\r\nutil.inherits(DoubleType, PrimitiveType);\r\n\r\nDoubleType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'number';\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nDoubleType.prototype._read = function (tap) { return tap.readDouble(); };\r\n\r\nDoubleType.prototype._skip = function (tap) { tap.skipDouble(); };\r\n\r\nDoubleType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'number') {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeDouble(val);\r\n};\r\n\r\nDoubleType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchDouble(tap2);\r\n};\r\n\r\nDoubleType.prototype._update = function (resolver, type) {\r\n  switch (type.typeName) {\r\n    case 'double':\r\n    case 'float':\r\n    case 'int':\r\n      resolver._read = type._read;\r\n      break;\r\n    case 'abstract:long':\r\n    case 'long':\r\n      // Similar to inside `FloatType`, no need to worry about precision loss\r\n      // here since we're always rounding to double anyway.\r\n      resolver._read = function (tap) { return tap.readLong(); };\r\n  }\r\n};\r\n\r\nDoubleType.prototype.typeName = 'double';\r\n\r\nDoubleType.prototype.random = function () { return RANDOM.nextFloat(); };\r\n\r\n/** Strings. */\r\nfunction StringType() { PrimitiveType.call(this); }\r\nutil.inherits(StringType, PrimitiveType);\r\n\r\nStringType.prototype._check = function (val, flags, hook) {\r\n  var b = typeof val == 'string';\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nStringType.prototype._read = function (tap) { return tap.readString(); };\r\n\r\nStringType.prototype._skip = function (tap) { tap.skipString(); };\r\n\r\nStringType.prototype._write = function (tap, val) {\r\n  if (typeof val != 'string') {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeString(val);\r\n};\r\n\r\nStringType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchString(tap2);\r\n};\r\n\r\nStringType.prototype._update = function (resolver, type) {\r\n  switch (type.typeName) {\r\n    case 'bytes':\r\n    case 'string':\r\n      resolver._read = this._read;\r\n  }\r\n};\r\n\r\nStringType.prototype.typeName = 'string';\r\n\r\nStringType.prototype.random = function () {\r\n  return RANDOM.nextString(RANDOM.nextInt(32));\r\n};\r\n\r\n/**\r\n * Bytes.\r\n *\r\n * These are represented in memory as `Buffer`s rather than binary-encoded\r\n * strings. This is more efficient (when decoding/encoding from bytes, the\r\n * common use-case), idiomatic, and convenient.\r\n *\r\n * Note the coercion in `_copy`.\r\n */\r\nfunction BytesType() { PrimitiveType.call(this); }\r\nutil.inherits(BytesType, PrimitiveType);\r\n\r\nBytesType.prototype._check = function (val, flags, hook) {\r\n  var b = Buffer.isBuffer(val);\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nBytesType.prototype._read = function (tap) { return tap.readBytes(); };\r\n\r\nBytesType.prototype._skip = function (tap) { tap.skipBytes(); };\r\n\r\nBytesType.prototype._write = function (tap, val) {\r\n  if (!Buffer.isBuffer(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeBytes(val);\r\n};\r\n\r\nBytesType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchBytes(tap2);\r\n};\r\n\r\nBytesType.prototype._update = StringType.prototype._update;\r\n\r\nBytesType.prototype._copy = function (obj, opts) {\r\n  var buf;\r\n  switch ((opts && opts.coerce) | 0) {\r\n    case 3: // Coerce buffers to strings.\r\n      this._check(obj, undefined, throwInvalidError);\r\n      return obj.toString('binary');\r\n    case 2: // Coerce strings to buffers.\r\n      if (typeof obj != 'string') {\r\n        throw new Error(f('cannot coerce to buffer: %j', obj));\r\n      }\r\n      buf = utils.bufferFrom(obj, 'binary');\r\n      this._check(buf, undefined, throwInvalidError);\r\n      return buf;\r\n    case 1: // Coerce buffer JSON representation to buffers.\r\n      if (!isJsonBuffer(obj)) {\r\n        throw new Error(f('cannot coerce to buffer: %j', obj));\r\n      }\r\n      buf = utils.bufferFrom(obj.data);\r\n      this._check(buf, undefined, throwInvalidError);\r\n      return buf;\r\n    default: // Copy buffer.\r\n      this._check(obj, undefined, throwInvalidError);\r\n      return utils.bufferFrom(obj);\r\n  }\r\n};\r\n\r\nBytesType.prototype.compare = Buffer.compare;\r\n\r\nBytesType.prototype.typeName = 'bytes';\r\n\r\nBytesType.prototype.random = function () {\r\n  return RANDOM.nextBuffer(RANDOM.nextInt(32));\r\n};\r\n\r\n/** Base \"abstract\" Avro union type. */\r\nfunction UnionType(schema, opts) {\r\n  Type.call(this);\r\n\r\n  if (!Array.isArray(schema)) {\r\n    throw new Error(f('non-array union schema: %j', schema));\r\n  }\r\n  if (!schema.length) {\r\n    throw new Error('empty union');\r\n  }\r\n  this.types = Object.freeze(schema.map(function (obj) {\r\n    return Type.forSchema(obj, opts);\r\n  }));\r\n\r\n  this._branchIndices = {};\r\n  this.types.forEach(function (type, i) {\r\n    if (Type.isType(type, 'union')) {\r\n      throw new Error('unions cannot be directly nested');\r\n    }\r\n    var branch = type.branchName;\r\n    if (this._branchIndices[branch] !== undefined) {\r\n      throw new Error(f('duplicate union branch name: %j', branch));\r\n    }\r\n    this._branchIndices[branch] = i;\r\n  }, this);\r\n}\r\nutil.inherits(UnionType, Type);\r\n\r\nUnionType.prototype._branchConstructor = function () {\r\n  throw new Error('unions cannot be directly wrapped');\r\n};\r\n\r\nUnionType.prototype._skip = function (tap) {\r\n  this.types[tap.readLong()]._skip(tap);\r\n};\r\n\r\nUnionType.prototype._match = function (tap1, tap2) {\r\n  var n1 = tap1.readLong();\r\n  var n2 = tap2.readLong();\r\n  if (n1 === n2) {\r\n    return this.types[n1]._match(tap1, tap2);\r\n  } else {\r\n    return n1 < n2 ? -1 : 1;\r\n  }\r\n};\r\n\r\nUnionType.prototype._deref = function (schema, opts) {\r\n  return this.types.map(function (t) { return t._attrs(opts); });\r\n};\r\n\r\nUnionType.prototype.getTypes = function () { return this.types; };\r\n\r\n/**\r\n * \"Natural\" union type.\r\n *\r\n * This representation doesn't require a wrapping object and is therefore\r\n * simpler and generally closer to what users expect. However it cannot be used\r\n * to represent all Avro unions since some lead to ambiguities (e.g. if two\r\n * number types are in the union).\r\n *\r\n * Currently, this union supports at most one type in each of the categories\r\n * below:\r\n *\r\n * + `null`\r\n * + `boolean`\r\n * + `int`, `long`, `float`, `double`\r\n * + `string`, `enum`\r\n * + `bytes`, `fixed`\r\n * + `array`\r\n * + `map`, `record`\r\n */\r\nfunction UnwrappedUnionType(schema, opts) {\r\n  UnionType.call(this, schema, opts);\r\n\r\n  this._dynamicBranches = null;\r\n  this._bucketIndices = {};\r\n  this.types.forEach(function (type, index) {\r\n    if (Type.isType(type, 'abstract', 'logical')) {\r\n      if (!this._dynamicBranches) {\r\n        this._dynamicBranches = [];\r\n      }\r\n      this._dynamicBranches.push({index: index, type: type});\r\n    } else {\r\n      var bucket = getTypeBucket(type);\r\n      if (this._bucketIndices[bucket] !== undefined) {\r\n        throw new Error(f('ambiguous unwrapped union: %j', this));\r\n      }\r\n      this._bucketIndices[bucket] = index;\r\n    }\r\n  }, this);\r\n\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(UnwrappedUnionType, UnionType);\r\n\r\nUnwrappedUnionType.prototype._getIndex = function (val) {\r\n  var index = this._bucketIndices[getValueBucket(val)];\r\n  if (this._dynamicBranches) {\r\n    // Slower path, we must run the value through all branches.\r\n    index = this._getBranchIndex(val, index);\r\n  }\r\n  return index;\r\n};\r\n\r\nUnwrappedUnionType.prototype._getBranchIndex = function (any, index) {\r\n  var logicalBranches = this._dynamicBranches;\r\n  var i, l, branch;\r\n  for (i = 0, l = logicalBranches.length; i < l; i++) {\r\n    branch = logicalBranches[i];\r\n    if (branch.type._check(any)) {\r\n      if (index === undefined) {\r\n        index = branch.index;\r\n      } else {\r\n        // More than one branch matches the value so we aren't guaranteed to\r\n        // infer the correct type. We throw rather than corrupt data. This can\r\n        // be fixed by \"tightening\" the logical types.\r\n        throw new Error('ambiguous conversion');\r\n      }\r\n    }\r\n  }\r\n  return index;\r\n};\r\n\r\nUnwrappedUnionType.prototype._check = function (val, flags, hook, path) {\r\n  var index = this._getIndex(val);\r\n  var b = index !== undefined;\r\n  if (b) {\r\n    return this.types[index]._check(val, flags, hook, path);\r\n  }\r\n  if (hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nUnwrappedUnionType.prototype._read = function (tap) {\r\n  var index = tap.readLong();\r\n  var branchType = this.types[index];\r\n  if (branchType) {\r\n    return branchType._read(tap);\r\n  } else {\r\n    throw new Error(f('invalid union index: %s', index));\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype._write = function (tap, val) {\r\n  var index = this._getIndex(val);\r\n  if (index === undefined) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeLong(index);\r\n  if (val !== null) {\r\n    this.types[index]._write(tap, val);\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype._update = function (resolver, type, opts) {\r\n  // jshint -W083\r\n  // (The loop exits after the first function is created.)\r\n  var i, l, typeResolver;\r\n  for (i = 0, l = this.types.length; i < l; i++) {\r\n    try {\r\n      typeResolver = this.types[i].createResolver(type, opts);\r\n    } catch (err) {\r\n      continue;\r\n    }\r\n    resolver._read = function (tap) { return typeResolver._read(tap); };\r\n    return;\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype._copy = function (val, opts) {\r\n  var coerce = opts && opts.coerce | 0;\r\n  var wrap = opts && opts.wrap | 0;\r\n  var index;\r\n  if (wrap === 2) {\r\n    // We are parsing a default, so always use the first branch's type.\r\n    index = 0;\r\n  } else {\r\n    switch (coerce) {\r\n      case 1:\r\n        // Using the `coerceBuffers` option can cause corruption and erroneous\r\n        // failures with unwrapped unions (in rare cases when the union also\r\n        // contains a record which matches a buffer's JSON representation).\r\n        if (isJsonBuffer(val) && this._bucketIndices.buffer !== undefined) {\r\n          index = this._bucketIndices.buffer;\r\n        } else {\r\n          index = this._getIndex(val);\r\n        }\r\n        break;\r\n      case 2:\r\n        // Decoding from JSON, we must unwrap the value.\r\n        if (val === null) {\r\n          index = this._bucketIndices['null'];\r\n        } else if (typeof val === 'object') {\r\n          var keys = Object.keys(val);\r\n          if (keys.length === 1) {\r\n            index = this._branchIndices[keys[0]];\r\n            val = val[keys[0]];\r\n          }\r\n        }\r\n        break;\r\n      default:\r\n        index = this._getIndex(val);\r\n    }\r\n    if (index === undefined) {\r\n      throwInvalidError(val, this);\r\n    }\r\n  }\r\n  var type = this.types[index];\r\n  if (val === null || wrap === 3) {\r\n    return type._copy(val, opts);\r\n  } else {\r\n    switch (coerce) {\r\n      case 3:\r\n        // Encoding to JSON, we wrap the value.\r\n        var obj = {};\r\n        obj[type.branchName] = type._copy(val, opts);\r\n        return obj;\r\n      default:\r\n        return type._copy(val, opts);\r\n    }\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype.compare = function (val1, val2) {\r\n  var index1 = this._getIndex(val1);\r\n  var index2 = this._getIndex(val2);\r\n  if (index1 === undefined) {\r\n    throwInvalidError(val1, this);\r\n  } else if (index2 === undefined) {\r\n    throwInvalidError(val2, this);\r\n  } else if (index1 === index2) {\r\n    return this.types[index1].compare(val1, val2);\r\n  } else {\r\n    return utils.compare(index1, index2);\r\n  }\r\n};\r\n\r\nUnwrappedUnionType.prototype.typeName = 'union:unwrapped';\r\n\r\nUnwrappedUnionType.prototype.random = function () {\r\n  var index = RANDOM.nextInt(this.types.length);\r\n  return this.types[index].random();\r\n};\r\n\r\n/**\r\n * Compatible union type.\r\n *\r\n * Values of this type are represented in memory similarly to their JSON\r\n * representation (i.e. inside an object with single key the name of the\r\n * contained type).\r\n *\r\n * This is not ideal, but is the most efficient way to unambiguously support\r\n * all unions. Here are a few reasons why the wrapping object is necessary:\r\n *\r\n * + Unions with multiple number types would have undefined behavior, unless\r\n *   numbers are wrapped (either everywhere, leading to large performance and\r\n *   convenience costs; or only when necessary inside unions, making it hard to\r\n *   understand when numbers are wrapped or not).\r\n * + Fixed types would have to be wrapped to be distinguished from bytes.\r\n * + Using record's constructor names would work (after a slight change to use\r\n *   the fully qualified name), but would mean that generic objects could no\r\n *   longer be valid records (making it inconvenient to do simple things like\r\n *   creating new records).\r\n */\r\nfunction WrappedUnionType(schema, opts) {\r\n  UnionType.call(this, schema, opts);\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(WrappedUnionType, UnionType);\r\n\r\nWrappedUnionType.prototype._check = function (val, flags, hook, path) {\r\n  var b = false;\r\n  if (val === null) {\r\n    // Shortcut type lookup in this case.\r\n    b = this._branchIndices['null'] !== undefined;\r\n  } else if (typeof val == 'object') {\r\n    var keys = Object.keys(val);\r\n    if (keys.length === 1) {\r\n      // We require a single key here to ensure that writes are correct and\r\n      // efficient as soon as a record passes this check.\r\n      var name = keys[0];\r\n      var index = this._branchIndices[name];\r\n      if (index !== undefined) {\r\n        if (hook) {\r\n          // Slow path.\r\n          path.push(name);\r\n          b = this.types[index]._check(val[name], flags, hook, path);\r\n          path.pop();\r\n          return b;\r\n        } else {\r\n          return this.types[index]._check(val[name], flags);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nWrappedUnionType.prototype._read = function (tap) {\r\n  var type = this.types[tap.readLong()];\r\n  if (!type) {\r\n    throw new Error(f('invalid union index'));\r\n  }\r\n  var Branch = type._branchConstructor;\r\n  if (Branch === null) {\r\n    return null;\r\n  } else {\r\n    return new Branch(type._read(tap));\r\n  }\r\n};\r\n\r\nWrappedUnionType.prototype._write = function (tap, val) {\r\n  var index, keys, name;\r\n  if (val === null) {\r\n    index = this._branchIndices['null'];\r\n    if (index === undefined) {\r\n      throwInvalidError(val, this);\r\n    }\r\n    tap.writeLong(index);\r\n  } else {\r\n    keys = Object.keys(val);\r\n    if (keys.length === 1) {\r\n      name = keys[0];\r\n      index = this._branchIndices[name];\r\n    }\r\n    if (index === undefined) {\r\n      throwInvalidError(val, this);\r\n    }\r\n    tap.writeLong(index);\r\n    this.types[index]._write(tap, val[name]);\r\n  }\r\n};\r\n\r\nWrappedUnionType.prototype._update = function (resolver, type, opts) {\r\n  // jshint -W083\r\n  // (The loop exits after the first function is created.)\r\n  var i, l, typeResolver, Branch;\r\n  for (i = 0, l = this.types.length; i < l; i++) {\r\n    try {\r\n      typeResolver = this.types[i].createResolver(type, opts);\r\n    } catch (err) {\r\n      continue;\r\n    }\r\n    Branch = this.types[i]._branchConstructor;\r\n    if (Branch) {\r\n      resolver._read = function (tap) {\r\n        return new Branch(typeResolver._read(tap));\r\n      };\r\n    } else {\r\n      resolver._read = function () { return null; };\r\n    }\r\n    return;\r\n  }\r\n};\r\n\r\nWrappedUnionType.prototype._copy = function (val, opts) {\r\n  var wrap = opts && opts.wrap | 0;\r\n  if (wrap === 2) {\r\n    var firstType = this.types[0];\r\n    // Promote into first type (used for schema defaults).\r\n    if (val === null && firstType.typeName === 'null') {\r\n      return null;\r\n    }\r\n    return new firstType._branchConstructor(firstType._copy(val, opts));\r\n  }\r\n  if (val === null && this._branchIndices['null'] !== undefined) {\r\n    return null;\r\n  }\r\n\r\n  var i, l, obj;\r\n  if (typeof val == 'object') {\r\n    var keys = Object.keys(val);\r\n    if (keys.length === 1) {\r\n      var name = keys[0];\r\n      i = this._branchIndices[name];\r\n      if (i === undefined && opts.qualifyNames) {\r\n        // We are a bit more flexible than in `_check` here since we have\r\n        // to deal with other serializers being less strict, so we fall\r\n        // back to looking up unqualified names.\r\n        var j, type;\r\n        for (j = 0, l = this.types.length; j < l; j++) {\r\n          type = this.types[j];\r\n          if (type.name && name === utils.unqualify(type.name)) {\r\n            i = j;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      if (i !== undefined) {\r\n        obj = this.types[i]._copy(val[name], opts);\r\n      }\r\n    }\r\n  }\r\n  if (wrap === 1 && obj === undefined) {\r\n    // Try promoting into first match (convenience, slow).\r\n    i = 0;\r\n    l = this.types.length;\r\n    while (i < l && obj === undefined) {\r\n      try {\r\n        obj = this.types[i]._copy(val, opts);\r\n      } catch (err) {\r\n        i++;\r\n      }\r\n    }\r\n  }\r\n  if (obj !== undefined) {\r\n    return wrap === 3 ? obj : new this.types[i]._branchConstructor(obj);\r\n  }\r\n  throwInvalidError(val, this);\r\n};\r\n\r\nWrappedUnionType.prototype.compare = function (val1, val2) {\r\n  var name1 = val1 === null ? 'null' : Object.keys(val1)[0];\r\n  var name2 = val2 === null ? 'null' : Object.keys(val2)[0];\r\n  var index = this._branchIndices[name1];\r\n  if (name1 === name2) {\r\n    return name1 === 'null' ?\r\n      0 :\r\n      this.types[index].compare(val1[name1], val2[name1]);\r\n  } else {\r\n    return utils.compare(index, this._branchIndices[name2]);\r\n  }\r\n};\r\n\r\nWrappedUnionType.prototype.typeName = 'union:wrapped';\r\n\r\nWrappedUnionType.prototype.random = function () {\r\n  var index = RANDOM.nextInt(this.types.length);\r\n  var type = this.types[index];\r\n  var Branch = type._branchConstructor;\r\n  if (!Branch) {\r\n    return null;\r\n  }\r\n  return new Branch(type.random());\r\n};\r\n\r\n/**\r\n * Avro enum type.\r\n *\r\n * Represented as strings (with allowed values from the set of symbols). Using\r\n * integers would be a reasonable option, but the performance boost is arguably\r\n * offset by the legibility cost and the extra deviation from the JSON encoding\r\n * convention.\r\n *\r\n * An integer representation can still be used (e.g. for compatibility with\r\n * TypeScript `enum`s) by overriding the `EnumType` with a `LongType` (e.g. via\r\n * `parse`'s registry).\r\n */\r\nfunction EnumType(schema, opts) {\r\n  Type.call(this, schema, opts);\r\n  if (!Array.isArray(schema.symbols) || !schema.symbols.length) {\r\n    throw new Error(f('invalid enum symbols: %j', schema.symbols));\r\n  }\r\n  this.symbols = Object.freeze(schema.symbols.slice());\r\n  this._indices = {};\r\n  this.symbols.forEach(function (symbol, i) {\r\n    if (!utils.isValidName(symbol)) {\r\n      throw new Error(f('invalid %s symbol: %j', this, symbol));\r\n    }\r\n    if (this._indices[symbol] !== undefined) {\r\n      throw new Error(f('duplicate %s symbol: %j', this, symbol));\r\n    }\r\n    this._indices[symbol] = i;\r\n  }, this);\r\n  this.default = schema.default;\r\n  if (this.default !== undefined && this._indices[this.default] === undefined) {\r\n    throw new Error(f('invalid %s default: %j', this, this.default));\r\n  }\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(EnumType, Type);\r\n\r\nEnumType.prototype._check = function (val, flags, hook) {\r\n  var b = this._indices[val] !== undefined;\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nEnumType.prototype._read = function (tap) {\r\n  var index = tap.readLong();\r\n  var symbol = this.symbols[index];\r\n  if (symbol === undefined) {\r\n    throw new Error(f('invalid %s enum index: %s', this.name, index));\r\n  }\r\n  return symbol;\r\n};\r\n\r\nEnumType.prototype._skip = function (tap) { tap.skipLong(); };\r\n\r\nEnumType.prototype._write = function (tap, val) {\r\n  var index = this._indices[val];\r\n  if (index === undefined) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeLong(index);\r\n};\r\n\r\nEnumType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchLong(tap2);\r\n};\r\n\r\nEnumType.prototype.compare = function (val1, val2) {\r\n  return utils.compare(this._indices[val1], this._indices[val2]);\r\n};\r\n\r\nEnumType.prototype._update = function (resolver, type, opts) {\r\n  var symbols = this.symbols;\r\n  if (\r\n    type.typeName === 'enum' &&\r\n    hasCompatibleName(this, type, !opts.ignoreNamespaces) &&\r\n    (\r\n      type.symbols.every(function (s) { return ~symbols.indexOf(s); }) ||\r\n      this.default !== undefined\r\n    )\r\n  ) {\r\n    resolver.symbols = type.symbols.map(function (s) {\r\n      return this._indices[s] === undefined ? this.default : s;\r\n    }, this);\r\n    resolver._read = type._read;\r\n  }\r\n};\r\n\r\nEnumType.prototype._copy = function (val) {\r\n  this._check(val, undefined, throwInvalidError);\r\n  return val;\r\n};\r\n\r\nEnumType.prototype._deref = function (schema) {\r\n  schema.symbols = this.symbols;\r\n};\r\n\r\nEnumType.prototype.getSymbols = function () { return this.symbols; };\r\n\r\nEnumType.prototype.typeName = 'enum';\r\n\r\nEnumType.prototype.random = function () {\r\n  return RANDOM.choice(this.symbols);\r\n};\r\n\r\n/** Avro fixed type. Represented simply as a `Buffer`. */\r\nfunction FixedType(schema, opts) {\r\n  Type.call(this, schema, opts);\r\n  if (schema.size !== (schema.size | 0) || schema.size < 0) {\r\n    throw new Error(f('invalid %s size', this.branchName));\r\n  }\r\n  this.size = schema.size | 0;\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(FixedType, Type);\r\n\r\nFixedType.prototype._check = function (val, flags, hook) {\r\n  var b = Buffer.isBuffer(val) && val.length === this.size;\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nFixedType.prototype._read = function (tap) {\r\n  return tap.readFixed(this.size);\r\n};\r\n\r\nFixedType.prototype._skip = function (tap) {\r\n  tap.skipFixed(this.size);\r\n};\r\n\r\nFixedType.prototype._write = function (tap, val) {\r\n  if (!Buffer.isBuffer(val) || val.length !== this.size) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  tap.writeFixed(val, this.size);\r\n};\r\n\r\nFixedType.prototype._match = function (tap1, tap2) {\r\n  return tap1.matchFixed(tap2, this.size);\r\n};\r\n\r\nFixedType.prototype.compare = Buffer.compare;\r\n\r\nFixedType.prototype._update = function (resolver, type, opts) {\r\n  if (\r\n    type.typeName === 'fixed' &&\r\n    this.size === type.size &&\r\n    hasCompatibleName(this, type, !opts.ignoreNamespaces)\r\n  ) {\r\n    resolver.size = this.size;\r\n    resolver._read = this._read;\r\n  }\r\n};\r\n\r\nFixedType.prototype._copy = BytesType.prototype._copy;\r\n\r\nFixedType.prototype._deref = function (schema) { schema.size = this.size; };\r\n\r\nFixedType.prototype.getSize = function () { return this.size; };\r\n\r\nFixedType.prototype.typeName = 'fixed';\r\n\r\nFixedType.prototype.random = function () {\r\n  return RANDOM.nextBuffer(this.size);\r\n};\r\n\r\n/** Avro map. Represented as vanilla objects. */\r\nfunction MapType(schema, opts) {\r\n  Type.call(this);\r\n  if (!schema.values) {\r\n    throw new Error(f('missing map values: %j', schema));\r\n  }\r\n  this.valuesType = Type.forSchema(schema.values, opts);\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(MapType, Type);\r\n\r\nMapType.prototype._check = function (val, flags, hook, path) {\r\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\r\n    if (hook) {\r\n      hook(val, this);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  var keys = Object.keys(val);\r\n  var b = true;\r\n  var i, l, j, key;\r\n  if (hook) {\r\n    // Slow path.\r\n    j = path.length;\r\n    path.push('');\r\n    for (i = 0, l = keys.length; i < l; i++) {\r\n      key = path[j] = keys[i];\r\n      if (!this.valuesType._check(val[key], flags, hook, path)) {\r\n        b = false;\r\n      }\r\n    }\r\n    path.pop();\r\n  } else {\r\n    for (i = 0, l = keys.length; i < l; i++) {\r\n      if (!this.valuesType._check(val[keys[i]], flags)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return b;\r\n};\r\n\r\nMapType.prototype._read = function (tap) {\r\n  var values = this.valuesType;\r\n  var val = {};\r\n  var n;\r\n  while ((n = readArraySize(tap))) {\r\n    while (n--) {\r\n      var key = tap.readString();\r\n      val[key] = values._read(tap);\r\n    }\r\n  }\r\n  return val;\r\n};\r\n\r\nMapType.prototype._skip = function (tap) {\r\n  var values = this.valuesType;\r\n  var len, n;\r\n  while ((n = tap.readLong())) {\r\n    if (n < 0) {\r\n      len = tap.readLong();\r\n      tap.pos += len;\r\n    } else {\r\n      while (n--) {\r\n        tap.skipString();\r\n        values._skip(tap);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nMapType.prototype._write = function (tap, val) {\r\n  if (!val || typeof val != 'object' || Array.isArray(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n\r\n  var values = this.valuesType;\r\n  var keys = Object.keys(val);\r\n  var n = keys.length;\r\n  var i, key;\r\n  if (n) {\r\n    tap.writeLong(n);\r\n    for (i = 0; i < n; i++) {\r\n      key = keys[i];\r\n      tap.writeString(key);\r\n      values._write(tap, val[key]);\r\n    }\r\n  }\r\n  tap.writeLong(0);\r\n};\r\n\r\nMapType.prototype._match = function () {\r\n  throw new Error('maps cannot be compared');\r\n};\r\n\r\nMapType.prototype._update = function (rsv, type, opts) {\r\n  if (type.typeName === 'map') {\r\n    rsv.valuesType = this.valuesType.createResolver(type.valuesType, opts);\r\n    rsv._read = this._read;\r\n  }\r\n};\r\n\r\nMapType.prototype._copy = function (val, opts) {\r\n  if (val && typeof val == 'object' && !Array.isArray(val)) {\r\n    var values = this.valuesType;\r\n    var keys = Object.keys(val);\r\n    var i, l, key;\r\n    var copy = {};\r\n    for (i = 0, l = keys.length; i < l; i++) {\r\n      key = keys[i];\r\n      copy[key] = values._copy(val[key], opts);\r\n    }\r\n    return copy;\r\n  }\r\n  throwInvalidError(val, this);\r\n};\r\n\r\nMapType.prototype.compare = MapType.prototype._match;\r\n\r\nMapType.prototype.typeName = 'map';\r\n\r\nMapType.prototype.getValuesType = function () { return this.valuesType; };\r\n\r\nMapType.prototype.random = function () {\r\n  var val = {};\r\n  var i, l;\r\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\r\n    val[RANDOM.nextString(RANDOM.nextInt(20))] = this.valuesType.random();\r\n  }\r\n  return val;\r\n};\r\n\r\nMapType.prototype._deref = function (schema, opts) {\r\n  schema.values = this.valuesType._attrs(opts);\r\n};\r\n\r\n/** Avro array. Represented as vanilla arrays. */\r\nfunction ArrayType(schema, opts) {\r\n  Type.call(this);\r\n  if (!schema.items) {\r\n    throw new Error(f('missing array items: %j', schema));\r\n  }\r\n  this.itemsType = Type.forSchema(schema.items, opts);\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(ArrayType, Type);\r\n\r\nArrayType.prototype._check = function (val, flags, hook, path) {\r\n  if (!Array.isArray(val)) {\r\n    if (hook) {\r\n      hook(val, this);\r\n    }\r\n    return false;\r\n  }\r\n  var items = this.itemsType;\r\n  var b = true;\r\n  var i, l, j;\r\n  if (hook) {\r\n    // Slow path.\r\n    j = path.length;\r\n    path.push('');\r\n    for (i = 0, l = val.length; i < l; i++) {\r\n      path[j] = '' + i;\r\n      if (!items._check(val[i], flags, hook, path)) {\r\n        b = false;\r\n      }\r\n    }\r\n    path.pop();\r\n  } else {\r\n    for (i = 0, l = val.length; i < l; i++) {\r\n      if (!items._check(val[i], flags)) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return b;\r\n};\r\n\r\nArrayType.prototype._read = function (tap) {\r\n  var items = this.itemsType;\r\n  var i = 0;\r\n  var val, n;\r\n  while ((n = tap.readLong())) {\r\n    if (n < 0) {\r\n      n = -n;\r\n      tap.skipLong(); // Skip size.\r\n    }\r\n    // Initializing the array on the first batch gives a ~10% speedup. See\r\n    // https://github.com/mtth/avsc/pull/338 for more context.\r\n    val = val || new Array(n)\r\n    while (n--) {\r\n      val[i++] = items._read(tap);\r\n    }\r\n  }\r\n  return val || [];\r\n};\r\n\r\nArrayType.prototype._skip = function (tap) {\r\n  var items = this.itemsType;\r\n  var len, n;\r\n  while ((n = tap.readLong())) {\r\n    if (n < 0) {\r\n      len = tap.readLong();\r\n      tap.pos += len;\r\n    } else {\r\n      while (n--) {\r\n        items._skip(tap);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nArrayType.prototype._write = function (tap, val) {\r\n  if (!Array.isArray(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  var items = this.itemsType;\r\n  var n = val.length;\r\n  var i;\r\n  if (n) {\r\n    tap.writeLong(n);\r\n    for (i = 0; i < n; i++) {\r\n      items._write(tap, val[i]);\r\n    }\r\n  }\r\n  tap.writeLong(0);\r\n};\r\n\r\nArrayType.prototype._match = function (tap1, tap2) {\r\n  var n1 = tap1.readLong();\r\n  var n2 = tap2.readLong();\r\n  var f;\r\n  while (n1 && n2) {\r\n    f = this.itemsType._match(tap1, tap2);\r\n    if (f) {\r\n      return f;\r\n    }\r\n    if (!--n1) {\r\n      n1 = readArraySize(tap1);\r\n    }\r\n    if (!--n2) {\r\n      n2 = readArraySize(tap2);\r\n    }\r\n  }\r\n  return utils.compare(n1, n2);\r\n};\r\n\r\nArrayType.prototype._update = function (resolver, type, opts) {\r\n  if (type.typeName === 'array') {\r\n    resolver.itemsType = this.itemsType.createResolver(type.itemsType, opts);\r\n    resolver._read = this._read;\r\n  }\r\n};\r\n\r\nArrayType.prototype._copy = function (val, opts) {\r\n  if (!Array.isArray(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  var items = new Array(val.length);\r\n  var i, l;\r\n  for (i = 0, l = val.length; i < l; i++) {\r\n    items[i] = this.itemsType._copy(val[i], opts);\r\n  }\r\n  return items;\r\n};\r\n\r\nArrayType.prototype._deref = function (schema, opts) {\r\n  schema.items = this.itemsType._attrs(opts);\r\n};\r\n\r\nArrayType.prototype.compare = function (val1, val2) {\r\n  var n1 = val1.length;\r\n  var n2 = val2.length;\r\n  var i, l, f;\r\n  for (i = 0, l = Math.min(n1, n2); i < l; i++) {\r\n    if ((f = this.itemsType.compare(val1[i], val2[i]))) {\r\n      return f;\r\n    }\r\n  }\r\n  return utils.compare(n1, n2);\r\n};\r\n\r\nArrayType.prototype.getItemsType = function () { return this.itemsType; };\r\n\r\nArrayType.prototype.typeName = 'array';\r\n\r\nArrayType.prototype.random = function () {\r\n  var arr = [];\r\n  var i, l;\r\n  for (i = 0, l = RANDOM.nextInt(10); i < l; i++) {\r\n    arr.push(this.itemsType.random());\r\n  }\r\n  return arr;\r\n};\r\n\r\n/**\r\n * Avro record.\r\n *\r\n * Values are represented as instances of a programmatically generated\r\n * constructor (similar to a \"specific record\"), available via the\r\n * `getRecordConstructor` method. This \"specific record class\" gives\r\n * significant speedups over using generics objects.\r\n *\r\n * Note that vanilla objects are still accepted as valid as long as their\r\n * fields match (this makes it much more convenient to do simple things like\r\n * update nested records).\r\n *\r\n * This type is also used for errors (similar, except for the extra `Error`\r\n * constructor call) and for messages (see comment below).\r\n */\r\nfunction RecordType(schema, opts) {\r\n  // Force creation of the options object in case we need to register this\r\n  // record's name.\r\n  opts = opts || {};\r\n\r\n  // Save the namespace to restore it as we leave this record's scope.\r\n  var namespace = opts.namespace;\r\n  if (schema.namespace !== undefined) {\r\n    opts.namespace = schema.namespace;\r\n  } else if (schema.name) {\r\n    // Fully qualified names' namespaces are used when no explicit namespace\r\n    // attribute was specified.\r\n    var ns = utils.impliedNamespace(schema.name);\r\n    if (ns !== undefined) {\r\n      opts.namespace = ns;\r\n    }\r\n  }\r\n  Type.call(this, schema, opts);\r\n\r\n  if (!Array.isArray(schema.fields)) {\r\n    throw new Error(f('non-array record fields: %j', schema.fields));\r\n  }\r\n  if (utils.hasDuplicates(schema.fields, function (f) { return f.name; })) {\r\n    throw new Error(f('duplicate field name: %j', schema.fields));\r\n  }\r\n  this._fieldsByName = {};\r\n  this.fields = Object.freeze(schema.fields.map(function (f) {\r\n    var field = new Field(f, opts);\r\n    this._fieldsByName[field.name] = field;\r\n    return field;\r\n  }, this));\r\n  this._branchConstructor = this._createBranchConstructor();\r\n  this._isError = schema.type === 'error';\r\n  this.recordConstructor = this._createConstructor(\r\n    opts.errorStackTraces,\r\n    opts.omitRecordMethods\r\n  );\r\n  this._read = this._createReader();\r\n  this._skip = this._createSkipper();\r\n  this._write = this._createWriter();\r\n  this._check = this._createChecker();\r\n\r\n  opts.namespace = namespace;\r\n  Object.freeze(this);\r\n}\r\nutil.inherits(RecordType, Type);\r\n\r\nRecordType.prototype._getConstructorName = function () {\r\n  return this.name ?\r\n    utils.capitalize(utils.unqualify(this.name)) :\r\n    this._isError ? 'Error$' : 'Record$';\r\n};\r\n\r\nRecordType.prototype._createConstructor = function (errorStack, plainRecords) {\r\n  // jshint -W054\r\n  var outerArgs = [];\r\n  var innerArgs = [];\r\n  var ds = []; // Defaults.\r\n  var innerBody = '';\r\n  var i, l, field, name, defaultValue, hasDefault, stackField;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    field = this.fields[i];\r\n    defaultValue = field.defaultValue;\r\n    hasDefault = defaultValue() !== undefined;\r\n    name = field.name;\r\n    if (\r\n      errorStack && this._isError && name === 'stack' &&\r\n      Type.isType(field.type, 'string') && !hasDefault\r\n    ) {\r\n      // We keep track of whether we've encountered a valid stack field (in\r\n      // particular, without a default) to populate a stack trace below.\r\n      stackField = field;\r\n    }\r\n    innerArgs.push('v' + i);\r\n    innerBody += '  ';\r\n    if (!hasDefault) {\r\n      innerBody += 'this.' + name + ' = v' + i + ';\\n';\r\n    } else {\r\n      innerBody += 'if (v' + i + ' === undefined) { ';\r\n      innerBody += 'this.' + name + ' = d' + ds.length + '(); ';\r\n      innerBody += '} else { this.' + name + ' = v' + i + '; }\\n';\r\n      outerArgs.push('d' + ds.length);\r\n      ds.push(defaultValue);\r\n    }\r\n  }\r\n  if (stackField) {\r\n    // We should populate a stack trace.\r\n    innerBody += '  if (this.stack === undefined) { ';\r\n    /* istanbul ignore else */\r\n    if (typeof Error.captureStackTrace == 'function') {\r\n      // v8 runtimes, the easy case.\r\n      innerBody += 'Error.captureStackTrace(this, this.constructor);';\r\n    } else {\r\n      // A few other runtimes (e.g. SpiderMonkey), might not work everywhere.\r\n      innerBody += 'this.stack = Error().stack;';\r\n    }\r\n    innerBody += ' }\\n';\r\n  }\r\n  var outerBody = 'return function ' + this._getConstructorName() + '(';\r\n  outerBody += innerArgs.join() + ') {\\n' + innerBody + '};';\r\n  var Record = new Function(outerArgs.join(), outerBody).apply(undefined, ds);\r\n  if (plainRecords) {\r\n    return Record;\r\n  }\r\n\r\n  var self = this;\r\n  Record.getType = function () { return self; };\r\n  Record.type = self;\r\n  if (this._isError) {\r\n    util.inherits(Record, Error);\r\n    Record.prototype.name = this._getConstructorName();\r\n  }\r\n  Record.prototype.clone = function (o) { return self.clone(this, o); };\r\n  Record.prototype.compare = function (v) { return self.compare(this, v); };\r\n  Record.prototype.isValid = function (o) { return self.isValid(this, o); };\r\n  Record.prototype.toBuffer = function () { return self.toBuffer(this); };\r\n  Record.prototype.toString = function () { return self.toString(this); };\r\n  Record.prototype.wrap = function () { return self.wrap(this); };\r\n  Record.prototype.wrapped = Record.prototype.wrap; // Deprecated.\r\n  return Record;\r\n};\r\n\r\nRecordType.prototype._createChecker = function () {\r\n  // jshint -W054\r\n  var names = [];\r\n  var values = [];\r\n  var name = this._getConstructorName();\r\n  var body = 'return function check' + name + '(v, f, h, p) {\\n';\r\n  body += '  if (\\n';\r\n  body += '    v === null ||\\n';\r\n  body += '    typeof v != \\'object\\' ||\\n';\r\n  body += '    (f && !this._checkFields(v))\\n';\r\n  body += '  ) {\\n';\r\n  body += '    if (h) { h(v, this); }\\n';\r\n  body += '    return false;\\n';\r\n  body += '  }\\n';\r\n  if (!this.fields.length) {\r\n    // Special case, empty record. We handle this directly.\r\n    body += '  return true;\\n';\r\n  } else {\r\n    for (i = 0, l = this.fields.length; i < l; i++) {\r\n      field = this.fields[i];\r\n      names.push('t' + i);\r\n      values.push(field.type);\r\n      if (field.defaultValue() !== undefined) {\r\n        body += '  var v' + i + ' = v.' + field.name + ';\\n';\r\n      }\r\n    }\r\n    body += '  if (h) {\\n';\r\n    body += '    var b = 1;\\n';\r\n    body += '    var j = p.length;\\n';\r\n    body += '    p.push(\\'\\');\\n';\r\n    var i, l, field;\r\n    for (i = 0, l = this.fields.length; i < l; i++) {\r\n      field = this.fields[i];\r\n      body += '    p[j] = \\'' + field.name + '\\';\\n';\r\n      body += '    b &= ';\r\n      if (field.defaultValue() === undefined) {\r\n        body += 't' + i + '._check(v.' + field.name + ', f, h, p);\\n';\r\n      } else {\r\n        body += 'v' + i + ' === undefined || ';\r\n        body += 't' + i + '._check(v' + i + ', f, h, p);\\n';\r\n      }\r\n    }\r\n    body += '    p.pop();\\n';\r\n    body += '    return !!b;\\n';\r\n    body += '  } else {\\n    return (\\n      ';\r\n    body += this.fields.map(function (field, i) {\r\n      return field.defaultValue() === undefined ?\r\n        't' + i + '._check(v.' + field.name + ', f)' :\r\n        '(v' + i + ' === undefined || t' + i + '._check(v' + i + ', f))';\r\n    }).join(' &&\\n      ');\r\n    body += '\\n    );\\n  }\\n';\r\n  }\r\n  body += '};';\r\n  return new Function(names.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._createReader = function () {\r\n  // jshint -W054\r\n  var names = [];\r\n  var values = [this.recordConstructor];\r\n  var i, l;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    names.push('t' + i);\r\n    values.push(this.fields[i].type);\r\n  }\r\n  var name = this._getConstructorName();\r\n  var body = 'return function read' + name + '(t) {\\n';\r\n  body += '  return new ' + name + '(\\n    ';\r\n  body += names.map(function (s) { return s + '._read(t)'; }).join(',\\n    ');\r\n  body += '\\n  );\\n};';\r\n  names.unshift(name);\r\n  // We can do this since the JS spec guarantees that function arguments are\r\n  // evaluated from left to right.\r\n  return new Function(names.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._createSkipper = function () {\r\n  // jshint -W054\r\n  var args = [];\r\n  var body = 'return function skip' + this._getConstructorName() + '(t) {\\n';\r\n  var values = [];\r\n  var i, l;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    args.push('t' + i);\r\n    values.push(this.fields[i].type);\r\n    body += '  t' + i + '._skip(t);\\n';\r\n  }\r\n  body += '}';\r\n  return new Function(args.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._createWriter = function () {\r\n  // jshint -W054\r\n  // We still do default handling here, in case a normal JS object is passed.\r\n  var args = [];\r\n  var name = this._getConstructorName();\r\n  var body = 'return function write' + name + '(t, v) {\\n';\r\n  var values = [];\r\n  var i, l, field, value;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    field = this.fields[i];\r\n    args.push('t' + i);\r\n    values.push(field.type);\r\n    body += '  ';\r\n    if (field.defaultValue() === undefined) {\r\n      body += 't' + i + '._write(t, v.' + field.name + ');\\n';\r\n    } else {\r\n      value = field.type.toBuffer(field.defaultValue()).toString('binary');\r\n      // Convert the default value to a binary string ahead of time. We aren't\r\n      // converting it to a buffer to avoid retaining too much memory. If we\r\n      // had our own buffer pool, this could be an idea in the future.\r\n      args.push('d' + i);\r\n      values.push(value);\r\n      body += 'var v' + i + ' = v.' + field.name + ';\\n';\r\n      body += 'if (v' + i + ' === undefined) {\\n';\r\n      body += '    t.writeBinary(d' + i + ', ' + value.length + ');\\n';\r\n      body += '  } else {\\n    t' + i + '._write(t, v' + i + ');\\n  }\\n';\r\n    }\r\n  }\r\n  body += '}';\r\n  return new Function(args.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._update = function (resolver, type, opts) {\r\n  // jshint -W054\r\n  if (!hasCompatibleName(this, type, !opts.ignoreNamespaces)) {\r\n    throw new Error(f('no alias found for %s', type.name));\r\n  }\r\n\r\n  var rFields = this.fields;\r\n  var wFields = type.fields;\r\n  var wFieldsMap = utils.toMap(wFields, function (f) { return f.name; });\r\n\r\n  var innerArgs = []; // Arguments for reader constructor.\r\n  var resolvers = {}; // Resolvers keyed by writer field name.\r\n  var i, j, field, name, names, matches, fieldResolver;\r\n  for (i = 0; i < rFields.length; i++) {\r\n    field = rFields[i];\r\n    names = getAliases(field);\r\n    matches = [];\r\n    for (j = 0; j < names.length; j++) {\r\n      name = names[j];\r\n      if (wFieldsMap[name]) {\r\n        matches.push(name);\r\n      }\r\n    }\r\n    if (matches.length > 1) {\r\n      throw new Error(\r\n        f('ambiguous aliasing for %s.%s (%s)', type.name, field.name, matches)\r\n      );\r\n    }\r\n    if (!matches.length) {\r\n      if (field.defaultValue() === undefined) {\r\n        throw new Error(\r\n          f('no matching field for default-less %s.%s', type.name, field.name)\r\n        );\r\n      }\r\n      innerArgs.push('undefined');\r\n    } else {\r\n      name = matches[0];\r\n      fieldResolver = {\r\n        resolver: field.type.createResolver(wFieldsMap[name].type, opts),\r\n        name: '_' + field.name, // Reader field name.\r\n      };\r\n      if (!resolvers[name]) {\r\n        resolvers[name] = [fieldResolver];\r\n      } else {\r\n        resolvers[name].push(fieldResolver);\r\n      }\r\n      innerArgs.push(fieldResolver.name);\r\n    }\r\n  }\r\n\r\n  // See if we can add a bypass for unused fields at the end of the record.\r\n  var lazyIndex = -1;\r\n  i = wFields.length;\r\n  while (i && resolvers[wFields[--i].name] === undefined) {\r\n    lazyIndex = i;\r\n  }\r\n\r\n  var uname = this._getConstructorName();\r\n  var args = [uname];\r\n  var values = [this.recordConstructor];\r\n  var body = '  return function read' + uname + '(t, b) {\\n';\r\n  for (i = 0; i < wFields.length; i++) {\r\n    if (i === lazyIndex) {\r\n      body += '  if (!b) {\\n';\r\n    }\r\n    field = type.fields[i];\r\n    name = field.name;\r\n    if (resolvers[name] === undefined) {\r\n      body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';\r\n      args.push('r' + i);\r\n      values.push(field.type);\r\n      body += 'r' + i + '._skip(t);\\n';\r\n    } else {\r\n      j = resolvers[name].length;\r\n      while (j--) {\r\n        body += (~lazyIndex && i >= lazyIndex) ? '    ' : '  ';\r\n        args.push('r' + i + 'f' + j);\r\n        fieldResolver = resolvers[name][j];\r\n        values.push(fieldResolver.resolver);\r\n        body += 'var ' + fieldResolver.name + ' = ';\r\n        body += 'r' + i + 'f' + j + '._' + (j ? 'peek' : 'read') + '(t);\\n';\r\n      }\r\n    }\r\n  }\r\n  if (~lazyIndex) {\r\n    body += '  }\\n';\r\n  }\r\n  body += '  return new ' + uname + '(' + innerArgs.join() + ');\\n};';\r\n\r\n  resolver._read = new Function(args.join(), body).apply(undefined, values);\r\n};\r\n\r\nRecordType.prototype._match = function (tap1, tap2) {\r\n  var fields = this.fields;\r\n  var i, l, field, order, type;\r\n  for (i = 0, l = fields.length; i < l; i++) {\r\n    field = fields[i];\r\n    order = field._order;\r\n    type = field.type;\r\n    if (order) {\r\n      order *= type._match(tap1, tap2);\r\n      if (order) {\r\n        return order;\r\n      }\r\n    } else {\r\n      type._skip(tap1);\r\n      type._skip(tap2);\r\n    }\r\n  }\r\n  return 0;\r\n};\r\n\r\nRecordType.prototype._checkFields = function (obj) {\r\n  var keys = Object.keys(obj);\r\n  var i, l;\r\n  for (i = 0, l = keys.length; i < l; i++) {\r\n    if (!this._fieldsByName[keys[i]]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\nRecordType.prototype._copy = function (val, opts) {\r\n  // jshint -W058\r\n  var hook = opts && opts.fieldHook;\r\n  var values = [undefined];\r\n  var i, l, field, value;\r\n  for (i = 0, l = this.fields.length; i < l; i++) {\r\n    field = this.fields[i];\r\n    value = val[field.name];\r\n    if (value === undefined && field.hasOwnProperty('defaultValue')) {\r\n      value = field.defaultValue();\r\n    }\r\n    if ((opts && !opts.skip) || value !== undefined) {\r\n      value = field.type._copy(value, opts);\r\n    }\r\n    if (hook) {\r\n      value = hook(field, value, this);\r\n    }\r\n    values.push(value);\r\n  }\r\n  var Record = this.recordConstructor;\r\n  return new (Record.bind.apply(Record, values))();\r\n};\r\n\r\nRecordType.prototype._deref = function (schema, opts) {\r\n  schema.fields = this.fields.map(function (field) {\r\n    var fieldType = field.type;\r\n    var fieldSchema = {\r\n      name: field.name,\r\n      type: fieldType._attrs(opts)\r\n    };\r\n    if (opts.exportAttrs) {\r\n      var val = field.defaultValue();\r\n      if (val !== undefined) {\r\n        // We must both unwrap all unions and coerce buffers to strings.\r\n        fieldSchema['default'] = fieldType._copy(val, {coerce: 3, wrap: 3});\r\n      }\r\n      var fieldOrder = field.order;\r\n      if (fieldOrder !== 'ascending') {\r\n        fieldSchema.order = fieldOrder;\r\n      }\r\n      var fieldAliases = field.aliases;\r\n      if (fieldAliases.length) {\r\n        fieldSchema.aliases = fieldAliases;\r\n      }\r\n      var fieldDoc = field.doc;\r\n      if (fieldDoc !== undefined) {\r\n        fieldSchema.doc = fieldDoc;\r\n      }\r\n    }\r\n    return fieldSchema;\r\n  });\r\n};\r\n\r\nRecordType.prototype.compare = function (val1, val2) {\r\n  var fields = this.fields;\r\n  var i, l, field, name, order, type;\r\n  for (i = 0, l = fields.length; i < l; i++) {\r\n    field = fields[i];\r\n    name = field.name;\r\n    order = field._order;\r\n    type = field.type;\r\n    if (order) {\r\n      order *= type.compare(val1[name], val2[name]);\r\n      if (order) {\r\n        return order;\r\n      }\r\n    }\r\n  }\r\n  return 0;\r\n};\r\n\r\nRecordType.prototype.random = function () {\r\n  // jshint -W058\r\n  var fields = this.fields.map(function (f) { return f.type.random(); });\r\n  fields.unshift(undefined);\r\n  var Record = this.recordConstructor;\r\n  return new (Record.bind.apply(Record, fields))();\r\n};\r\n\r\nRecordType.prototype.field = function (name) {\r\n  return this._fieldsByName[name];\r\n};\r\n\r\nRecordType.prototype.getField = RecordType.prototype.field;\r\n\r\nRecordType.prototype.getFields = function () { return this.fields; };\r\n\r\nRecordType.prototype.getRecordConstructor = function () {\r\n  return this.recordConstructor;\r\n};\r\n\r\nObject.defineProperty(RecordType.prototype, 'typeName', {\r\n  enumerable: true,\r\n  get: function () { return this._isError ? 'error' : 'record'; }\r\n});\r\n\r\n/** Derived type abstract class. */\r\nfunction LogicalType(schema, opts) {\r\n  this._logicalTypeName = schema.logicalType;\r\n  Type.call(this);\r\n  LOGICAL_TYPE = this;\r\n  try {\r\n    this._underlyingType = Type.forSchema(schema, opts);\r\n  } finally {\r\n    LOGICAL_TYPE = null;\r\n    // Remove the underlying type now that we're done instantiating. Note that\r\n    // in some (rare) cases, it might not have been inserted; for example, if\r\n    // this constructor was manually called with an already instantiated type.\r\n    var l = UNDERLYING_TYPES.length;\r\n    if (l && UNDERLYING_TYPES[l - 1][0] === this) {\r\n      UNDERLYING_TYPES.pop();\r\n    }\r\n  }\r\n  // We create a separate branch constructor for logical types to keep them\r\n  // monomorphic.\r\n  if (Type.isType(this.underlyingType, 'union')) {\r\n    this._branchConstructor = this.underlyingType._branchConstructor;\r\n  } else {\r\n    this._branchConstructor = this.underlyingType._createBranchConstructor();\r\n  }\r\n  // We don't freeze derived types to allow arbitrary properties. Implementors\r\n  // can still do so in the subclass' constructor at their convenience.\r\n}\r\nutil.inherits(LogicalType, Type);\r\n\r\nObject.defineProperty(LogicalType.prototype, 'typeName', {\r\n  enumerable: true,\r\n  get: function () { return 'logical:' + this._logicalTypeName; }\r\n});\r\n\r\nObject.defineProperty(LogicalType.prototype, 'underlyingType', {\r\n  enumerable: true,\r\n  get: function () {\r\n    if (this._underlyingType) {\r\n      return this._underlyingType;\r\n    }\r\n    // If the field wasn't present, it means the logical type isn't complete\r\n    // yet: we're waiting on its underlying type to be fully instantiated. In\r\n    // this case, it will be present in the `UNDERLYING_TYPES` array.\r\n    var i, l, arr;\r\n    for (i = 0, l = UNDERLYING_TYPES.length; i < l; i++) {\r\n      arr = UNDERLYING_TYPES[i];\r\n      if (arr[0] === this) {\r\n        return arr[1];\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\nLogicalType.prototype.getUnderlyingType = function () {\r\n  return this.underlyingType;\r\n};\r\n\r\nLogicalType.prototype._read = function (tap) {\r\n  return this._fromValue(this.underlyingType._read(tap));\r\n};\r\n\r\nLogicalType.prototype._write = function (tap, any) {\r\n  this.underlyingType._write(tap, this._toValue(any));\r\n};\r\n\r\nLogicalType.prototype._check = function (any, flags, hook, path) {\r\n  try {\r\n    var val = this._toValue(any);\r\n  } catch (err) {\r\n    // Handled below.\r\n  }\r\n  if (val === undefined) {\r\n    if (hook) {\r\n      hook(any, this);\r\n    }\r\n    return false;\r\n  }\r\n  return this.underlyingType._check(val, flags, hook, path);\r\n};\r\n\r\nLogicalType.prototype._copy = function (any, opts) {\r\n  var type = this.underlyingType;\r\n  switch (opts && opts.coerce) {\r\n    case 3: // To string.\r\n      return type._copy(this._toValue(any), opts);\r\n    case 2: // From string.\r\n      return this._fromValue(type._copy(any, opts));\r\n    default: // Normal copy.\r\n      return this._fromValue(type._copy(this._toValue(any), opts));\r\n  }\r\n};\r\n\r\nLogicalType.prototype._update = function (resolver, type, opts) {\r\n  var _fromValue = this._resolve(type, opts);\r\n  if (_fromValue) {\r\n    resolver._read = function (tap) { return _fromValue(type._read(tap)); };\r\n  }\r\n};\r\n\r\nLogicalType.prototype.compare = function (obj1, obj2) {\r\n  var val1 = this._toValue(obj1);\r\n  var val2 = this._toValue(obj2);\r\n  return this.underlyingType.compare(val1, val2);\r\n};\r\n\r\nLogicalType.prototype.random = function () {\r\n  return this._fromValue(this.underlyingType.random());\r\n};\r\n\r\nLogicalType.prototype._deref = function (schema, opts) {\r\n  var type = this.underlyingType;\r\n  var isVisited = type.name !== undefined && opts.derefed[type.name];\r\n  schema = type._attrs(opts);\r\n  if (!isVisited && opts.exportAttrs) {\r\n    if (typeof schema == 'string') {\r\n      schema = {type: schema};\r\n    }\r\n    schema.logicalType = this._logicalTypeName;\r\n    this._export(schema);\r\n  }\r\n  return schema;\r\n};\r\n\r\nLogicalType.prototype._skip = function (tap) {\r\n  this.underlyingType._skip(tap);\r\n};\r\n\r\n// Unlike the other methods below, `_export` has a reasonable default which we\r\n// can provide (not exporting anything).\r\nLogicalType.prototype._export = function (/* schema */) {};\r\n\r\n// Methods to be implemented.\r\nLogicalType.prototype._fromValue = utils.abstractFunction;\r\nLogicalType.prototype._toValue = utils.abstractFunction;\r\nLogicalType.prototype._resolve = utils.abstractFunction;\r\n\r\n\r\n// General helpers.\r\n\r\n/**\r\n * Customizable long.\r\n *\r\n * This allows support of arbitrarily large long (e.g. larger than\r\n * `Number.MAX_SAFE_INTEGER`). See `LongType.__with` method above. Note that we\r\n * can't use a logical type because we need a \"lower-level\" hook here: passing\r\n * through through the standard long would cause a loss of precision.\r\n */\r\nfunction AbstractLongType(noUnpack) {\r\n  this._concreteTypeName = 'long';\r\n  PrimitiveType.call(this, true);\r\n  // Note that this type \"inherits\" `LongType` (i.e. gain its prototype\r\n  // methods) but only \"subclasses\" `PrimitiveType` to avoid being prematurely\r\n  // frozen.\r\n  this._noUnpack = !!noUnpack;\r\n}\r\nutil.inherits(AbstractLongType, LongType);\r\n\r\nAbstractLongType.prototype.typeName = 'abstract:long';\r\n\r\nAbstractLongType.prototype._check = function (val, flags, hook) {\r\n  var b = this._isValid(val);\r\n  if (!b && hook) {\r\n    hook(val, this);\r\n  }\r\n  return b;\r\n};\r\n\r\nAbstractLongType.prototype._read = function (tap) {\r\n  var buf, pos;\r\n  if (this._noUnpack) {\r\n    pos = tap.pos;\r\n    tap.skipLong();\r\n    buf = tap.buf.slice(pos, tap.pos);\r\n  } else {\r\n    buf = tap.unpackLongBytes(tap);\r\n  }\r\n  if (tap.isValid()) {\r\n    return this._fromBuffer(buf);\r\n  }\r\n};\r\n\r\nAbstractLongType.prototype._write = function (tap, val) {\r\n  if (!this._isValid(val)) {\r\n    throwInvalidError(val, this);\r\n  }\r\n  var buf = this._toBuffer(val);\r\n  if (this._noUnpack) {\r\n    tap.writeFixed(buf);\r\n  } else {\r\n    tap.packLongBytes(buf);\r\n  }\r\n};\r\n\r\nAbstractLongType.prototype._copy = function (val, opts) {\r\n  switch (opts && opts.coerce) {\r\n    case 3: // To string.\r\n      return this._toJSON(val);\r\n    case 2: // From string.\r\n      return this._fromJSON(val);\r\n    default: // Normal copy.\r\n      // Slow but guarantees most consistent results. Faster alternatives would\r\n      // require assumptions on the long class used (e.g. immutability).\r\n      return this._fromJSON(this._toJSON(val));\r\n  }\r\n};\r\n\r\nAbstractLongType.prototype._deref = function () { return 'long'; };\r\n\r\nAbstractLongType.prototype._update = function (resolver, type) {\r\n  var self = this;\r\n  switch (type.typeName) {\r\n    case 'int':\r\n      resolver._read = function (tap) {\r\n        return self._fromJSON(type._read(tap));\r\n      };\r\n      break;\r\n    case 'abstract:long':\r\n    case 'long':\r\n      resolver._read = function (tap) { return self._read(tap); };\r\n  }\r\n};\r\n\r\nAbstractLongType.prototype.random = function () {\r\n  return this._fromJSON(LongType.prototype.random());\r\n};\r\n\r\n// Methods to be implemented by the user.\r\nAbstractLongType.prototype._fromBuffer = utils.abstractFunction;\r\nAbstractLongType.prototype._toBuffer = utils.abstractFunction;\r\nAbstractLongType.prototype._fromJSON = utils.abstractFunction;\r\nAbstractLongType.prototype._toJSON = utils.abstractFunction;\r\nAbstractLongType.prototype._isValid = utils.abstractFunction;\r\nAbstractLongType.prototype.compare = utils.abstractFunction;\r\n\r\n/** A record field. */\r\nfunction Field(schema, opts) {\r\n  var name = schema.name;\r\n  if (typeof name != 'string' || !utils.isValidName(name)) {\r\n    throw new Error(f('invalid field name: %s', name));\r\n  }\r\n\r\n  this.name = name;\r\n  this.type = Type.forSchema(schema.type, opts);\r\n  this.aliases = schema.aliases || [];\r\n  this.doc = schema.doc !== undefined ? '' + schema.doc : undefined;\r\n\r\n  this._order = (function (order) {\r\n    switch (order) {\r\n      case 'ascending':\r\n        return 1;\r\n      case 'descending':\r\n        return -1;\r\n      case 'ignore':\r\n        return 0;\r\n      default:\r\n        throw new Error(f('invalid order: %j', order));\r\n    }\r\n  })(schema.order === undefined ? 'ascending' : schema.order);\r\n\r\n  var value = schema['default'];\r\n  if (value !== undefined) {\r\n    // We need to convert defaults back to a valid format (unions are\r\n    // disallowed in default definitions, only the first type of each union is\r\n    // allowed instead).\r\n    // http://apache-avro.679487.n3.nabble.com/field-union-default-in-Java-td1175327.html\r\n    var type = this.type;\r\n    var val = type._copy(value, {coerce: 2, wrap: 2});\r\n    // The clone call above will throw an error if the default is invalid.\r\n    if (isPrimitive(type.typeName) && type.typeName !== 'bytes') {\r\n      // These are immutable.\r\n      this.defaultValue = function () { return val; };\r\n    } else {\r\n      this.defaultValue = function () { return type._copy(val); };\r\n    }\r\n  }\r\n\r\n  Object.freeze(this);\r\n}\r\n\r\nField.prototype.defaultValue = function () {}; // Undefined default.\r\n\r\nObject.defineProperty(Field.prototype, 'order', {\r\n  enumerable: true,\r\n  get: function () {\r\n    return ['descending', 'ignore', 'ascending'][this._order + 1];\r\n  }\r\n});\r\n\r\nField.prototype.getAliases = function () { return this.aliases; };\r\n\r\nField.prototype.getDefault = Field.prototype.defaultValue;\r\n\r\nField.prototype.getName = function () { return this.name; };\r\n\r\nField.prototype.getOrder = function () { return this.order; };\r\n\r\nField.prototype.getType = function () { return this.type; };\r\n\r\n/**\r\n * Resolver to read a writer's schema as a new schema.\r\n *\r\n * @param readerType {Type} The type to convert to.\r\n */\r\nfunction Resolver(readerType) {\r\n  // Add all fields here so that all resolvers share the same hidden class.\r\n  this._readerType = readerType;\r\n  this._read = null;\r\n  this.itemsType = null;\r\n  this.size = 0;\r\n  this.symbols = null;\r\n  this.valuesType = null;\r\n}\r\n\r\nResolver.prototype._peek = Type.prototype._peek;\r\n\r\nResolver.prototype.inspect = function () { return '<Resolver>'; };\r\n\r\n/** Mutable hash container. */\r\nfunction Hash() {\r\n  this.str = undefined;\r\n}\r\n\r\n/**\r\n * Read a value from a tap.\r\n *\r\n * @param type {Type} The type to decode.\r\n * @param tap {Tap} The tap to read from. No checks are performed here.\r\n * @param resolver {Resolver} Optional resolver. It must match the input type.\r\n * @param lazy {Boolean} Skip trailing fields when using a resolver.\r\n */\r\nfunction readValue(type, tap, resolver, lazy) {\r\n  if (resolver) {\r\n    if (resolver._readerType !== type) {\r\n      throw new Error('invalid resolver');\r\n    }\r\n    return resolver._read(tap, lazy);\r\n  } else {\r\n    return type._read(tap);\r\n  }\r\n}\r\n\r\n/**\r\n * Get all aliases for a type (including its name).\r\n *\r\n * @param obj {Type|Object} Typically a type or a field. Its aliases property\r\n * must exist and be an array.\r\n */\r\nfunction getAliases(obj) {\r\n  var names = {};\r\n  if (obj.name) {\r\n    names[obj.name] = true;\r\n  }\r\n  var aliases = obj.aliases;\r\n  var i, l;\r\n  for (i = 0, l = aliases.length; i < l; i++) {\r\n    names[aliases[i]] = true;\r\n  }\r\n  return Object.keys(names);\r\n}\r\n\r\n/** Checks if a type can be read as another based on name resolution rules. */\r\nfunction hasCompatibleName(reader, writer, strict) {\r\n  if (!writer.name) {\r\n    return true;\r\n  }\r\n  var name = strict ? writer.name : utils.unqualify(writer.name);\r\n  var aliases = getAliases(reader);\r\n  var i, l, alias;\r\n  for (i = 0, l = aliases.length; i < l; i++) {\r\n    alias = aliases[i];\r\n    if (!strict) {\r\n      alias = utils.unqualify(alias);\r\n    }\r\n    if (alias === name) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Check whether a type's name is a primitive.\r\n *\r\n * @param name {String} Type name (e.g. `'string'`, `'array'`).\r\n */\r\nfunction isPrimitive(typeName) {\r\n  // Since we use this module's own `TYPES` object, we can use `instanceof`.\r\n  var type = TYPES[typeName];\r\n  return type && type.prototype instanceof PrimitiveType;\r\n}\r\n\r\n/**\r\n * Return a type's class name from its Avro type name.\r\n *\r\n * We can't simply use `constructor.name` since it isn't supported in all\r\n * browsers.\r\n *\r\n * @param typeName {String} Type name.\r\n */\r\nfunction getClassName(typeName) {\r\n  if (typeName === 'error') {\r\n    typeName = 'record';\r\n  } else {\r\n    var match = /^([^:]+):(.*)$/.exec(typeName);\r\n    if (match) {\r\n      if (match[1] === 'union') {\r\n        typeName = match[2] + 'Union';\r\n      } else {\r\n        // Logical type.\r\n        typeName = match[1];\r\n      }\r\n    }\r\n  }\r\n  return utils.capitalize(typeName) + 'Type';\r\n}\r\n\r\n/**\r\n * Get the number of elements in an array block.\r\n *\r\n * @param tap {Tap} A tap positioned at the beginning of an array block.\r\n */\r\nfunction readArraySize(tap) {\r\n  var n = tap.readLong();\r\n  if (n < 0) {\r\n    n = -n;\r\n    tap.skipLong(); // Skip size.\r\n  }\r\n  return n;\r\n}\r\n\r\n/**\r\n * Check whether a long can be represented without precision loss.\r\n *\r\n * @param n {Number} The number.\r\n *\r\n * Two things to note:\r\n *\r\n * + We are not using the `Number` constants for compatibility with older\r\n *   browsers.\r\n * + We must remove one from each bound because of rounding errors.\r\n */\r\nfunction isSafeLong(n) {\r\n  return n >= -9007199254740990 && n <= 9007199254740990;\r\n}\r\n\r\n/**\r\n * Check whether an object is the JSON representation of a buffer.\r\n */\r\nfunction isJsonBuffer(obj) {\r\n  return obj && obj.type === 'Buffer' && Array.isArray(obj.data);\r\n}\r\n\r\n/**\r\n * Throw a somewhat helpful error on invalid object.\r\n *\r\n * @param path {Array} Passed from hook, but unused (because empty where this\r\n * function is used, since we aren't keeping track of it for effiency).\r\n * @param val {...} The object to reject.\r\n * @param type {Type} The type to check against.\r\n *\r\n * This method is mostly used from `_write` to signal an invalid object for a\r\n * given type. Note that this provides less information than calling `isValid`\r\n * with a hook since the path is not propagated (for efficiency reasons).\r\n */\r\nfunction throwInvalidError(val, type) {\r\n  throw new Error(f('invalid %j: %j', type.schema(), val));\r\n}\r\n\r\nfunction maybeQualify(name, ns) {\r\n  var unqualified = utils.unqualify(name);\r\n  // Primitives are always in the global namespace.\r\n  return isPrimitive(unqualified) ? unqualified : utils.qualify(name, ns);\r\n}\r\n\r\n/**\r\n * Get a type's bucket when included inside an unwrapped union.\r\n *\r\n * @param type {Type} Any type.\r\n */\r\nfunction getTypeBucket(type) {\r\n  var typeName = type.typeName;\r\n  switch (typeName) {\r\n    case 'double':\r\n    case 'float':\r\n    case 'int':\r\n    case 'long':\r\n      return 'number';\r\n    case 'bytes':\r\n    case 'fixed':\r\n      return 'buffer';\r\n    case 'enum':\r\n      return 'string';\r\n    case 'map':\r\n    case 'error':\r\n    case 'record':\r\n      return 'object';\r\n    default:\r\n      return typeName;\r\n  }\r\n}\r\n\r\n/**\r\n * Infer a value's bucket (see unwrapped unions for more details).\r\n *\r\n * @param val {...} Any value.\r\n */\r\nfunction getValueBucket(val) {\r\n  if (val === null) {\r\n    return 'null';\r\n  }\r\n  var bucket = typeof val;\r\n  if (bucket === 'object') {\r\n    // Could be bytes, fixed, array, map, or record.\r\n    if (Array.isArray(val)) {\r\n      return 'array';\r\n    } else if (Buffer.isBuffer(val)) {\r\n      return 'buffer';\r\n    }\r\n  }\r\n  return bucket;\r\n}\r\n\r\n/**\r\n * Check whether a collection of types leads to an ambiguous union.\r\n *\r\n * @param types {Array} Array of types.\r\n */\r\nfunction isAmbiguous(types) {\r\n  var buckets = {};\r\n  var i, l, bucket, type;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    if (!Type.isType(type, 'logical')) {\r\n      bucket = getTypeBucket(type);\r\n      if (buckets[bucket]) {\r\n        return true;\r\n      }\r\n      buckets[bucket] = true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Combine number types.\r\n *\r\n * Note that never have to create a new type here, we are guaranteed to be able\r\n * to reuse one of the input types as super-type.\r\n */\r\nfunction combineNumbers(types) {\r\n  var typeNames = ['int', 'long', 'float', 'double'];\r\n  var superIndex = -1;\r\n  var superType = null;\r\n  var i, l, type, index;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    index = typeNames.indexOf(type.typeName);\r\n    if (index > superIndex) {\r\n      superIndex = index;\r\n      superType = type;\r\n    }\r\n  }\r\n  return superType;\r\n}\r\n\r\n/**\r\n * Combine enums and strings.\r\n *\r\n * The order of the returned symbols is undefined and the returned enum is\r\n *\r\n */\r\nfunction combineStrings(types, opts) {\r\n  var symbols = {};\r\n  var i, l, type, typeSymbols;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    if (type.typeName === 'string') {\r\n      // If at least one of the types is a string, it will be the supertype.\r\n      return type;\r\n    }\r\n    typeSymbols = type.symbols;\r\n    var j, m;\r\n    for (j = 0, m = typeSymbols.length; j < m; j++) {\r\n      symbols[typeSymbols[j]] = true;\r\n    }\r\n  }\r\n  return Type.forSchema({type: 'enum', symbols: Object.keys(symbols)}, opts);\r\n}\r\n\r\n/**\r\n * Combine bytes and fixed.\r\n *\r\n * This function is optimized to avoid creating new types when possible: in\r\n * case of a size mismatch between fixed types, it will continue looking\r\n * through the array to find an existing bytes type (rather than exit early by\r\n * creating one eagerly).\r\n */\r\nfunction combineBuffers(types, opts) {\r\n  var size = -1;\r\n  var i, l, type;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    if (type.typeName === 'bytes') {\r\n      return type;\r\n    }\r\n    if (size === -1) {\r\n      size = type.size;\r\n    } else if (type.size !== size) {\r\n      // Don't create a bytes type right away, we might be able to reuse one\r\n      // later on in the types array. Just mark this for now.\r\n      size = -2;\r\n    }\r\n  }\r\n  return size < 0 ? Type.forSchema('bytes', opts) : types[0];\r\n}\r\n\r\n/**\r\n * Combine maps and records.\r\n *\r\n * Field defaults are kept when possible (i.e. when no coercion to a map\r\n * happens), with later definitions overriding previous ones.\r\n */\r\nfunction combineObjects(types, opts) {\r\n  var allTypes = []; // Field and value types.\r\n  var fieldTypes = {}; // Record field types grouped by field name.\r\n  var fieldDefaults = {};\r\n  var isValidRecord = true;\r\n\r\n  // Check whether the final type will be a map or a record.\r\n  var i, l, type, fields;\r\n  for (i = 0, l = types.length; i < l; i++) {\r\n    type = types[i];\r\n    if (type.typeName === 'map') {\r\n      isValidRecord = false;\r\n      allTypes.push(type.valuesType);\r\n    } else {\r\n      fields = type.fields;\r\n      var j, m, field, fieldDefault, fieldName, fieldType;\r\n      for (j = 0, m = fields.length; j < m; j++) {\r\n        field = fields[j];\r\n        fieldName = field.name;\r\n        fieldType = field.type;\r\n        allTypes.push(fieldType);\r\n        if (isValidRecord) {\r\n          if (!fieldTypes[fieldName]) {\r\n            fieldTypes[fieldName] = [];\r\n          }\r\n          fieldTypes[fieldName].push(fieldType);\r\n          fieldDefault = field.defaultValue();\r\n          if (fieldDefault !== undefined) {\r\n            // Later defaults will override any previous ones.\r\n            fieldDefaults[fieldName] = fieldDefault;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (isValidRecord) {\r\n    // Check that no fields are missing and that we have the approriate\r\n    // defaults for those which are.\r\n    var fieldNames = Object.keys(fieldTypes);\r\n    for (i = 0, l = fieldNames.length; i < l; i++) {\r\n      fieldName = fieldNames[i];\r\n      if (\r\n        fieldTypes[fieldName].length < types.length &&\r\n        fieldDefaults[fieldName] === undefined\r\n      ) {\r\n        // At least one of the records is missing a field with no default.\r\n        if (opts && opts.strictDefaults) {\r\n          isValidRecord = false;\r\n        } else {\r\n          fieldTypes[fieldName].unshift(Type.forSchema('null', opts));\r\n          fieldDefaults[fieldName] = null;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  var schema;\r\n  if (isValidRecord) {\r\n    schema = {\r\n      type: 'record',\r\n      fields: fieldNames.map(function (s) {\r\n        var fieldType = Type.forTypes(fieldTypes[s], opts);\r\n        var fieldDefault = fieldDefaults[s];\r\n        if (\r\n          fieldDefault !== undefined &&\r\n          ~fieldType.typeName.indexOf('union')\r\n        ) {\r\n          // Ensure that the default's corresponding type is first.\r\n          var unionTypes = fieldType.types.slice();\r\n          var i, l;\r\n          for (i = 0, l = unionTypes.length; i < l; i++) {\r\n            if (unionTypes[i].isValid(fieldDefault)) {\r\n              break;\r\n            }\r\n          }\r\n          if (i > 0) {\r\n            var unionType = unionTypes[0];\r\n            unionTypes[0] = unionTypes[i];\r\n            unionTypes[i] = unionType;\r\n            fieldType = Type.forSchema(unionTypes, opts);\r\n          }\r\n        }\r\n        return {\r\n          name: s,\r\n          type: fieldType,\r\n          'default': fieldDefaults[s]\r\n        };\r\n      })\r\n    };\r\n  } else {\r\n    schema = {\r\n      type: 'map',\r\n      values: Type.forTypes(allTypes, opts)\r\n    };\r\n  }\r\n  return Type.forSchema(schema, opts);\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  Type: Type,\r\n  getTypeBucket: getTypeBucket,\r\n  getValueBucket: getValueBucket,\r\n  isPrimitive: isPrimitive,\r\n  builtins: (function () {\r\n    var types = {\r\n      LogicalType: LogicalType,\r\n      UnwrappedUnionType: UnwrappedUnionType,\r\n      WrappedUnionType: WrappedUnionType\r\n    };\r\n    var typeNames = Object.keys(TYPES);\r\n    var i, l, typeName;\r\n    for (i = 0, l = typeNames.length; i < l; i++) {\r\n      typeName = typeNames[i];\r\n      types[getClassName(typeName)] = TYPES[typeName];\r\n    }\r\n    return types;\r\n  })()\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/types.js?");

/***/ }),

/***/ "./node_modules/avsc/lib/utils.js":
/*!****************************************!*\
  !*** ./node_modules/avsc/lib/utils.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* jshint node: true */\r\n\r\n// TODO: Make long comparison impervious to precision loss.\r\n// TODO: Optimize binary comparison methods.\r\n\r\n\r\n\r\n/** Various utilities used across this library. */\r\n\r\nvar crypto = __webpack_require__(/*! crypto */ \"./node_modules/avsc/etc/browser/lib/crypto.js\");\r\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\n\r\n// Shared buffer pool for all taps.\r\nvar POOL = new BufferPool(4096);\r\n\r\n// Valid (field, type, and symbol) name regex.\r\nvar NAME_PATTERN = /^[A-Za-z_][A-Za-z0-9_]*$/;\r\n\r\n// Convenience imports.\r\nvar f = util.format;\r\n\r\n/**\r\n * Create a new empty buffer.\r\n *\r\n * @param size {Number} The buffer's size.\r\n */\r\nfunction newBuffer(size) {\r\n  if (typeof Buffer.alloc == 'function') {\r\n    return Buffer.alloc(size);\r\n  } else {\r\n    return new Buffer(size);\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new buffer with the input contents.\r\n *\r\n * @param data {Array|String} The buffer's data.\r\n * @param enc {String} Encoding, used if data is a string.\r\n */\r\nfunction bufferFrom(data, enc) {\r\n  if (typeof Buffer.from == 'function') {\r\n    return Buffer.from(data, enc);\r\n  } else {\r\n    return new Buffer(data, enc);\r\n  }\r\n}\r\n\r\n/**\r\n * Uppercase the first letter of a string.\r\n *\r\n * @param s {String} The string.\r\n */\r\nfunction capitalize(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\r\n\r\n/**\r\n * Compare two numbers.\r\n *\r\n * @param n1 {Number} The first one.\r\n * @param n2 {Number} The second one.\r\n */\r\nfunction compare(n1, n2) { return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1); }\r\n\r\n/**\r\n * Get option or default if undefined.\r\n *\r\n * @param opts {Object} Options.\r\n * @param key {String} Name of the option.\r\n * @param def {...} Default value.\r\n *\r\n * This is useful mostly for true-ish defaults and false-ish values (where the\r\n * usual `||` idiom breaks down).\r\n */\r\nfunction getOption(opts, key, def) {\r\n  var value = opts[key];\r\n  return value === undefined ? def : value;\r\n}\r\n\r\n/**\r\n * Compute a string's hash.\r\n *\r\n * @param str {String} The string to hash.\r\n * @param algorithm {String} The algorithm used. Defaults to MD5.\r\n */\r\nfunction getHash(str, algorithm) {\r\n  algorithm = algorithm || 'md5';\r\n  var hash = crypto.createHash(algorithm);\r\n  hash.end(str);\r\n  return hash.read();\r\n}\r\n\r\n/**\r\n * Find index of value in array.\r\n *\r\n * @param arr {Array} Can also be a false-ish value.\r\n * @param v {Object} Value to find.\r\n *\r\n * Returns -1 if not found, -2 if found multiple times.\r\n */\r\nfunction singleIndexOf(arr, v) {\r\n  var pos = -1;\r\n  var i, l;\r\n  if (!arr) {\r\n    return -1;\r\n  }\r\n  for (i = 0, l = arr.length; i < l; i++) {\r\n    if (arr[i] === v) {\r\n      if (pos >= 0) {\r\n        return -2;\r\n      }\r\n      pos = i;\r\n    }\r\n  }\r\n  return pos;\r\n}\r\n\r\n/**\r\n * Convert array to map.\r\n *\r\n * @param arr {Array} Elements.\r\n * @param fn {Function} Function returning an element's key.\r\n */\r\nfunction toMap(arr, fn) {\r\n  var obj = {};\r\n  var i, elem;\r\n  for (i = 0; i < arr.length; i++) {\r\n    elem = arr[i];\r\n    obj[fn(elem)] = elem;\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Convert map to array of values (polyfill for `Object.values`).\r\n *\r\n * @param obj {Object} Map.\r\n */\r\nfunction objectValues(obj) {\r\n  return Object.keys(obj).map(function (key) { return obj[key]; });\r\n}\r\n\r\n/**\r\n * Check whether an array has duplicates.\r\n *\r\n * @param arr {Array} The array.\r\n * @param fn {Function} Optional function to apply to each element.\r\n */\r\nfunction hasDuplicates(arr, fn) {\r\n  var obj = Object.create(null);\r\n  var i, l, elem;\r\n  for (i = 0, l = arr.length; i < l; i++) {\r\n    elem = arr[i];\r\n    if (fn) {\r\n      elem = fn(elem);\r\n    }\r\n    if (obj[elem]) {\r\n      return true;\r\n    }\r\n    obj[elem] = true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Copy properties from one object to another.\r\n *\r\n * @param src {Object} The source object.\r\n * @param dst {Object} The destination object.\r\n * @param overwrite {Boolean} Whether to overwrite existing destination\r\n * properties. Defaults to false.\r\n */\r\nfunction copyOwnProperties(src, dst, overwrite) {\r\n  var names = Object.getOwnPropertyNames(src);\r\n  var i, l, name;\r\n  for (i = 0, l = names.length; i < l; i++) {\r\n    name = names[i];\r\n    if (!dst.hasOwnProperty(name) || overwrite) {\r\n      var descriptor = Object.getOwnPropertyDescriptor(src, name);\r\n      Object.defineProperty(dst, name, descriptor);\r\n    }\r\n  }\r\n  return dst;\r\n}\r\n\r\n/**\r\n * Check whether a string is a valid Avro identifier.\r\n */\r\nfunction isValidName(str) { return NAME_PATTERN.test(str); }\r\n\r\n/**\r\n * Verify and return fully qualified name.\r\n *\r\n * @param name {String} Full or short name. It can be prefixed with a dot to\r\n * force global namespace.\r\n * @param namespace {String} Optional namespace.\r\n */\r\nfunction qualify(name, namespace) {\r\n  if (~name.indexOf('.')) {\r\n    name = name.replace(/^\\./, ''); // Allow absolute referencing.\r\n  } else if (namespace) {\r\n    name = namespace + '.' + name;\r\n  }\r\n  name.split('.').forEach(function (part) {\r\n    if (!isValidName(part)) {\r\n      throw new Error(f('invalid name: %j', name));\r\n    }\r\n  });\r\n  return name;\r\n}\r\n\r\n/**\r\n * Remove namespace from a name.\r\n *\r\n * @param name {String} Full or short name.\r\n */\r\nfunction unqualify(name) {\r\n  var parts = name.split('.');\r\n  return parts[parts.length - 1];\r\n}\r\n\r\n/**\r\n * Return the namespace implied by a name.\r\n *\r\n * @param name {String} Full or short name. If short, the returned namespace\r\n *  will be empty.\r\n */\r\nfunction impliedNamespace(name) {\r\n  var match = /^(.*)\\.[^.]+$/.exec(name);\r\n  return match ? match[1] : undefined;\r\n}\r\n\r\n/**\r\n * Returns offset in the string of the end of JSON object (-1 if past the end).\r\n *\r\n * To keep the implementation simple, this function isn't a JSON validator. It\r\n * will gladly return a result for invalid JSON (which is OK since that will be\r\n * promptly rejected by the JSON parser). What matters is that it is guaranteed\r\n * to return the correct end when presented with valid JSON.\r\n *\r\n * @param str {String} Input string containing serialized JSON..\r\n * @param pos {Number} Starting position.\r\n */\r\nfunction jsonEnd(str, pos) {\r\n  pos = pos | 0;\r\n\r\n  // Handle the case of a simple literal separately.\r\n  var c = str.charAt(pos++);\r\n  if (/[\\d-]/.test(c)) {\r\n    while (/[eE\\d.+-]/.test(str.charAt(pos))) {\r\n      pos++;\r\n    }\r\n    return pos;\r\n  } else if (/true|null/.test(str.slice(pos - 1, pos + 3))) {\r\n    return pos + 3;\r\n  } else if (/false/.test(str.slice(pos - 1, pos + 4))) {\r\n    return pos + 4;\r\n  }\r\n\r\n  // String, object, or array.\r\n  var depth = 0;\r\n  var literal = false;\r\n  do {\r\n    switch (c) {\r\n    case '{':\r\n    case '[':\r\n      if (!literal) { depth++; }\r\n      break;\r\n    case '}':\r\n    case ']':\r\n      if (!literal && !--depth) {\r\n        return pos;\r\n      }\r\n      break;\r\n    case '\"':\r\n      literal = !literal;\r\n      if (!depth && !literal) {\r\n        return pos;\r\n      }\r\n      break;\r\n    case '\\\\':\r\n      pos++; // Skip the next character.\r\n    }\r\n  } while ((c = str.charAt(pos++)));\r\n\r\n  return -1;\r\n}\r\n\r\n/** \"Abstract\" function to help with \"subclassing\". */\r\nfunction abstractFunction() { throw new Error('abstract'); }\r\n\r\n/** Batch-deprecate \"getters\" from an object's prototype. */\r\nfunction addDeprecatedGetters(obj, props) {\r\n  var proto = obj.prototype;\r\n  var i, l, prop, getter;\r\n  for (i = 0, l = props.length; i < l; i++) {\r\n    prop = props[i];\r\n    getter = 'get' + capitalize(prop);\r\n    proto[getter] = util.deprecate(\r\n      createGetter(prop),\r\n      'use `.' + prop + '` instead of `.' + getter + '()`'\r\n    );\r\n  }\r\n\r\n  function createGetter(prop) {\r\n    return function () {\r\n      var delegate = this[prop];\r\n      return typeof delegate == 'function' ?\r\n        delegate.apply(this, arguments) :\r\n        delegate;\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Simple buffer pool to avoid allocating many small buffers.\r\n *\r\n * This provides significant speedups in recent versions of node (6+).\r\n */\r\nfunction BufferPool(len) {\r\n  this._len = len | 0;\r\n  this._pos = 0;\r\n  this._slab = newBuffer(this._len);\r\n}\r\n\r\nBufferPool.prototype.alloc = function (len) {\r\n  if (len < 0) {\r\n    throw new Error('negative length');\r\n  }\r\n  var maxLen = this._len;\r\n  if (len > maxLen) {\r\n    return newBuffer(len);\r\n  }\r\n  if (this._pos + len > maxLen) {\r\n    this._slab = newBuffer(maxLen);\r\n    this._pos = 0;\r\n  }\r\n  return this._slab.slice(this._pos, this._pos += len);\r\n};\r\n\r\n/**\r\n * Generator of random things.\r\n *\r\n * Inspired by: http://stackoverflow.com/a/424445/1062617\r\n */\r\nfunction Lcg(seed) {\r\n  var a = 1103515245;\r\n  var c = 12345;\r\n  var m = Math.pow(2, 31);\r\n  var state = Math.floor(seed || Math.random() * (m - 1));\r\n\r\n  this._max = m;\r\n  this._nextInt = function () { return state = (a * state + c) % m; };\r\n}\r\n\r\nLcg.prototype.nextBoolean = function () {\r\n  // jshint -W018\r\n  return !!(this._nextInt() % 2);\r\n};\r\n\r\nLcg.prototype.nextInt = function (start, end) {\r\n  if (end === undefined) {\r\n    end = start;\r\n    start = 0;\r\n  }\r\n  end = end === undefined ? this._max : end;\r\n  return start + Math.floor(this.nextFloat() * (end - start));\r\n};\r\n\r\nLcg.prototype.nextFloat = function (start, end) {\r\n  if (end === undefined) {\r\n    end = start;\r\n    start = 0;\r\n  }\r\n  end = end === undefined ? 1 : end;\r\n  return start + (end - start) * this._nextInt() / this._max;\r\n};\r\n\r\nLcg.prototype.nextString = function(len, flags) {\r\n  len |= 0;\r\n  flags = flags || 'aA';\r\n  var mask = '';\r\n  if (flags.indexOf('a') > -1) {\r\n    mask += 'abcdefghijklmnopqrstuvwxyz';\r\n  }\r\n  if (flags.indexOf('A') > -1) {\r\n    mask += 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n  }\r\n  if (flags.indexOf('#') > -1) {\r\n    mask += '0123456789';\r\n  }\r\n  if (flags.indexOf('!') > -1) {\r\n    mask += '~`!@#$%^&*()_+-={}[]:\";\\'<>?,./|\\\\';\r\n  }\r\n  var result = [];\r\n  for (var i = 0; i < len; i++) {\r\n    result.push(this.choice(mask));\r\n  }\r\n  return result.join('');\r\n};\r\n\r\nLcg.prototype.nextBuffer = function (len) {\r\n  var arr = [];\r\n  var i;\r\n  for (i = 0; i < len; i++) {\r\n    arr.push(this.nextInt(256));\r\n  }\r\n  return bufferFrom(arr);\r\n};\r\n\r\nLcg.prototype.choice = function (arr) {\r\n  var len = arr.length;\r\n  if (!len) {\r\n    throw new Error('choosing from empty array');\r\n  }\r\n  return arr[this.nextInt(len)];\r\n};\r\n\r\n/**\r\n * Ordered queue which returns items consecutively.\r\n *\r\n * This is actually a heap by index, with the added requirements that elements\r\n * can only be retrieved consecutively.\r\n */\r\nfunction OrderedQueue() {\r\n  this._index = 0;\r\n  this._items = [];\r\n}\r\n\r\nOrderedQueue.prototype.push = function (item) {\r\n  var items = this._items;\r\n  var i = items.length | 0;\r\n  var j;\r\n  items.push(item);\r\n  while (i > 0 && items[i].index < items[j = ((i - 1) >> 1)].index) {\r\n    item = items[i];\r\n    items[i] = items[j];\r\n    items[j] = item;\r\n    i = j;\r\n  }\r\n};\r\n\r\nOrderedQueue.prototype.pop = function () {\r\n  var items = this._items;\r\n  var len = (items.length - 1) | 0;\r\n  var first = items[0];\r\n  if (!first || first.index > this._index) {\r\n    return null;\r\n  }\r\n  this._index++;\r\n  if (!len) {\r\n    items.pop();\r\n    return first;\r\n  }\r\n  items[0] = items.pop();\r\n  var mid = len >> 1;\r\n  var i = 0;\r\n  var i1, i2, j, item, c, c1, c2;\r\n  while (i < mid) {\r\n    item = items[i];\r\n    i1 = (i << 1) + 1;\r\n    i2 = (i + 1) << 1;\r\n    c1 = items[i1];\r\n    c2 = items[i2];\r\n    if (!c2 || c1.index <= c2.index) {\r\n      c = c1;\r\n      j = i1;\r\n    } else {\r\n      c = c2;\r\n      j = i2;\r\n    }\r\n    if (c.index >= item.index) {\r\n      break;\r\n    }\r\n    items[j] = item;\r\n    items[i] = c;\r\n    i = j;\r\n  }\r\n  return first;\r\n};\r\n\r\n/**\r\n * A tap is a buffer which remembers what has been already read.\r\n *\r\n * It is optimized for performance, at the cost of failing silently when\r\n * overflowing the buffer. This is a purposeful trade-off given the expected\r\n * rarity of this case and the large performance hit necessary to enforce\r\n * validity. See `isValid` below for more information.\r\n */\r\nfunction Tap(buf, pos) {\r\n  this.buf = buf;\r\n  this.pos = pos | 0;\r\n  if (this.pos < 0) {\r\n    throw new Error('negative offset');\r\n  }\r\n}\r\n\r\n/**\r\n * Check that the tap is in a valid state.\r\n *\r\n * For efficiency reasons, none of the methods below will fail if an overflow\r\n * occurs (either read, skip, or write). For this reason, it is up to the\r\n * caller to always check that the read, skip, or write was valid by calling\r\n * this method.\r\n */\r\nTap.prototype.isValid = function () { return this.pos <= this.buf.length; };\r\n\r\nTap.prototype._invalidate = function () { this.pos = this.buf.length + 1; };\r\n\r\n// Read, skip, write methods.\r\n//\r\n// These should fail silently when the buffer overflows. Note this is only\r\n// required to be true when the functions are decoding valid objects. For\r\n// example errors will still be thrown if a bad count is read, leading to a\r\n// negative position offset (which will typically cause a failure in\r\n// `readFixed`).\r\n\r\nTap.prototype.readBoolean = function () { return !!this.buf[this.pos++]; };\r\n\r\nTap.prototype.skipBoolean = function () { this.pos++; };\r\n\r\nTap.prototype.writeBoolean = function (b) { this.buf[this.pos++] = !!b; };\r\n\r\nTap.prototype.readInt = Tap.prototype.readLong = function () {\r\n  var n = 0;\r\n  var k = 0;\r\n  var buf = this.buf;\r\n  var b, h, f, fk;\r\n\r\n  do {\r\n    b = buf[this.pos++];\r\n    h = b & 0x80;\r\n    n |= (b & 0x7f) << k;\r\n    k += 7;\r\n  } while (h && k < 28);\r\n\r\n  if (h) {\r\n    // Switch to float arithmetic, otherwise we might overflow.\r\n    f = n;\r\n    fk = 268435456; // 2 ** 28.\r\n    do {\r\n      b = buf[this.pos++];\r\n      f += (b & 0x7f) * fk;\r\n      fk *= 128;\r\n    } while (b & 0x80);\r\n    return (f % 2 ? -(f + 1) : f) / 2;\r\n  }\r\n\r\n  return (n >> 1) ^ -(n & 1);\r\n};\r\n\r\nTap.prototype.skipInt = Tap.prototype.skipLong = function () {\r\n  var buf = this.buf;\r\n  while (buf[this.pos++] & 0x80) {}\r\n};\r\n\r\nTap.prototype.writeInt = Tap.prototype.writeLong = function (n) {\r\n  var buf = this.buf;\r\n  var f, m;\r\n\r\n  if (n >= -1073741824 && n < 1073741824) {\r\n    // Won't overflow, we can use integer arithmetic.\r\n    m = n >= 0 ? n << 1 : (~n << 1) | 1;\r\n    do {\r\n      buf[this.pos] = m & 0x7f;\r\n      m >>= 7;\r\n    } while (m && (buf[this.pos++] |= 0x80));\r\n  } else {\r\n    // We have to use slower floating arithmetic.\r\n    f = n >= 0 ? n * 2 : (-n * 2) - 1;\r\n    do {\r\n      buf[this.pos] = f & 0x7f;\r\n      f /= 128;\r\n    } while (f >= 1 && (buf[this.pos++] |= 0x80));\r\n  }\r\n  this.pos++;\r\n};\r\n\r\nTap.prototype.readFloat = function () {\r\n  var buf = this.buf;\r\n  var pos = this.pos;\r\n  this.pos += 4;\r\n  if (this.pos > buf.length) {\r\n    return 0;\r\n  }\r\n  return this.buf.readFloatLE(pos);\r\n};\r\n\r\nTap.prototype.skipFloat = function () { this.pos += 4; };\r\n\r\nTap.prototype.writeFloat = function (f) {\r\n  var buf = this.buf;\r\n  var pos = this.pos;\r\n  this.pos += 4;\r\n  if (this.pos > buf.length) {\r\n    return;\r\n  }\r\n  return this.buf.writeFloatLE(f, pos);\r\n};\r\n\r\nTap.prototype.readDouble = function () {\r\n  var buf = this.buf;\r\n  var pos = this.pos;\r\n  this.pos += 8;\r\n  if (this.pos > buf.length) {\r\n    return 0;\r\n  }\r\n  return this.buf.readDoubleLE(pos);\r\n};\r\n\r\nTap.prototype.skipDouble = function () { this.pos += 8; };\r\n\r\nTap.prototype.writeDouble = function (d) {\r\n  var buf = this.buf;\r\n  var pos = this.pos;\r\n  this.pos += 8;\r\n  if (this.pos > buf.length) {\r\n    return;\r\n  }\r\n  return this.buf.writeDoubleLE(d, pos);\r\n};\r\n\r\nTap.prototype.readFixed = function (len) {\r\n  var pos = this.pos;\r\n  this.pos += len;\r\n  if (this.pos > this.buf.length) {\r\n    return;\r\n  }\r\n  var fixed = POOL.alloc(len);\r\n  this.buf.copy(fixed, 0, pos, pos + len);\r\n  return fixed;\r\n};\r\n\r\nTap.prototype.skipFixed = function (len) { this.pos += len; };\r\n\r\nTap.prototype.writeFixed = function (buf, len) {\r\n  len = len || buf.length;\r\n  var pos = this.pos;\r\n  this.pos += len;\r\n  if (this.pos > this.buf.length) {\r\n    return;\r\n  }\r\n  buf.copy(this.buf, pos, 0, len);\r\n};\r\n\r\nTap.prototype.readBytes = function () {\r\n  var len = this.readLong();\r\n  if (len < 0) {\r\n    this._invalidate();\r\n    return;\r\n  }\r\n  return this.readFixed(len);\r\n};\r\n\r\nTap.prototype.skipBytes = function () {\r\n  var len = this.readLong();\r\n  if (len < 0) {\r\n    this._invalidate();\r\n    return;\r\n  }\r\n  this.pos += len;\r\n};\r\n\r\nTap.prototype.writeBytes = function (buf) {\r\n  var len = buf.length;\r\n  this.writeLong(len);\r\n  this.writeFixed(buf, len);\r\n};\r\n\r\n/* istanbul ignore else */\r\nif (typeof Buffer.prototype.utf8Slice == 'function') {\r\n  // Use this optimized function when available.\r\n  Tap.prototype.readString = function () {\r\n    var len = this.readLong();\r\n    if (len < 0) {\r\n      this._invalidate();\r\n      return '';\r\n    }\r\n    var pos = this.pos;\r\n    var buf = this.buf;\r\n    this.pos += len;\r\n    if (this.pos > buf.length) {\r\n      return;\r\n    }\r\n    return this.buf.utf8Slice(pos, pos + len);\r\n  };\r\n} else {\r\n  Tap.prototype.readString = function () {\r\n    var len = this.readLong();\r\n    if (len < 0) {\r\n      this._invalidate();\r\n      return '';\r\n    }\r\n    var pos = this.pos;\r\n    var buf = this.buf;\r\n    this.pos += len;\r\n    if (this.pos > buf.length) {\r\n      return;\r\n    }\r\n    return this.buf.slice(pos, pos + len).toString();\r\n  };\r\n}\r\n\r\nTap.prototype.skipString = function () {\r\n  var len = this.readLong();\r\n  if (len < 0) {\r\n    this._invalidate();\r\n    return;\r\n  }\r\n  this.pos += len;\r\n};\r\n\r\nTap.prototype.writeString = function (s) {\r\n  var len = Buffer.byteLength(s);\r\n  var buf = this.buf;\r\n  this.writeLong(len);\r\n  var pos = this.pos;\r\n  this.pos += len;\r\n  if (this.pos > buf.length) {\r\n    return;\r\n  }\r\n  if (len > 64 && typeof Buffer.prototype.utf8Write == 'function') {\r\n    // This method is roughly 50% faster than the manual implementation below\r\n    // for long strings (which is itself faster than the generic `Buffer#write`\r\n    // at least in most browsers, where `utf8Write` is not available).\r\n    buf.utf8Write(s, pos, len);\r\n  } else {\r\n    var i, l, c1, c2;\r\n    for (i = 0, l = len; i < l; i++) {\r\n      c1 = s.charCodeAt(i);\r\n      if (c1 < 0x80) {\r\n        buf[pos++] = c1;\r\n      } else if (c1 < 0x800) {\r\n        buf[pos++] = c1 >> 6 | 0xc0;\r\n        buf[pos++] = c1 & 0x3f | 0x80;\r\n      } else if (\r\n        (c1 & 0xfc00) === 0xd800 &&\r\n        ((c2 = s.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\r\n      ) {\r\n        c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\r\n        i++;\r\n        buf[pos++] = c1 >> 18 | 0xf0;\r\n        buf[pos++] = c1 >> 12 & 0x3f | 0x80;\r\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\r\n        buf[pos++] = c1 & 0x3f | 0x80;\r\n      } else {\r\n        buf[pos++] = c1 >> 12 | 0xe0;\r\n        buf[pos++] = c1 >> 6 & 0x3f | 0x80;\r\n        buf[pos++] = c1 & 0x3f | 0x80;\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/* istanbul ignore else */\r\nif (typeof Buffer.prototype.latin1Write == 'function') {\r\n  // `binaryWrite` has been renamed to `latin1Write` in Node v6.4.0, see\r\n  // https://github.com/nodejs/node/pull/7111. Note that the `'binary'`\r\n  // encoding argument still works however.\r\n  Tap.prototype.writeBinary = function (str, len) {\r\n    var pos = this.pos;\r\n    this.pos += len;\r\n    if (this.pos > this.buf.length) {\r\n      return;\r\n    }\r\n    this.buf.latin1Write(str, pos, len);\r\n  };\r\n} else if (typeof Buffer.prototype.binaryWrite == 'function') {\r\n  Tap.prototype.writeBinary = function (str, len) {\r\n    var pos = this.pos;\r\n    this.pos += len;\r\n    if (this.pos > this.buf.length) {\r\n      return;\r\n    }\r\n    this.buf.binaryWrite(str, pos, len);\r\n  };\r\n} else {\r\n  // Slowest implementation.\r\n  Tap.prototype.writeBinary = function (s, len) {\r\n    var pos = this.pos;\r\n    this.pos += len;\r\n    if (this.pos > this.buf.length) {\r\n      return;\r\n    }\r\n    this.buf.write(s, pos, len, 'binary');\r\n  };\r\n}\r\n\r\n// Binary comparison methods.\r\n//\r\n// These are not guaranteed to consume the objects they are comparing when\r\n// returning a non-zero result (allowing for performance benefits), so no other\r\n// operations should be done on either tap after a compare returns a non-zero\r\n// value. Also, these methods do not have the same silent failure requirement\r\n// as read, skip, and write since they are assumed to be called on valid\r\n// buffers.\r\n\r\nTap.prototype.matchBoolean = function (tap) {\r\n  return this.buf[this.pos++] - tap.buf[tap.pos++];\r\n};\r\n\r\nTap.prototype.matchInt = Tap.prototype.matchLong = function (tap) {\r\n  var n1 = this.readLong();\r\n  var n2 = tap.readLong();\r\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\r\n};\r\n\r\nTap.prototype.matchFloat = function (tap) {\r\n  var n1 = this.readFloat();\r\n  var n2 = tap.readFloat();\r\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\r\n};\r\n\r\nTap.prototype.matchDouble = function (tap) {\r\n  var n1 = this.readDouble();\r\n  var n2 = tap.readDouble();\r\n  return n1 === n2 ? 0 : (n1 < n2 ? -1 : 1);\r\n};\r\n\r\nTap.prototype.matchFixed = function (tap, len) {\r\n  return this.readFixed(len).compare(tap.readFixed(len));\r\n};\r\n\r\nTap.prototype.matchBytes = Tap.prototype.matchString = function (tap) {\r\n  var l1 = this.readLong();\r\n  var p1 = this.pos;\r\n  this.pos += l1;\r\n  var l2 = tap.readLong();\r\n  var p2 = tap.pos;\r\n  tap.pos += l2;\r\n  var b1 = this.buf.slice(p1, this.pos);\r\n  var b2 = tap.buf.slice(p2, tap.pos);\r\n  return b1.compare(b2);\r\n};\r\n\r\n// Functions for supporting custom long classes.\r\n//\r\n// The two following methods allow the long implementations to not have to\r\n// worry about Avro's zigzag encoding, we directly expose longs as unpacked.\r\n\r\nTap.prototype.unpackLongBytes = function () {\r\n  var res = newBuffer(8);\r\n  var n = 0;\r\n  var i = 0; // Byte index in target buffer.\r\n  var j = 6; // Bit offset in current target buffer byte.\r\n  var buf = this.buf;\r\n  var b, neg;\r\n\r\n  b = buf[this.pos++];\r\n  neg = b & 1;\r\n  res.fill(0);\r\n\r\n  n |= (b & 0x7f) >> 1;\r\n  while (b & 0x80) {\r\n    b = buf[this.pos++];\r\n    n |= (b & 0x7f) << j;\r\n    j += 7;\r\n    if (j >= 8) {\r\n      // Flush byte.\r\n      j -= 8;\r\n      res[i++] = n;\r\n      n >>= 8;\r\n    }\r\n  }\r\n  res[i] = n;\r\n\r\n  if (neg) {\r\n    invert(res, 8);\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\nTap.prototype.packLongBytes = function (buf) {\r\n  var neg = (buf[7] & 0x80) >> 7;\r\n  var res = this.buf;\r\n  var j = 1;\r\n  var k = 0;\r\n  var m = 3;\r\n  var n;\r\n\r\n  if (neg) {\r\n    invert(buf, 8);\r\n    n = 1;\r\n  } else {\r\n    n = 0;\r\n  }\r\n\r\n  var parts = [\r\n    buf.readUIntLE(0, 3),\r\n    buf.readUIntLE(3, 3),\r\n    buf.readUIntLE(6, 2)\r\n  ];\r\n  // Not reading more than 24 bits because we need to be able to combine the\r\n  // \"carry\" bits from the previous part and JavaScript only supports bitwise\r\n  // operations on 32 bit integers.\r\n  while (m && !parts[--m]) {} // Skip trailing 0s.\r\n\r\n  // Leading parts (if any), we never bail early here since we need the\r\n  // continuation bit to be set.\r\n  while (k < m) {\r\n    n |= parts[k++] << j;\r\n    j += 24;\r\n    while (j > 7) {\r\n      res[this.pos++] = (n & 0x7f) | 0x80;\r\n      n >>= 7;\r\n      j -= 7;\r\n    }\r\n  }\r\n\r\n  // Final part, similar to normal packing aside from the initial offset.\r\n  n |= parts[m] << j;\r\n  do {\r\n    res[this.pos] = n & 0x7f;\r\n    n >>= 7;\r\n  } while (n && (res[this.pos++] |= 0x80));\r\n  this.pos++;\r\n\r\n  // Restore original buffer (could make this optional?).\r\n  if (neg) {\r\n    invert(buf, 8);\r\n  }\r\n};\r\n\r\n// Helpers.\r\n\r\n/**\r\n * Invert all bits in a buffer.\r\n *\r\n * @param buf {Buffer} Non-empty buffer to invert.\r\n * @param len {Number} Buffer length (must be positive).\r\n */\r\nfunction invert(buf, len) {\r\n  while (len--) {\r\n    buf[len] = ~buf[len];\r\n  }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  abstractFunction: abstractFunction,\r\n  addDeprecatedGetters: addDeprecatedGetters,\r\n  bufferFrom: bufferFrom,\r\n  capitalize: capitalize,\r\n  copyOwnProperties: copyOwnProperties,\r\n  getHash: getHash,\r\n  compare: compare,\r\n  getOption: getOption,\r\n  impliedNamespace: impliedNamespace,\r\n  isValidName: isValidName,\r\n  jsonEnd: jsonEnd,\r\n  newBuffer: newBuffer,\r\n  objectValues: objectValues,\r\n  qualify: qualify,\r\n  toMap: toMap,\r\n  singleIndexOf: singleIndexOf,\r\n  hasDuplicates: hasDuplicates,\r\n  unqualify: unqualify,\r\n  BufferPool: BufferPool,\r\n  Lcg: Lcg,\r\n  OrderedQueue: OrderedQueue,\r\n  Tap: Tap\r\n};\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/avsc/lib/utils.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar callBind = __webpack_require__(/*! ./ */ \"./node_modules/call-bind/index.js\");\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/call-bind/callBound.js?");

/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/call-bind/index.js?");

/***/ }),

/***/ "./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\nconst fs = __webpack_require__(/*! fs */ \"?a0c3\")\nconst path = __webpack_require__(/*! path */ \"./node_modules/path/path.js\")\nconst os = __webpack_require__(/*! os */ \"?613f\")\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parser src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _log (message) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(\"MISSING_ENV_VAR\", key)) {\n        \"MISSING_ENV_VAR\"[key] = parsed[key]\n      } else {\n        if (override === true) {\n          \"MISSING_ENV_VAR\"[key] = parsed[key]\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`)\n          } else {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`)\n          }\n        }\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    if (debug) {\n      _log(`Failed to load ${dotenvPath} ${e.message}`)\n    }\n\n    return { error: e }\n  }\n}\n\nconst DotenvModule = {\n  config,\n  parse\n}\n\nmodule.exports.config = DotenvModule.config\nmodule.exports.parse = DotenvModule.parse\nmodule.exports = DotenvModule\n\n\n//# sourceURL=webpack://js-kart/./node_modules/dotenv/lib/main.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"./node_modules/is-callable/index.js\");\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/for-each/index.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar hasOwn = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tif ($exec(/^%?[^%]*%?$/g, name) === null) {\n\t\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\n\t}\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/get-intrinsic/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/has-symbols/index.js?");

/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/has-symbols/shams.js?");

/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasSymbols = __webpack_require__(/*! has-symbols/shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/has-tostringtag/shams.js?");

/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack://js-kart/./node_modules/has/src/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/is-arguments/index.js":
/*!********************************************!*\
  !*** ./node_modules/is-arguments/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/is-arguments/index.js?");

/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar fnToStr = Function.prototype.toString;\nvar reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;\nvar badArrayLike;\nvar isCallableMarker;\nif (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {\n\ttry {\n\t\tbadArrayLike = Object.defineProperty({}, 'length', {\n\t\t\tget: function () {\n\t\t\t\tthrow isCallableMarker;\n\t\t\t}\n\t\t});\n\t\tisCallableMarker = {};\n\t\t// eslint-disable-next-line no-throw-literal\n\t\treflectApply(function () { throw 42; }, null, badArrayLike);\n\t} catch (_) {\n\t\tif (_ !== isCallableMarker) {\n\t\t\treflectApply = null;\n\t\t}\n\t}\n} else {\n\treflectApply = null;\n}\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`\n/* globals document: false */\nvar documentDotAll = typeof document === 'object' && typeof document.all === 'undefined' && document.all !== undefined ? document.all : {};\n\nmodule.exports = reflectApply\n\t? function isCallable(value) {\n\t\tif (value === documentDotAll) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (typeof value === 'function' && !value.prototype) { return true; }\n\t\ttry {\n\t\t\treflectApply(value, null, badArrayLike);\n\t\t} catch (e) {\n\t\t\tif (e !== isCallableMarker) { return false; }\n\t\t}\n\t\treturn !isES6ClassFn(value);\n\t}\n\t: function isCallable(value) {\n\t\tif (value === documentDotAll) { return true; }\n\t\tif (!value) { return false; }\n\t\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\t\tif (typeof value === 'function' && !value.prototype) { return true; }\n\t\tif (hasToStringTag) { return tryFunctionObject(value); }\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tvar strClass = toStr.call(value);\n\t\treturn strClass === fnClass || strClass === genClass;\n\t};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/is-callable/index.js?");

/***/ }),

/***/ "./node_modules/is-generator-function/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/is-generator-function/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/is-generator-function/index.js?");

/***/ }),

/***/ "./node_modules/is-typed-array/index.js":
/*!**********************************************!*\
  !*** ./node_modules/is-typed-array/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! for-each */ \"./node_modules/for-each/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/is-typed-array/index.js?");

/***/ }),

/***/ "./node_modules/path/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/path/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/path/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/path/node_modules/util/support/isBufferBrowser.js":
/*!************************************************************************!*\
  !*** ./node_modules/path/node_modules/util/support/isBufferBrowser.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://js-kart/./node_modules/path/node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/path/node_modules/util/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/path/node_modules/util/util.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(__webpack_require__.g.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = \"MISSING_ENV_VAR\".NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/path/node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/path/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n//# sourceURL=webpack://js-kart/./node_modules/path/node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/path/path.js":
/*!***********************************!*\
  !*** ./node_modules/path/path.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n\r\nvar isWindows = process.platform === 'win32';\r\nvar util = __webpack_require__(/*! util */ \"./node_modules/path/node_modules/util/util.js\");\r\n\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  var res = [];\r\n  for (var i = 0; i < parts.length; i++) {\r\n    var p = parts[i];\r\n\r\n    // ignore empty parts\r\n    if (!p || p === '.')\r\n      continue;\r\n\r\n    if (p === '..') {\r\n      if (res.length && res[res.length - 1] !== '..') {\r\n        res.pop();\r\n      } else if (allowAboveRoot) {\r\n        res.push('..');\r\n      }\r\n    } else {\r\n      res.push(p);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// returns an array with empty elements removed from either end of the input\r\n// array or the original array if no elements need to be removed\r\nfunction trimArray(arr) {\r\n  var lastIndex = arr.length - 1;\r\n  var start = 0;\r\n  for (; start <= lastIndex; start++) {\r\n    if (arr[start])\r\n      break;\r\n  }\r\n\r\n  var end = lastIndex;\r\n  for (; end >= 0; end--) {\r\n    if (arr[end])\r\n      break;\r\n  }\r\n\r\n  if (start === 0 && end === lastIndex)\r\n    return arr;\r\n  if (start > end)\r\n    return [];\r\n  return arr.slice(start, end + 1);\r\n}\r\n\r\n// Regex to split a windows path into three parts: [*, device, slash,\r\n// tail] windows-only\r\nvar splitDeviceRe =\r\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\r\n\r\n// Regex to split the tail part of the above into [*, dir, basename, ext]\r\nvar splitTailRe =\r\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\r\n\r\nvar win32 = {};\r\n\r\n// Function to split a filename into [root, dir, basename, ext]\r\nfunction win32SplitPath(filename) {\r\n  // Separate device+slash from tail\r\n  var result = splitDeviceRe.exec(filename),\r\n      device = (result[1] || '') + (result[2] || ''),\r\n      tail = result[3] || '';\r\n  // Split the tail into dir, basename and extension\r\n  var result2 = splitTailRe.exec(tail),\r\n      dir = result2[1],\r\n      basename = result2[2],\r\n      ext = result2[3];\r\n  return [device, dir, basename, ext];\r\n}\r\n\r\nfunction win32StatPath(path) {\r\n  var result = splitDeviceRe.exec(path),\r\n      device = result[1] || '',\r\n      isUnc = !!device && device[1] !== ':';\r\n  return {\r\n    device: device,\r\n    isUnc: isUnc,\r\n    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\r\n    tail: result[3]\r\n  };\r\n}\r\n\r\nfunction normalizeUNCRoot(device) {\r\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\r\n}\r\n\r\n// path.resolve([from ...], to)\r\nwin32.resolve = function() {\r\n  var resolvedDevice = '',\r\n      resolvedTail = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1; i--) {\r\n    var path;\r\n    if (i >= 0) {\r\n      path = arguments[i];\r\n    } else if (!resolvedDevice) {\r\n      path = process.cwd();\r\n    } else {\r\n      // Windows has the concept of drive-specific current working\r\n      // directories. If we've resolved a drive letter but not yet an\r\n      // absolute path, get cwd for that drive. We're sure the device is not\r\n      // an unc path at this points, because unc paths are always absolute.\r\n      path = \"MISSING_ENV_VAR\"['=' + resolvedDevice];\r\n      // Verify that a drive-local cwd was found and that it actually points\r\n      // to our drive. If not, default to the drive's root.\r\n      if (!path || path.substr(0, 3).toLowerCase() !==\r\n          resolvedDevice.toLowerCase() + '\\\\') {\r\n        path = resolvedDevice + '\\\\';\r\n      }\r\n    }\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    var result = win32StatPath(path),\r\n        device = result.device,\r\n        isUnc = result.isUnc,\r\n        isAbsolute = result.isAbsolute,\r\n        tail = result.tail;\r\n\r\n    if (device &&\r\n        resolvedDevice &&\r\n        device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n      // This path points to another device so it is not applicable\r\n      continue;\r\n    }\r\n\r\n    if (!resolvedDevice) {\r\n      resolvedDevice = device;\r\n    }\r\n    if (!resolvedAbsolute) {\r\n      resolvedTail = tail + '\\\\' + resolvedTail;\r\n      resolvedAbsolute = isAbsolute;\r\n    }\r\n\r\n    if (resolvedDevice && resolvedAbsolute) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Convert slashes to backslashes when `resolvedDevice` points to an UNC\r\n  // root. Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path,\r\n  // but handle relative paths to be safe (might happen when process.cwd()\r\n  // fails)\r\n\r\n  // Normalize the tail path\r\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\r\n                                !resolvedAbsolute).join('\\\\');\r\n\r\n  return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n         '.';\r\n};\r\n\r\n\r\nwin32.normalize = function(path) {\r\n  var result = win32StatPath(path),\r\n      device = result.device,\r\n      isUnc = result.isUnc,\r\n      isAbsolute = result.isAbsolute,\r\n      tail = result.tail,\r\n      trailingSlash = /[\\\\\\/]$/.test(tail);\r\n\r\n  // Normalize the tail path\r\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\r\n\r\n  if (!tail && !isAbsolute) {\r\n    tail = '.';\r\n  }\r\n  if (tail && trailingSlash) {\r\n    tail += '\\\\';\r\n  }\r\n\r\n  // Convert slashes to backslashes when `device` points to an UNC root.\r\n  // Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    device = normalizeUNCRoot(device);\r\n  }\r\n\r\n  return device + (isAbsolute ? '\\\\' : '') + tail;\r\n};\r\n\r\n\r\nwin32.isAbsolute = function(path) {\r\n  return win32StatPath(path).isAbsolute;\r\n};\r\n\r\nwin32.join = function() {\r\n  var paths = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    if (!util.isString(arg)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (arg) {\r\n      paths.push(arg);\r\n    }\r\n  }\r\n\r\n  var joined = paths.join('\\\\');\r\n\r\n  // Make sure that the joined path doesn't start with two slashes, because\r\n  // normalize() will mistake it for an UNC path then.\r\n  //\r\n  // This step is skipped when it is very clear that the user actually\r\n  // intended to point at an UNC path. This is assumed when the first\r\n  // non-empty string arguments starts with exactly two slashes followed by\r\n  // at least one more non-slash character.\r\n  //\r\n  // Note that for normalize() to treat a path as an UNC path it needs to\r\n  // have at least 2 components, so we don't filter for that here.\r\n  // This means that the user can use join to construct UNC paths from\r\n  // a server name and a share name; for example:\r\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\r\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\r\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\r\n  }\r\n\r\n  return win32.normalize(joined);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// it will solve the relative path from 'from' to 'to', for instance:\r\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\nwin32.relative = function(from, to) {\r\n  from = win32.resolve(from);\r\n  to = win32.resolve(to);\r\n\r\n  // windows is not case sensitive\r\n  var lowerFrom = from.toLowerCase();\r\n  var lowerTo = to.toLowerCase();\r\n\r\n  var toParts = trimArray(to.split('\\\\'));\r\n\r\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\r\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\r\n\r\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (lowerFromParts[i] !== lowerToParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (samePartsLength == 0) {\r\n    return to;\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('\\\\');\r\n};\r\n\r\n\r\nwin32._makeLong = function(path) {\r\n  // Note: this will *probably* throw somewhere.\r\n  if (!util.isString(path))\r\n    return path;\r\n\r\n  if (!path) {\r\n    return '';\r\n  }\r\n\r\n  var resolvedPath = win32.resolve(path);\r\n\r\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\r\n    // path is local filesystem path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\' + resolvedPath;\r\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\r\n    // path is network UNC path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\n\r\nwin32.dirname = function(path) {\r\n  var result = win32SplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nwin32.basename = function(path, ext) {\r\n  var f = win32SplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nwin32.extname = function(path) {\r\n  return win32SplitPath(path)[3];\r\n};\r\n\r\n\r\nwin32.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir;\r\n  var base = pathObject.base || '';\r\n  if (!dir) {\r\n    return base;\r\n  }\r\n  if (dir[dir.length - 1] === win32.sep) {\r\n    return dir + base;\r\n  }\r\n  return dir + win32.sep + base;\r\n};\r\n\r\n\r\nwin32.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = win32SplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nwin32.sep = '\\\\';\r\nwin32.delimiter = ';';\r\n\r\n\r\n// Split a filename into [root, dir, basename, ext], unix version\r\n// 'root' is just a slash, or nothing.\r\nvar splitPathRe =\r\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\nvar posix = {};\r\n\r\n\r\nfunction posixSplitPath(filename) {\r\n  return splitPathRe.exec(filename).slice(1);\r\n}\r\n\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nposix.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path[0] === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\r\n                                !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nposix.normalize = function(path) {\r\n  var isAbsolute = posix.isAbsolute(path),\r\n      trailingSlash = path && path[path.length - 1] === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nposix.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nposix.join = function() {\r\n  var path = '';\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var segment = arguments[i];\r\n    if (!util.isString(segment)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (segment) {\r\n      if (!path) {\r\n        path += segment;\r\n      } else {\r\n        path += '/' + segment;\r\n      }\r\n    }\r\n  }\r\n  return posix.normalize(path);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nposix.relative = function(from, to) {\r\n  from = posix.resolve(from).substr(1);\r\n  to = posix.resolve(to).substr(1);\r\n\r\n  var fromParts = trimArray(from.split('/'));\r\n  var toParts = trimArray(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\n\r\nposix._makeLong = function(path) {\r\n  return path;\r\n};\r\n\r\n\r\nposix.dirname = function(path) {\r\n  var result = posixSplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nposix.basename = function(path, ext) {\r\n  var f = posixSplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nposix.extname = function(path) {\r\n  return posixSplitPath(path)[3];\r\n};\r\n\r\n\r\nposix.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\r\n  var base = pathObject.base || '';\r\n  return dir + base;\r\n};\r\n\r\n\r\nposix.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = posixSplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  allParts[1] = allParts[1] || '';\r\n  allParts[2] = allParts[2] || '';\r\n  allParts[3] = allParts[3] || '';\r\n\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nposix.sep = '/';\r\nposix.delimiter = ':';\r\n\r\n\r\nif (isWindows)\r\n  module.exports = win32;\r\nelse /* posix */\r\n  module.exports = posix;\r\n\r\nmodule.exports.posix = posix;\r\nmodule.exports.win32 = win32;\r\n\n\n//# sourceURL=webpack://js-kart/./node_modules/path/path.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://js-kart/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://js-kart/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/support/types.js":
/*!********************************************!*\
  !*** ./node_modules/util/support/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n\n\nvar isArgumentsObject = __webpack_require__(/*! is-arguments */ \"./node_modules/is-arguments/index.js\");\nvar isGeneratorFunction = __webpack_require__(/*! is-generator-function */ \"./node_modules/is-generator-function/index.js\");\nvar whichTypedArray = __webpack_require__(/*! which-typed-array */ \"./node_modules/which-typed-array/index.js\");\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n\n\n//# sourceURL=webpack://js-kart/./node_modules/util/support/types.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (\"MISSING_ENV_VAR\".NODE_DEBUG) {\n  var debugEnv = \"MISSING_ENV_VAR\".NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = __webpack_require__(/*! ./support/types */ \"./node_modules/util/support/types.js\");\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/which-typed-array/index.js":
/*!*************************************************!*\
  !*** ./node_modules/which-typed-array/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar forEach = __webpack_require__(/*! for-each */ \"./node_modules/for-each/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ \"./node_modules/has-tostringtag/shams.js\")();\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/which-typed-array/index.js?");

/***/ }),

/***/ "./src/client/clientHandler.js":
/*!*************************************!*\
  !*** ./src/client/clientHandler.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Car = __webpack_require__(/*! ../shared_modules/car */ \"./src/shared_modules/car.js\");\r\nconst util = __webpack_require__(/*! ../shared_modules/util */ \"./src/shared_modules/util.js\");\r\nconst PhysX = __webpack_require__(/*! ../shared_modules/physx */ \"./src/shared_modules/physx.js\");\r\nconst Vec2D = PhysX.Vec2D;\r\nconst PhysObject = PhysX.PhysObject;\r\nconst PhysEnv = PhysX.PhysEnv;\r\n\r\nconst wall_material = {\r\n    density: Infinity,\r\n    restitution: .5,\r\n    sFriction: .24,\r\n    dFriction: .16,\r\n};\r\n\r\nclass ClientHandler {\r\n    constructor() {\r\n        this.tick;\r\n        this.confirmedTick;\r\n        this.delay = 1;     // built in delay to help smooth lag spikes\r\n        this.latency = 100;\r\n\r\n        this.state = {\r\n            scene: null,\r\n            cars: {},\r\n            walls: [], \r\n        };\r\n\r\n        this.env = new PhysEnv(1);\r\n\r\n        this.stateBuffer = [];\r\n        this.inputBuffer = [];\r\n        \r\n        this.id;\r\n        this.viewID;\r\n        this.isSpectator;\r\n        this.freezeTime = 0;\r\n        \r\n        this.inputs = {\r\n            left: false,\r\n            right: false,\r\n            up: false,\r\n            down: false,\r\n            shift: false,\r\n            enter: false,\r\n        }\r\n    }\r\n\r\n    getTick() {\r\n        return (util.getTime() + this.latency) / 16 + this.delay;\r\n    }\r\n\r\n    processPacket(packet, event) {\r\n        switch(event) {\r\n            case 'id':\r\n                this.id = packet;\r\n                this.updateViewID();\r\n                break;\r\n            case 'rewind':\r\n                let A = this.state.cars[this.id];\r\n                let B = packet;\r\n\r\n                if(!A && !B)\r\n                    return;\r\n                \r\n                if(A && !B) {\r\n                    this.env.removeObject(A);\r\n                    delete this.state.cars[this.id];\r\n\r\n                    return;\r\n                }\r\n                \r\n                if(!A && B) {\r\n                    this.state.cars[this.id] = new Car(B.pos, B.hue);\r\n                    this.env.addObject(this.state.cars[this.id]);\r\n                }\r\n                \r\n                this.updateCar(this.state.cars[this.id], B);\r\n                break;\r\n            case 'dynamic':\r\n                for(let i = 0; i < util.MAX_PLAYERS; i++) {\r\n                    let A = this.state.cars[i];\r\n                    let B = packet.cars[i];\r\n\r\n                    if(!A && !B || i == this.id)\r\n                        continue;\r\n                    \r\n                    if(A && !B) {\r\n                        this.env.removeObject(A);\r\n                        delete this.state.cars[i];\r\n\r\n                        continue;\r\n                    }\r\n                    \r\n                    if(!A && B) {\r\n                        this.state.cars[i] = new Car(B.pos, B.hue);\r\n                        this.env.addObject(this.state.cars[i]);\r\n                    }\r\n                    \r\n                    this.updateCar(this.state.cars[i], B);\r\n                }\r\n\r\n                break;\r\n            case 'static':\r\n                const changeScene = this.state.scene != packet.scene;    \r\n\r\n                if(this.state.scene == \"lobby\" && packet.scene == \"race\") {\r\n                    this.freezeTime = 5;\r\n                }\r\n\r\n                this.state.scene = packet.scene;\r\n                this.state.walls = [];\r\n                \r\n                for(const border of packet.walls) {\r\n                    let new_border = [];\r\n\r\n                    for(const ref of border) {\r\n                        let pos = new Vec2D(ref.pos.x, ref.pos.y);\r\n                        \r\n                        let points = [];\r\n                        for(const point of ref.points) {\r\n                            points.push(new Vec2D(point.x, point.y));\r\n                        }\r\n\r\n                        let wall = new PhysObject(pos, points, wall_material);\r\n                        new_border.push(wall);\r\n                    }\r\n\r\n                    this.state.walls.push(new_border);\r\n                }\r\n\r\n                if(changeScene)\r\n                    this.resetEnv();\r\n                break;\r\n            default:\r\n        }\r\n    }\r\n\r\n    updateCar(car, ref) {\r\n        car.pos = new Vec2D(ref.pos.x, ref.pos.y);\r\n        car.vel = new Vec2D(ref.vel.x, ref.vel.y);\r\n\r\n        car.angle = ref.angle;\r\n        car.rotVel = ref.rotVel;\r\n\r\n        car.ready = ref.ready;\r\n        car.lap = ref.lap;\r\n\r\n        car.inputs = ref.inputs;\r\n\r\n        for(let i = 0; i < car.points.length; i++) {\r\n            car.points[i] = Vec2D.rotate({x: 0, y: 0}, car.shape[i], car.angle);\r\n            car.points[i].add(car.pos);\r\n        }\r\n    }\r\n\r\n    resetEnv() {\r\n        this.env.clearObjects();\r\n\r\n        // for(const car of Object.values(this.state.cars)) {\r\n        //     this.env.addObject(car);\r\n        // }\r\n\r\n        if(!this.isSpectator && this.state.cars[this.id])\r\n            this.env.addObject(this.state.cars[this.id]);\r\n\r\n        for(const border of this.state.walls) {\r\n            for(const wall of border) {\r\n                this.env.addObject(wall);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateViewID() {\r\n        this.isSpectator = this.id >= util.MAX_PLAYERS || (this.state.scene == \"race\" && this.state.cars[this.id].ready)\r\n        \r\n        if(!this.isSpectator) {\r\n            this.viewID = this.id;\r\n        } else if(!this.state.cars[this.viewID]) {\r\n            this.viewID = Object.keys(this.state.cars)[0];\r\n        }\r\n    }\r\n\r\n    changeViewID() {\r\n        let d = 0;\r\n\r\n        if(this.inputs.left)\r\n            d--;\r\n\r\n        if(this.inputs.right)\r\n            d++;\r\n\r\n        if(d == 0)\r\n            return;\r\n        \r\n        const cars = Object.entries(this.state.cars);\r\n\r\n        let idx = 0;\r\n        for(const id of Object.keys(this.state.cars)) {\r\n            if(id == this.viewID) {\r\n                this.viewID = cars[(idx + d + cars.length) % cars.length][0];\r\n                return;\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    lerpState(alpha) {\r\n        let buffer = util.getBuffer(this.stateBuffer, this.tick - 1);\r\n        \r\n        if(!buffer)\r\n            return this.state;\r\n        \r\n        let lerp = {};\r\n        let curr = this.state.cars;\r\n        let last = buffer.cars;\r\n\r\n        for(let i = 0; i < util.MAX_PLAYERS; i++) {\r\n            let a = curr[i];\r\n            let b = last[i];\r\n\r\n            if(!a)  \r\n                continue;\r\n\r\n            if(!b) {\r\n                lerp[i] = a;\r\n                continue;\r\n            }\r\n            \r\n            let obj = util.copyObj(a);\r\n            \r\n            obj.pos.x = b.pos.x * alpha + a.pos.x * (1 - alpha);\r\n            obj.pos.y = b.pos.y * alpha + a.pos.y * (1 - alpha);\r\n            obj.vel.x = b.vel.x * alpha + a.vel.x * (1 - alpha);\r\n            obj.vel.y = b.vel.y * alpha + a.vel.y * (1 - alpha);\r\n            obj.angle = b.angle * alpha + a.angle * (1 - alpha);\r\n            obj.rotVel = b.rotVel * alpha + a.rotVel * (1 - alpha);\r\n\r\n            lerp[i] = obj;\r\n        }\r\n\r\n        let state = util.copyObj(this.state);\r\n        state.cars = lerp;\r\n\r\n        return state;\r\n    }\r\n\r\n    copyDynamicState(state) {\r\n        let newState = {};\r\n\r\n        newState.cars = {};\r\n        \r\n        for(const [idx, obj] of Object.entries(state.cars)) {\r\n            newState.cars[idx] = {\r\n                angle:  obj.angle,\r\n                rotVel: obj.rotVel,\r\n                lap:    obj.lap,\r\n                ready:  obj.ready,\r\n                pos: {\r\n                    x:  obj.pos.x,\r\n                    y:  obj.pos.y,\r\n                },\r\n                vel: {\r\n                    x:  obj.vel.x,\r\n                    y:  obj.vel.y,\r\n                },\r\n                inputs: {\r\n                    up: obj.inputs.up,\r\n                    down: obj.inputs.down,\r\n                    left: obj.inputs.left,\r\n                    right: obj.inputs.right,\r\n                    shift: obj.inputs.shift,\r\n                    enter: obj.inputs.enter,\r\n                }\r\n            };\r\n            // util.copyObj(obj);\r\n        }\r\n\r\n        return newState;\r\n    }\r\n\r\n    comparePlayerStates(A, B) {\r\n        const t_tolerance = 1;\r\n        const a_tolerance = .1;\r\n\r\n        if(!A || !B)\r\n            return false;\r\n\r\n        const tx = A.pos.x - B.pos.x;\r\n        const ty = A.pos.y - B.pos.y;\r\n        const tdif2 = tx * tx + ty * ty;\r\n\r\n        const vx = A.vel.x - B.vel.x;\r\n        const vy = A.vel.y - B.vel.y;\r\n        const vdif2 = vx * vx + vy * vy;\r\n\r\n        if(tdif2 > t_tolerance * t_tolerance)\r\n            return false;\r\n            \r\n        if(vdif2 > t_tolerance * t_tolerance)\r\n            return false;\r\n        \r\n        if(Math.abs(A.rotVel - B.rotVel) > a_tolerance)\r\n            return false;\r\n\r\n        if(Math.abs(A.angle - B.angle) > a_tolerance)\r\n            return false;\r\n\r\n        if(A.ready != B.ready)\r\n            return false;\r\n\r\n        if(A.lap != B.lap)\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    update(dt) {\r\n        if(this.freezeTime > 0) {\r\n            this.freezeTime -= dt;\r\n            return;\r\n        }\r\n\r\n        for(const [id, car] of Object.entries(this.state.cars)) {\r\n            car.controlPlayer(dt);\r\n        }\r\n\r\n        this.env.update(dt);\r\n    }\r\n}\r\n\r\nmodule.exports = ClientHandler;\n\n//# sourceURL=webpack://js-kart/./src/client/clientHandler.js?");

/***/ }),

/***/ "./src/client/index.js":
/*!*****************************!*\
  !*** ./src/client/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! ../shared_modules/util */ \"./src/shared_modules/util.js\");\r\nconst ClientHandler = __webpack_require__(/*! ./clientHandler */ \"./src/client/clientHandler.js\");\r\nconst Camera = __webpack_require__(/*! ../shared_modules/camera */ \"./src/shared_modules/camera.js\");\r\nconst avsc = __webpack_require__(/*! ../shared_modules/serialize.js */ \"./src/shared_modules/serialize.js\");\r\n(__webpack_require__(/*! dotenv */ \"./node_modules/dotenv/lib/main.js\").config)();\r\n\r\nconsole.log(\"MISSING_ENV_VAR\");\r\n// const HOST = \"wss://js-kart.herokuapp.com/\";\r\n// const HOST = \"wss://js-kart.herokuapp.com/\";\r\nconst HOST = \"wss://js-kart.herokuapp.com/\";\r\n\r\nlet socket = new WebSocket(HOST);\r\n\r\nlet game = new ClientHandler(); \r\n\r\nlet canvas = document.getElementById(\"paper\");\r\nlet camera = new Camera(canvas);\r\n\r\n// TODO: create circular queue for messages\r\nlet messageTypes = {};\r\nlet messages = [];\r\n\r\nsocket.onerror = error => {\r\n    camera.drawError(error);\r\n}\r\n\r\nsocket.onopen = event => {\r\n    console.log(\"Client connected!\");\r\n\r\n    game.tick = Math.floor(game.getTick());\r\n    waitForID();\r\n}\r\n\r\nsocket.onmessage = async event => {\r\n    const buffer = await event.data.arrayBuffer();\r\n    let data = avsc.decode(buffer);\r\n\r\n    if(data.packets.ping) {\r\n        game.latency = data.packets.ping.latency;\r\n        console.log(game.latency);\r\n        socket.send(avsc.encode(data));\r\n        return;\r\n    }\r\n\r\n    pushMessage(data);\r\n\r\n    if(messages.length > 128) {\r\n        for(const [idx, message] of messages.entries()) {\r\n            \r\n            necessary = false;\r\n\r\n            for(const id of Object.keys(message.packets)) {\r\n                if(messageTypes[id] <= 1) {\r\n                    necessary = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if(!necessary) {\r\n                popMessage(idx);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction pushMessage(message) {\r\n    messages.push(message);\r\n\r\n    for(const id of Object.keys(message.packets)) {\r\n        if(messageTypes[id]) {\r\n            messageTypes[id]++;\r\n        } else {\r\n            messageTypes[id] = 1;\r\n        }\r\n    }\r\n}\r\n\r\nfunction popMessage(idx) {\r\n    for(const id of Object.keys(messages[idx].packets)) {\r\n        messageTypes[id]--;\r\n    }\r\n                    \r\n    return messages.splice(idx, 1)[0];\r\n}\r\n\r\nfunction processTick(tick) {\r\n    let rewind = game.tick;\r\n    let auth_state = null;\r\n    \r\n    while(messages.length > 0 && messages[0].tick < tick) {\r\n        const message = popMessage(0);\r\n\r\n        if(message.packets.id != null)\r\n            game.processPacket(message.packets.id, 'id');\r\n        \r\n        if(message.packets.static)\r\n            game.processPacket(message.packets.static, 'static');\r\n\r\n        if(message.packets.dynamic) {\r\n            game.processPacket(message.packets.dynamic, 'dynamic');\r\n\r\n            const buffered = util.getBuffer(game.stateBuffer, message.tick);\r\n            if(buffered) {\r\n                if(game.comparePlayerStates(buffered.cars[game.id], message.packets.dynamic.cars[game.id])) {\r\n                    rewind = game.tick;\r\n                    auth_state = null;\r\n                } else {\r\n                    rewind = message.tick;\r\n                    auth_state = message.packets.dynamic.cars[game.id];\r\n                }\r\n            } else {\r\n                auth_state = message.packets.dynamic.cars[game.id];\r\n            }\r\n        }\r\n    }\r\n\r\n    if(auth_state) {\r\n        game.processPacket(auth_state, 'rewind');\r\n    }\r\n\r\n    return rewind;\r\n}\r\n\r\nfunction handleInputs() {\r\n    let buffered = util.getBuffer(game.stateBuffer, game.tick - 1)\r\n    \r\n    if(buffered)\r\n        buffered = buffered.cars[game.id].inputs;\r\n\r\n    for(const key in game.inputs) {\r\n        if(!buffered || game.inputs[key] != buffered[key]) {\r\n            sendInputs(game.inputs);\r\n\r\n            if(game.isSpectator)\r\n                game.changeViewID();\r\n\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nfunction sendInputs(inputs) {\r\n    let bundle = {\r\n        packets: {\r\n            inputs: inputs, \r\n        },\r\n        tick: game.tick,\r\n    }\r\n\r\n    const message = avsc.encode(bundle);\r\n    socket.send(message);\r\n}\r\n\r\nfunction waitForID() {  \r\n    game.tick = Math.floor(game.getTick());\r\n\r\n    processTick(game.tick);\r\n\r\n    if(game.id != null) {\r\n        gameLoop();\r\n        return;\r\n    }\r\n\r\n    window.requestAnimationFrame(waitForID);\r\n}\r\n\r\n// TODO handle weird collision rubberbanding\r\n// probably comes from having outdated versions of other players\r\n// in the state buffer\r\n\r\nfunction gameLoop() {\r\n    const dt = .016;\r\n    const curTick = Math.floor(game.getTick());\r\n    const alpha = game.getTick() - curTick;\r\n    \r\n    if(curTick - game.tick > 128)\r\n        game.tick = curTick - 128;\r\n\r\n    game.updateViewID();\r\n\r\n    while(game.tick < curTick) {\r\n        \r\n        handleInputs();\r\n        \r\n        if(!game.isSpectator)\r\n            game.state.cars[game.id].inputs = game.inputs;\r\n        \r\n        util.setBuffer(game.stateBuffer, game.tick, game.copyDynamicState(game.state));\r\n        \r\n        game.update(dt);\r\n        \r\n        if(game.state.scene == \"race\") {\r\n            camera.update(game.state.cars[game.viewID], dt);\r\n        }\r\n\r\n        game.tick++;\r\n    }\r\n\r\n    let rewind = processTick(game.tick);\r\n    // console.log(game.tick - rewind);\r\n\r\n    while(rewind < game.tick) {\r\n        for(const [idx, cars] of Object.entries(game.state.cars)) {\r\n            cars.inputs = util.getBuffer(game.stateBuffer, rewind).cars[idx].inputs;\r\n        }\r\n        \r\n        util.setBuffer(game.stateBuffer, rewind, game.copyDynamicState(game.state));\r\n\r\n        game.update(dt);\r\n\r\n        rewind++;\r\n    }\r\n\r\n    let lerp = game.lerpState(alpha);\r\n    camera.draw(lerp, game.viewID, game.isSpectator, game.freezeTime);\r\n\r\n    window.requestAnimationFrame(gameLoop);\r\n}\r\n\r\ndocument.addEventListener(\"keydown\", (e) => {\r\n    switch(e.code) {\r\n        case 'KeyW':\r\n        case 'ArrowUp':\r\n            game.inputs.up = true;\r\n            break;\r\n        case 'KeyA':\r\n        case 'ArrowLeft':\r\n            game.inputs.left = true;\r\n            break;\r\n        case 'KeyS':\r\n        case 'ArrowDown':\r\n            game.inputs.down = true;\r\n            break;\r\n        case 'KeyD':\r\n        case 'ArrowRight':\r\n            game.inputs.right = true;\r\n            break;\r\n        case 'ShiftLeft':\r\n            game.inputs.shift = true;\r\n            break;\r\n        case \"Enter\":\r\n            game.inputs.enter = true;\r\n            break;\r\n        default:\r\n    }\r\n});\r\n\r\ndocument.addEventListener(\"keyup\", (e) => {\r\n    switch(e.code) {\r\n        case 'KeyW':\r\n        case 'ArrowUp':\r\n            game.inputs.up = false;\r\n            break;\r\n        case 'KeyA':\r\n        case 'ArrowLeft':\r\n            game.inputs.left = false;\r\n            break;\r\n        case 'KeyS':\r\n        case 'ArrowDown':\r\n            game.inputs.down = false;\r\n            break;\r\n        case 'KeyD':\r\n        case 'ArrowRight':\r\n            game.inputs.right = false;\r\n            break;\r\n        case 'ShiftLeft':\r\n            game.inputs.shift = false;\r\n            break;\r\n        case 'Enter':\r\n            game.inputs.enter = false;\r\n            break;\r\n        default:\r\n    }\r\n});\n\n//# sourceURL=webpack://js-kart/./src/client/index.js?");

/***/ }),

/***/ "./src/shared_modules/camera.js":
/*!**************************************!*\
  !*** ./src/shared_modules/camera.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("let PhysX = __webpack_require__(/*! ./physx */ \"./src/shared_modules/physx.js\");\r\nlet Vec2D = PhysX.Vec2D;\r\n\r\nfunction num_to_place(num) {\r\n    switch(num) {\r\n        case 1:\r\n            return \"1st\";\r\n        case 2:\r\n            return \"2nd\";\r\n        case 3:\r\n            return \"3rd\";\r\n        default:\r\n            return num+\"th\";\r\n    }\r\n}\r\n\r\nclass Camera {\r\n    constructor(canvas) {\r\n        this.canvas = canvas;\r\n        this.ctx = canvas.getContext(\"2d\");\r\n        this.angle = 0;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.scale = 1;\r\n\r\n        this.offset = 0;\r\n\r\n        this.target = {\r\n            angle: 0,\r\n            x: 0,\r\n            y: 0,\r\n            scale: 1,\r\n        };\r\n\r\n        this.ctx.lineCap = \"round\";\r\n        this.ctx.textAlign = \"center\";\r\n        this.ctx.textBaseline = \"middle\";\r\n        this.ctx.translate(canvas.width * .5, this.canvas.height * .5);\r\n    }\r\n\r\n    update(car, dt) {\r\n        const followFactor = 8 * dt;\r\n\r\n        this.target.angle = car.angle + car.rotVel / 6;\r\n        this.target.x = car.pos.x + car.vel.x / 6;\r\n        this.target.y = car.pos.y + car.vel.y / 6;\r\n        this.target.scale = 1 / (1.7 + Vec2D.mag(car.vel) / 2400);\r\n    \r\n        this.angle += (this.target.angle - this.angle) * followFactor;\r\n        this.x += (this.target.x - this.x) * followFactor;\r\n        this.y += (this.target.y - this.y) * followFactor;\r\n        this.scale += (this.target.scale - this.scale) * followFactor * .2;\r\n    }\r\n\r\n    drawError(error) {\r\n        this.ctx.globalCompositeOperation = \"source-over\";\r\n        this.ctx.fillStyle = \"#121212\";\r\n        \r\n        this.ctx.fillRect(-this.canvas.width * .5, -this.canvas.height * .5, this.canvas.width, this.canvas.height);\r\n\r\n        this.ctx.globalCompositeOperation = \"lighter\";\r\n        this.ctx.shadowBlur = 4;\r\n\r\n        this.ctx.fillStyle = `hsl(0, 30%, 60%)`;\r\n        this.ctx.shadowColor = `hsl(0, 30%, 50%)`;\r\n        this.ctx.font = \"bold 24px Share Tech Mono\";\r\n\r\n        this.ctx.fillText('Could not connect to:', 0, -20);\r\n        this.ctx.fillText(error.target.url, 0, 20);\r\n    }\r\n\r\n    drawWalls(walls) {\r\n        let hue = 0;\r\n        this.ctx.lineWidth = 6;\r\n\r\n        for(const wall of walls)  {\r\n            this.ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;\r\n            this.ctx.strokeStyle = `hsl(${hue}, 50%, 85%)`;\r\n\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(wall.points[1].x, wall.points[1].y);\r\n            this.ctx.lineTo(wall.points[2].x, wall.points[2].y);\r\n\r\n            this.ctx.moveTo(wall.points[0].x, wall.points[0].y);\r\n            this.ctx.lineTo(wall.points[3].x, wall.points[3].y);\r\n            \r\n            this.ctx.closePath();\r\n            this.ctx.stroke();\r\n\r\n            hue += 360 / walls.length;\r\n        }\r\n    }\r\n\r\n    drawStartLine(walls) {\r\n        this.ctx.strokeStyle = `hsl(0, 0%, 15%)`;\r\n        this.ctx.shadowColor = `hsl(0, 0%, 15%)`;\r\n\r\n        this.offset++;\r\n        this.ctx.lineDashOffset = this.offset;\r\n        this.ctx.lineCap = \"butt\";\r\n\r\n        const size = 30;\r\n        this.ctx.lineWidth = size;\r\n        this.ctx.setLineDash([size, size]);\r\n        const len = walls[0].length - 1;\r\n        \r\n        const p1 = walls[1][len].points[1];\r\n        const p2 = walls[0][len].points[0];\r\n\r\n        const slope = Vec2D.normalize({\r\n                        x: p1.x - p2.x,\r\n                        y: p1.y - p2.y,\r\n                    });\r\n\r\n        const perp = new Vec2D(-slope.y, slope.x);\r\n        const offset = perp.mult(size);\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(p1.x, p1.y);\r\n        this.ctx.lineTo(p2.x, p2.y);\r\n        this.ctx.stroke();\r\n\r\n        this.ctx.lineDashOffset = this.offset + size;\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(p1.x + offset.x, p1.y + offset.y);\r\n        this.ctx.lineTo(p2.x + offset.x, p2.y + offset.y);\r\n        this.ctx.stroke();\r\n\r\n        this.ctx.setLineDash([]);\r\n        this.ctx.lineCap = \"round\";\r\n    }\r\n    \r\n    drawObject(obj, color, lineWidth = 2) {\r\n        this.ctx.strokeStyle = color;\r\n        this.ctx.lineWidth = lineWidth;\r\n\r\n        this.ctx.beginPath();\r\n        for(const point of obj.points) {\r\n            this.ctx.lineTo(point.x, point.y);\r\n        }\r\n        this.ctx.closePath();\r\n        this.ctx.stroke();\r\n    }\r\n\r\n    drawPlaces(state, _id) {\r\n        for(const [id,  car] of Object.entries(state.cars)) {\r\n            if(car.lap == -1)\r\n                continue;\r\n\r\n            this.ctx.fillStyle = `hsl(${car.hue}, 100%, 90%)`;\r\n            this.ctx.shadowColor = `hsl(${car.hue}, 100%, 50%)`;\r\n            this.ctx.font = \"bold 24px Share Tech Mono\";\r\n\r\n            this.ctx.fillText(num_to_place(car.lap), car.pos.x, car.pos.y - 30);\r\n        }\r\n    }\r\n\r\n    drawLobby(state, id, isSpectator) {\r\n        for(const wall of state.walls)\r\n            this.drawWalls(wall);\r\n\r\n        this.drawPlaces(state, id)\r\n\r\n        for(const car of Object.values(state.cars)) {\r\n            const rd = car.ready ? 1 : .3;\r\n            this.ctx.shadowColor = `hsl(${car.hue}, ${100 * rd}%, ${50 * rd}%)`;\r\n            const color = `hsl(${car.hue}, ${100 * rd}%, ${85 * rd}%)`;\r\n            this.drawObject(car, color, 4);\r\n        }\r\n\r\n        if(!isSpectator && !state.cars[id].ready) {\r\n            const car = state.cars[id]\r\n\r\n            this.ctx.fillStyle = `hsl(${car.hue}, 100%, 90%)`;\r\n            this.ctx.shadowColor = `hsl(${car.hue}, 100%, 50%)`;\r\n            this.ctx.font = \"bold 24px Share Tech Mono\";\r\n\r\n            this.ctx.fillText(\"PRESS [ENTER] TO READY\", 0, this.canvas.height * -.4);\r\n        }\r\n\r\n        if(isSpectator) {\r\n            this.ctx.fillStyle = `hsl(0, 0%, 90%)`;\r\n            this.ctx.shadowColor = `hsl(0, 0%, 50%)`;\r\n            this.ctx.font = \"bold 24px Share Tech Mono\";\r\n\r\n            this.ctx.fillText(\"SPECTATING\", 0, this.canvas.height * -.4);\r\n        }\r\n    }\r\n\r\n    drawRace(state, id, isSpectator, freezeTime) {\r\n        this.ctx.translate(0, this.canvas.height * .17);\r\n        this.ctx.scale(this.scale, this.scale);\r\n        this.ctx.rotate(-this.angle - Math.PI/2);\r\n        this.ctx.translate(-this.x, -this.y);\r\n\r\n        this.drawStartLine(state.walls);\r\n        \r\n        for(const wall of state.walls)\r\n            this.drawWalls(wall);\r\n\r\n        for(const car of Object.values(state.cars)) {\r\n            this.ctx.shadowColor = `hsl(${car.hue}, 100%, 50%)`;\r\n            const color = `hsl(${car.hue}, 100%, 85%)`;\r\n            this.drawObject(car, color, 4);\r\n        }\r\n\r\n        this.ctx.translate(this.x, this.y);\r\n        this.ctx.rotate(this.angle + Math.PI/2);\r\n        this.ctx.scale(1/this.scale, 1/this.scale);\r\n        this.ctx.translate(0, -this.canvas.height * .17);\r\n        \r\n        if(isSpectator) {\r\n            const car = state.cars[id];\r\n            this.ctx.fillStyle = `hsl(${car.hue}, ${100}%, ${90}%)`;\r\n            this.ctx.shadowColor = `hsl(${car.hue}, ${100}%, ${50}%)`;\r\n            this.ctx.font = \"bold 24px Share Tech Mono\";\r\n\r\n            this.ctx.fillText(`SPECTATING: CAR ${parseInt(id) + 1}`, 0, this.canvas.height * -.4);\r\n        }\r\n\r\n        if(freezeTime > 0) {\r\n            const car = state.cars[id];\r\n\r\n            this.ctx.strokeStyle = `hsl(${car.hue}, ${100}%, ${90}%)`;\r\n            this.ctx.shadowColor = `hsl(${car.hue}, ${100}%, ${50}%)`;\r\n            this.ctx.font = \"bold 240px Share Tech Mono\";\r\n            this.ctx.lineWidth = 1;\r\n            this.ctx.globalAlpha = freezeTime % 1;\r\n\r\n            this.ctx.strokeText(Math.ceil(freezeTime), 0, -this.canvas.height / 6);\r\n            \r\n            this.ctx.globalAlpha = 1;\r\n        }\r\n    }\r\n\r\n    draw(state, id, isSpectator, freezeTime) {\r\n        this.ctx.globalCompositeOperation = \"source-over\";\r\n        this.ctx.fillStyle = \"#121212\";\r\n        \r\n        this.ctx.fillRect(-this.canvas.width * .5, -this.canvas.height * .5, this.canvas.width, this.canvas.height);\r\n\r\n        this.ctx.globalCompositeOperation = \"lighter\";\r\n        this.ctx.shadowBlur = 4;\r\n\r\n        if(state.scene == \"lobby\") {\r\n            this.drawLobby(state, id, isSpectator);\r\n        } else {\r\n            this.drawRace(state, id, isSpectator, freezeTime);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Camera;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/camera.js?");

/***/ }),

/***/ "./src/shared_modules/car.js":
/*!***********************************!*\
  !*** ./src/shared_modules/car.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PhysX = __webpack_require__(/*! ./physx */ \"./src/shared_modules/physx.js\");\r\nconst Vec2D = PhysX.Vec2D;\r\nconst PhysObject = PhysX.PhysObject;\r\nconst PhysEnv = PhysX.PhysEnv;\r\n\r\nclass Car extends PhysObject {\r\n    constructor(pos, hue, material = null) {\r\n        const pts = [new Vec2D(0, 1),\r\n                     new Vec2D(0, 19),\r\n                     new Vec2D(12, 22),\r\n                     new Vec2D(40, 19),\r\n                     new Vec2D(40, 1),\r\n                     new Vec2D(12, -2),];\r\n\r\n        if(!material) {\r\n            material = {\r\n                density: 2.5,\r\n                restitution: .35,\r\n                sFriction: .06,\r\n                dFriction: .04,\r\n            };\r\n        }\r\n\r\n        super(pos, pts, material);\r\n        this.moi *= 10;\r\n        // this.masks = ['car-car'];\r\n\r\n        this.inputs = {\r\n            left: false,\r\n            right: false,\r\n            up: false,\r\n            down: false,\r\n            shift: false,\r\n            enter: false,\r\n        }\r\n\r\n        this.ready = false;\r\n        this.hue = hue;\r\n        this.lap = -1;\r\n        this.lastCheckpoint = 0;\r\n    }\r\n\r\n    controlPlayer(dt) {\r\n        const speed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);\r\n        const maxSpeed = 1000;\r\n        const isDrifting = false;\r\n\r\n        const accFactor = 600 * dt;\r\n        const maxRotFactor = 2.5;\r\n        const maxRot = maxRotFactor * Math.min(speed / 100, 1)\r\n        const rotFactor = 14 * dt;\r\n        const driftFactor = isDrifting ? .96 : .8;\r\n        \r\n        const dx = Math.cos(this.angle);\r\n        const dy = Math.sin(this.angle);\r\n\r\n        const dir = new Vec2D(dx, dy);\r\n        const orth = new Vec2D(-dy, dx);\r\n\r\n        const fwdSpeed = dir.dot(this.vel);\r\n        const fwdVel = dir.mult(fwdSpeed);\r\n\r\n        const orthSpeed = orth.dot(this.vel);\r\n        const orthVel = orth.mult(orthSpeed * driftFactor);\r\n\r\n        this.vel = fwdVel.addRet(orthVel);\r\n\r\n        if(this.inputs.up && !this.inputs.down && fwdSpeed < maxSpeed) {\r\n            const dx = Math.cos(this.angle) * accFactor;\r\n            const dy = Math.sin(this.angle) * accFactor;\r\n    \r\n            this.vel.add(new Vec2D(dx, dy));\r\n        } else if(this.inputs.down && !this.inputs.up && fwdSpeed > -maxSpeed / 2) {\r\n            const dx = Math.cos(this.angle) * accFactor;\r\n            const dy = Math.sin(this.angle) * accFactor;\r\n    \r\n            this.vel.sub(new Vec2D(dx, dy));\r\n        } else {\r\n            this.vel.x *= isDrifting ? .999 : .99;\r\n            this.vel.y *= isDrifting ? .999 : .99;\r\n        }\r\n    \r\n        const turningLeft = this.inputs.left && !this.inputs.right; \r\n        const turningRight = !this.inputs.left && this.inputs.right;\r\n\r\n        if((turningLeft && fwdSpeed > 0) || (turningRight && fwdSpeed < 0)) {\r\n            if(this.rotVel > 0) this.rotVel = 0;\r\n            if(this.rotVel < -maxRot) this.rotVel = -maxRot;\r\n\r\n            this.rotVel -= rotFactor;\r\n        } else if((turningRight && fwdSpeed > 0) || (turningLeft && fwdSpeed < 0)) {\r\n            if(this.rotVel < 0) this.rotVel = 0;\r\n            if(this.rotVel > maxRot) this.rotVel = maxRot;\r\n\r\n            this.rotVel += rotFactor;\r\n        } else {\r\n            this.rotVel *= .92;\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = Car;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/car.js?");

/***/ }),

/***/ "./src/shared_modules/physx.js":
/*!*************************************!*\
  !*** ./src/shared_modules/physx.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("function clip(v1, v2, n, o) {\r\n    let points = [];\r\n    const d1 = n.dot(v1) - o;\r\n    const d2 = n.dot(v2) - o;\r\n\r\n    if(d1 >= 0) points.push(v1);\r\n\r\n    if(d2 >= 0) points.push(v2);\r\n\r\n    if(d1 * d2 < 0) {\r\n        let e = Vec2D.dif(v1, v2);\r\n        const u = d1 / (d1 - d2);\r\n        e = e.mult(u);\r\n        e.add(v1);\r\n\r\n        points.push(e);\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\nfunction debugLine(p1, p2, ctx, color = \"red\") {\r\n    ctx.strokeStyle = color;\r\n    ctx.beginPath()\r\n    ctx.moveTo(p1.x, p1.y);\r\n    ctx.lineTo(p2.x, p2.y);\r\n    ctx.stroke();\r\n}\r\n\r\nfunction insertionSort(arr, lambda = (x) => x) {\r\n    let val, j, i;\r\n    for(i = 1; i < arr.length; i++) {\r\n        val = arr[i];\r\n        j = i - 1;\r\n\r\n        while(j >= 0 && lambda(arr[j]) > lambda(val)) {\r\n            arr[j + 1] = arr[j];\r\n            j--;\r\n        }\r\n        arr[j + 1] = val;\r\n    }\r\n}\r\n\r\nfunction polygonSupport(points, d) {\r\n    let furthest = null;\r\n    let dot = -Infinity;\r\n\r\n    for(const point of points) {\r\n        const proj = point.dot(d);\r\n        if(proj > dot) {\r\n            furthest = point;\r\n            dot = proj;\r\n        }\r\n    }\r\n\r\n    return furthest;\r\n}\r\n\r\nfunction minkowskiDifSupport(s1, s2, d) {\r\n    return Vec2D.dif(polygonSupport(s2.points, d.mult(-1)), polygonSupport(s1.points, d));\r\n}\r\n\r\nfunction mean(arr) {\r\n    let sum = 0;\r\n    for(const el of arr) {\r\n        sum += el;\r\n    }\r\n    return sum / arr.length;\r\n}\r\n\r\nfunction variance(arr) {\r\n    let variance = 0;\r\n    const mean = mean(arr);\r\n    for(const el of arr) {\r\n        const dif = el - mean;\r\n        variance += dif * dif;\r\n    }\r\n    return variance / arr.length;\r\n}\r\n\r\nfunction calculateMassAndMoi(obj) {\r\n    if(obj.material.density == Infinity)\r\n        return [Infinity, Infinity];\r\n\r\n    let mass = 0;\r\n    // let center = new Vec2D(0, 0);\r\n    let moi = 0;\r\n\r\n    let prev = obj.shape.length - 1;\r\n    for(let cur = 0; cur < obj.shape.length; cur++) {\r\n        const a = obj.shape[prev];\r\n        const b = obj.shape[cur];\r\n\r\n        const areaStep = Math.abs(Vec2D.cross(a, b) / 2);\r\n        const massStep = areaStep * obj.material.density;\r\n        // const centerStep = a.addRet(b).div(3);\r\n        const moiStep = massStep / 6 * (a.dot(a) + b.dot(b) + a.dot(b));\r\n\r\n        mass += massStep\r\n        // center.add(centerStep);\r\n        moi += moiStep;\r\n    }\r\n\r\n    return [mass, moi];\r\n}\r\n\r\nconst wood = {\r\n    density: 1,\r\n    restitution: .45,\r\n    sFriction: .3,\r\n    dFriction: .2,\r\n};\r\n\r\nconst rubber = {\r\n    density: 2.5,\r\n    restitution: .95,\r\n    sFriction: .6,\r\n    dFriction: .4,\r\n};\r\n\r\nconst wall = {\r\n    density: Infinity,\r\n    restitution: .5,\r\n    sFriction: .24,\r\n    dFriction: .16,\r\n};\r\n\r\nclass Vec2D {\r\n    static rotate(pivot, point, rad) {\r\n        const dx = (point.x - pivot.x);\r\n        const dy = (point.y - pivot.y);\r\n\r\n        const sin = Math.sin(rad);\r\n        const cos = Math.cos(rad);\r\n\r\n        const nx = dx * cos - dy * sin; \r\n        const ny = dx * sin + dy * cos;\r\n\r\n        return new Vec2D(nx, ny);\r\n    }\r\n\r\n    static mag(vec) {\r\n        return Math.sqrt(vec.x * vec.x + vec.y * vec.y);\r\n    }\r\n    \r\n    static distance(v1, v2) {\r\n        return Vec2D.mag(Vec2D.dif(v1, v2));\r\n    }\r\n\r\n    static normalize(vec) {\r\n        if(vec.x == 0 && vec.y == 0) return new Vec2D(0, 0);\r\n        const mag = Vec2D.mag(vec);\r\n        return new Vec2D(vec.x / mag, vec.y / mag);\r\n    }\r\n\r\n    static dif(v1, v2) {\r\n        return new Vec2D(v2.x - v1.x, v2.y - v1.y);\r\n    }\r\n\r\n    static tripleProd(v1, v2, v3) {\r\n        const k = v1.x * v2.y - v1.y * v2.x;\r\n        const nx = -v3.y * k;\r\n        const ny = v3.x * k;\r\n        return new Vec2D(nx, ny, 0);\r\n    }\r\n\r\n    static cross(A, B) {\r\n        if(A.x == undefined) {\r\n            // scalar x vector\r\n            return new Vec2D(-A * B.y, A * B.x);\r\n        } else if(B.x == undefined) {\r\n            // vector x scalar\r\n            return new Vec2D(B * A.y, -B * A.x);\r\n        } else {\r\n            // vector x vector\r\n            return A.x * B.y - A.y * B.x;\r\n        }\r\n    }\r\n\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    add(other) {\r\n        this.x += other.x;\r\n        this.y += other.y;\r\n    }\r\n\r\n    sub(other) {\r\n        this.x -= other.x;\r\n        this.y -= other.y;\r\n    }\r\n\r\n    scale(num) {\r\n        this.x *= num;\r\n        this.y *= num;\r\n    }\r\n    \r\n    addRet(other) {\r\n        return new Vec2D(this.x + other.x, this.y + other.y);\r\n    }\r\n\r\n    subRet(other) {\r\n        return new Vec2D(this.x - other.x, this.y - other.y);\r\n    }\r\n\r\n    mult(num) {\r\n        return new Vec2D(this.x * num, this.y * num);\r\n    }\r\n\r\n    div(num) {\r\n        return new Vec2D(this.x / num, this.y / num);\r\n    }\r\n\r\n    dot(other) {\r\n        return this.x * other.x + this.y * other.y;\r\n    }\r\n}\r\n\r\nclass AABB {\r\n\r\n    static findAABB(obj) {\r\n        let b = new Vec2D(Infinity, Infinity);\r\n        let e = new Vec2D(-Infinity, -Infinity);\r\n\r\n        for(const point of obj.points) {\r\n            b.x = Math.min(point.x, b.x);\r\n            b.y = Math.min(point.y, b.y);\r\n\r\n            e.x = Math.max(point.x, e.x);\r\n            e.y = Math.max(point.y, e.y);\r\n        }\r\n\r\n        return new AABB(b, e);\r\n    }\r\n\r\n    constructor(b, e) {\r\n        this.b = b;\r\n        this.e = e;\r\n    }\r\n\r\n    update(obj) {\r\n        this.b.add(new Vec2D(Infinity, Infinity));\r\n        this.e.add(new Vec2D(-Infinity, -Infinity));\r\n\r\n        for(const point of obj.points) {\r\n            this.b.x = Math.min(point.x, this.b.x);\r\n            this.b.y = Math.min(point.y, this.b.y);\r\n\r\n            this.e.x = Math.max(point.x, this.e.x);\r\n            this.e.y = Math.max(point.y, this.e.y);\r\n        }\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.strokeStyle = this.color;\r\n        ctx.strokeRect(this.b.x, this.b.y, this.e.x - this.b.x, this.e.y - this.b.y);\r\n    }\r\n}\r\n\r\nclass PhysObject {\r\n\r\n    static findCOM(points) {\r\n        let COM = new Vec2D(0, 0);\r\n        \r\n        for(const point of points) {\r\n            COM.add(point);\r\n        }\r\n\r\n        COM.x /= points.length;\r\n        COM.y /= points.length;\r\n\r\n        return COM;\r\n    }\r\n\r\n    constructor(pos, points, material = wood) {\r\n        this.force = new Vec2D(0, 0);\r\n        this.acc = new Vec2D(0, 0);\r\n        this.vel = new Vec2D(0, 0);\r\n        this.pos = pos;\r\n\r\n        this.torque = 0;\r\n        this.rotAcc = 0;\r\n        this.rotVel = 0;\r\n        this.angle = 0;\r\n\r\n        this.masks = [];\r\n\r\n        const center = PhysObject.findCOM(points);\r\n        points.forEach((p) => p.sub(center));\r\n        this.shape = points;\r\n        this.points = [];\r\n        for(let i = 0; i < points.length; i++) {\r\n            this.points[i] = Vec2D.rotate(new Vec2D(0, 0), this.shape[i], this.angle);\r\n            this.points[i].add(this.pos);\r\n        }\r\n\r\n        this.material = material;\r\n        const [mass, moi] = calculateMassAndMoi(this);\r\n\r\n        this.mass = mass;\r\n        this.moi = moi;\r\n        \r\n        this.AABB = AABB.findAABB(this);\r\n        this.func = null;\r\n    }\r\n\r\n    // a force consists of a position vector and a direction vector\r\n    applyForce(force) {\r\n        const r = new Vec2D(force.pos.x - this.pos.x, force.pos.y - this.pos.y);\r\n\r\n        this.force.add(force.dir);\r\n        this.torque += r.x * force.dir.y - r.y * force.dir.x;\r\n    }\r\n\r\n    stepForces(dt) {\r\n        this.acc = this.force.div(this.mass);\r\n        \r\n        if(this.mass == 0)\r\n            this.acc = new Vec2D(0, 0);\r\n        \r\n        this.vel.add(this.acc.mult(dt));\r\n        \r\n        this.pos.add(this.vel.mult(dt));\r\n        \r\n        this.rotAcc = this.torque / this.moi;\r\n\r\n        if(this.moi == 0)\r\n            this.rotAcc = 0;\r\n        \r\n        this.rotVel += this.rotAcc * dt;\r\n\r\n        this.angle += this.rotVel * dt;\r\n\r\n        this.force = new Vec2D(0, 0);\r\n        this.torque = 0;\r\n    }\r\n\r\n    update() {\r\n        for(let i = 0; i < this.points.length; i++) {\r\n            this.points[i] = Vec2D.rotate(new Vec2D(0, 0), this.shape[i], this.angle);\r\n            this.points[i].add(this.pos);\r\n        }\r\n\r\n        this.AABB.update(this);\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.strokeStyle = \"white\";\r\n        ctx.lineWidth = 1.5;\r\n\r\n        ctx.beginPath();\r\n        for(const point of this.points) {\r\n            ctx.lineTo(point.x, point.y);\r\n        }\r\n        ctx.closePath();\r\n\r\n        ctx.stroke();\r\n    }\r\n}\r\n\r\nclass PhysEnv {\r\n    constructor(iterations = 1) {\r\n        this.objects = [];\r\n        this.intervals = [];\r\n        this.sweepX = true;\r\n\r\n        this.iterations = iterations;\r\n    }\r\n\r\n    addObject(obj) {\r\n        let start = [obj.AABB.b, this.objects.length];\r\n        let end = [obj.AABB.e, this.objects.length];\r\n        \r\n        this.intervals.push(start, end);\r\n        this.objects.push(obj);\r\n    }\r\n\r\n    removeObject(obj) {\r\n        let idx = -1;\r\n        \r\n        for(let i = 0; i < this.objects.length; i++) {\r\n            if(obj == this.objects[i]) {\r\n                idx = i;\r\n                this.objects.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n\r\n        for(let i = this.intervals.length - 1; i >= 0; i--) {\r\n            if(idx == this.intervals[i][1]) {\r\n                this.intervals.splice(i, 1);\r\n            } else if(this.intervals[i][1] > idx) {\r\n                this.intervals[i][1]--;\r\n            }\r\n        }\r\n    }\r\n\r\n    clearObjects() {\r\n        this.objects = [];\r\n        this.intervals = [];\r\n    }\r\n\r\n    sweepAndPrune() {\r\n        let overlaps = [];\r\n        let activeObjects = {};\r\n\r\n        if(this.sweepX) {\r\n            insertionSort(this.intervals, (x) => x[0].x);\r\n        } else {\r\n            insertionSort(this.intervals, (x) => x[0].y);\r\n        }\r\n\r\n        for(let i = this.intervals.length - 1; i >= 0; i--) {\r\n            const node = this.intervals[i];\r\n            if(activeObjects[node[1]] != null) {\r\n                delete activeObjects[node[1]];\r\n            } else {\r\n                for(const key in activeObjects) {\r\n                    if((this.objects[node[1]].mass == Infinity &&\r\n                        this.objects[activeObjects[key]].mass == Infinity) || \r\n                       (this.objects[node[1]].mass == 0 &&\r\n                        this.objects[activeObjects[key]].mass == 0))\r\n                        continue;\r\n                    overlaps.push([this.objects[node[1]], this.objects[activeObjects[key]]]);\r\n                }\r\n\r\n                activeObjects[node[1]] = node[1];\r\n            }\r\n        }\r\n\r\n        // for(const node of this.intervals) {\r\n        //     if(activeObjects[node[1]] != null) {\r\n        //         delete activeObjects[node[1]];\r\n        //     } else {\r\n        //         for(const key in activeObjects) {\r\n        //             overlaps.push([this.objects[node[1]], this.objects[activeObjects[key]]]);\r\n        //         }\r\n\r\n        //         activeObjects[node[1]] = node[1];\r\n        //     }\r\n        // }\r\n\r\n        return overlaps;\r\n    }\r\n\r\n    update(dt) {\r\n        this.stepForces(dt);\r\n        for(let i = 0; i < this.iterations; i++) {\r\n            this.detectCollisions();\r\n        }\r\n    }\r\n\r\n    stepForces(dt) {\r\n        for(const obj of this.objects) {\r\n            obj.stepForces(dt);\r\n            obj.update();\r\n        }\r\n    }\r\n\r\n    detectCollisions() {\r\n        let simplex = [];\r\n        let possibleCollisions = this.sweepAndPrune();\r\n        for(let [s1, s2] of possibleCollisions) {\r\n            if((simplex = this.GJK(s1, s2))) {\r\n                if(s1.func) s1.func(s1, s2);\r\n                if(s2.func) s2.func(s2, s1);\r\n                \r\n                if(s1.mass == 0 || s2.mass == 0)\r\n                    continue;\r\n\r\n                let masked = false;\r\n\r\n                for(let i = 0; i < s1.masks.length; i++) {\r\n                    for(let j = 0; j < s2.masks.length; j++) {\r\n                        if(s1.masks[i] == s2.masks[j]) {\r\n                            masked = true;\r\n                            \r\n                            i = s1.masks.length;\r\n                            j = s2.masks.length;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(masked)\r\n                    continue;\r\n\r\n                let [normal, depth] = this.EPA(s1, s2, simplex);\r\n                \r\n                let contacts = this.findContacts(s1, s2, normal);\r\n\r\n                if(contacts == null)\r\n                    continue;\r\n\r\n                for(const contact of contacts)\r\n                    this.applyImpulses(s1, s2, normal, contact);\r\n\r\n                this.resolveIntersections(s1, s2, normal, depth);\r\n\r\n                s1.update();\r\n                s2.update();\r\n            }\r\n        }\r\n    }\r\n\r\n    resolveIntersections(s1, s2, normal, depth) {\r\n        const slop = .1;\r\n        const percent = .85;\r\n        const correction = Math.max(depth - slop, 0) * percent;\r\n        const totalMass = s1.mass + s2.mass;\r\n        if(s1.mass == Infinity && s2.mass == Infinity) {\r\n            return;\r\n        } else if(s1.mass == Infinity) {\r\n            s2.pos.x += normal.x * correction;\r\n            s2.pos.y += normal.y * correction;\r\n        } else if(s2.mass == Infinity) {\r\n            s1.pos.x -= normal.x * correction;\r\n            s1.pos.y -= normal.y * correction;\r\n        } else {\r\n            s1.pos.x -= normal.x * correction * s2.mass / totalMass;\r\n            s1.pos.y -= normal.y * correction * s2.mass / totalMass;\r\n            \r\n            s2.pos.x += normal.x * correction * s1.mass / totalMass;\r\n            s2.pos.y += normal.y * correction * s1.mass / totalMass;\r\n        }\r\n    }\r\n\r\n    applyImpulses(s1, s2, normal, contact) {\r\n        const r1 = Vec2D.dif(s1.pos, contact);\r\n        const v1 = s1.vel.addRet(Vec2D.cross(s1.rotVel, r1));\r\n\r\n        const r2 = Vec2D.dif(s2.pos, contact);\r\n        const v2 = s2.vel.addRet(Vec2D.cross(s2.rotVel, r2));\r\n\r\n        const abVel = Vec2D.dif(v1, v2);\r\n        const contactVel = abVel.dot(normal);\r\n\r\n        if(contactVel >= 0)\r\n            return;\r\n\r\n        const armA = Vec2D.cross(r1, normal);\r\n        const armB = Vec2D.cross(r2, normal);\r\n\r\n        const rest = Math.min(s1.material.restitution, s2.material.restitution);\r\n\r\n        const m = 1 / s1.mass + 1 / s2.mass + armA * armA / s1.moi + armB * armB / s2.moi; \r\n        const j = (-(rest + 1) * contactVel) / m;\r\n        const impulse = normal.mult(j);\r\n\r\n        s1.vel.sub(impulse.div(s1.mass));\r\n        s2.vel.add(impulse.div(s2.mass));\r\n        \r\n        const r1CrossI = Vec2D.cross(r1, impulse);\r\n        const r2CrossI = Vec2D.cross(r2, impulse);\r\n\r\n        s1.rotVel -= r1CrossI / s1.moi;\r\n        s2.rotVel += r2CrossI / s2.moi;\r\n\r\n        const tangent = Vec2D.normalize(abVel.subRet(normal.mult(contactVel)));\r\n        const jt = -abVel.dot(tangent) / m;\r\n\r\n        const mu = Math.sqrt(s1.material.sFriction * s1.material.sFriction + s2.material.sFriction * s2.material.sFriction);\r\n\r\n        if(Math.abs(jt) < j * mu) {\r\n            var impulset = tangent.mult(jt);\r\n        } else {\r\n            const dFriction = Math.sqrt(s1.material.dFriction * s1.material.dFriction + s2.material.dFriction * s2.material.dFriction);\r\n            var impulset = tangent.mult(-j * dFriction);\r\n        }\r\n\r\n        if(!isFinite(impulset.x) || !isFinite(impulset.y))\r\n            return;\r\n\r\n        s1.vel.sub(impulset.div(s1.mass));\r\n        s2.vel.add(impulset.div(s2.mass));\r\n\r\n        const r1CrossIt = Vec2D.cross(r1, impulset);\r\n        const r2CrossIt = Vec2D.cross(r2, impulset);\r\n\r\n        s1.rotVel -= r1CrossIt / s1.moi;\r\n        s2.rotVel += r2CrossIt / s2.moi;\r\n    }\r\n\r\n    findContacts(s1, s2, normal) {\r\n        const [p1, e1] = this.findCollisionEdge(s1, normal);\r\n        const [p2, e2] = this.findCollisionEdge(s2, normal.mult(-1));\r\n\r\n        const e1Dif = Vec2D.dif(e1[1], e1[0]);\r\n        const e2Dif = Vec2D.dif(e2[1], e2[0]);\r\n\r\n        let ref, pRef, eRef, inc, pInc, eInc;\r\n        if(Math.abs(e1Dif.dot(normal)) <= Math.abs(e2Dif.dot(normal))) {\r\n            pRef = p1;\r\n            eRef = e1;\r\n            ref = e1Dif;\r\n\r\n            pInc = p2;\r\n            eInc = e2;\r\n            inc = e2Dif;\r\n        } else {\r\n            pRef = p2;\r\n            eRef = e2;\r\n            ref = e2Dif;\r\n\r\n            pInc = p1;\r\n            eInc = e1;\r\n            inc = e1Dif;\r\n        }\r\n\r\n        const refV = Vec2D.normalize(ref).mult(-1);\r\n        const o1 = refV.dot(eRef[0]);\r\n\r\n        let cp = clip(eInc[0], eInc[1], refV, o1);\r\n\r\n        if(cp.length < 2) return;\r\n\r\n        const o2 = refV.dot(eRef[1]);\r\n        \r\n        cp = clip(cp[0], cp[1], refV.mult(-1), -o2);\r\n        \r\n        if(cp.length < 2) return;\r\n\r\n        let refNorm = Vec2D.cross(ref, -1);\r\n        \r\n        const max = refNorm.dot(pRef);\r\n\r\n        if(refNorm.dot(cp[1]) - max < 0)\r\n            cp.splice(1, 1);\r\n\r\n        if(refNorm.dot(cp[0]) - max < 0)\r\n            cp.splice(0, 1);\r\n    \r\n        return cp;\r\n    }\r\n\r\n    findCollisionEdge(s, normal) {\r\n        let v = null;\r\n        let idx = null;\r\n        let dot = -Infinity;\r\n    \r\n        for(const [i, point] of s.points.entries()) {\r\n            const proj = point.dot(normal);\r\n            if(proj > dot) {\r\n                v = point;\r\n                idx = i;\r\n                dot = proj;\r\n            }\r\n        }\r\n    \r\n        const v0 = s.points[(idx - 1 + s.points.length) % s.points.length];\r\n        const v1 = s.points[(idx + 1) % s.points.length];\r\n\r\n        const leftEdge = Vec2D.dif(v, v0);\r\n        const rightEdge = Vec2D.dif(v, v1);\r\n\r\n        if(Vec2D.normalize(rightEdge).dot(normal) <= Vec2D.normalize(leftEdge).dot(normal)) {\r\n            return [v, [v0, v], leftEdge];\r\n        } else {\r\n            return [v, [v, v1], rightEdge];\r\n        }\r\n    }\r\n\r\n    GJK(s1, s2) {\r\n        let d = Vec2D.normalize(Vec2D.dif(s1.pos, s2.pos));\r\n        let simplex = [minkowskiDifSupport(s1, s2, d)];\r\n        d = Vec2D.dif(simplex[0], new Vec2D(0, 0));\r\n\r\n        while(true) {\r\n            d = Vec2D.normalize(d);\r\n            const A = minkowskiDifSupport(s1, s2, d);\r\n            if(A.dot(d) < 0)\r\n                return false;\r\n            simplex.push(A);\r\n            if(this.handleSimplex(simplex, d))\r\n                return simplex;\r\n        }\r\n    }\r\n\r\n    handleSimplex(simplex, d) {\r\n        if(simplex.length == 2)\r\n            return this.lineCase(simplex, d);\r\n        return this.triangleCase(simplex, d);\r\n    }\r\n\r\n    lineCase(simplex, d) {\r\n        let [B, A] = simplex;\r\n        let AB = Vec2D.dif(A, B);\r\n        let AO = Vec2D.dif(A, new Vec2D(0, 0));\r\n        let ABperp = Vec2D.tripleProd(AB, AO, AB);\r\n        d.x = ABperp.x;\r\n        d.y = ABperp.y;\r\n        return false;\r\n    }\r\n\r\n    triangleCase(simplex, d) {\r\n        let [C, B, A] = simplex;\r\n\r\n        let AB = Vec2D.dif(A, B);\r\n        let AC = Vec2D.dif(A, C);\r\n        let AO = Vec2D.dif(A, new Vec2D(0, 0));\r\n\r\n        let ABperp = Vec2D.tripleProd(AC, AB, AB);\r\n        let ACperp = Vec2D.tripleProd(AB, AC, AC);\r\n\r\n        if(ABperp.dot(AO) > 0) {\r\n\r\n            simplex.splice(0, 1);\r\n\r\n            d.x = ABperp.x;\r\n            d.y = ABperp.y;\r\n\r\n            return false;\r\n        } else if(ACperp.dot(AO) > 0) {\r\n\r\n            simplex.splice(1, 1);\r\n\r\n            d.x = ACperp.x;\r\n            d.y = ACperp.y;\r\n\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // expanding polytope algorithm\r\n    EPA(s1, s2, simplex) {\r\n        while(true) {\r\n            let [edgeDist, edgeNorm, edgeIDX] = this.findClosestEdge(simplex);\r\n            let sup = minkowskiDifSupport(s1, s2, edgeNorm);\r\n\r\n            const d = sup.dot(edgeNorm);\r\n            \r\n            if(d - edgeDist <= 0.01) {\r\n                return [edgeNorm, edgeDist];\r\n            } else {\r\n                simplex.splice(edgeIDX, 0, sup);\r\n            }\r\n        }\r\n    }\r\n\r\n    findClosestEdge(simplex) {\r\n        let dist = Infinity;\r\n        let normal, idx;\r\n\r\n        for(let i = 0; i < simplex.length; i++) {\r\n            const j = (i + 1) % simplex.length;\r\n\r\n            const edge = Vec2D.dif(simplex[i], simplex[j]);\r\n            const n = Vec2D.normalize(Vec2D.tripleProd(edge, simplex[i], edge));\r\n\r\n            const d = n.dot(simplex[i]);\r\n\r\n            if(d < dist) {\r\n                dist = d;\r\n                normal = n;\r\n                idx = j;\r\n            }\r\n        }\r\n\r\n        return [dist, normal, idx];\r\n    }\r\n\r\n    drawObjects(ctx) {\r\n        for(const obj of this.objects) {\r\n            obj.draw(ctx);\r\n        }\r\n    }\r\n}\r\n\r\nexports.Vec2D = Vec2D;\r\nexports.PhysEnv = PhysEnv;\r\nexports.PhysObject = PhysObject;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/physx.js?");

/***/ }),

/***/ "./src/shared_modules/serialize.js":
/*!*****************************************!*\
  !*** ./src/shared_modules/serialize.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nlet avro = __webpack_require__(/*! avsc */ \"./node_modules/avsc/etc/browser/avsc.js\");\r\nlet util = __webpack_require__(/*! ./util */ \"./src/shared_modules/util.js\");\r\n\r\n\r\nlet car_schema = {\r\n    name: '_0',\r\n    default: null,\r\n    type: [ 'null', {\r\n        type: 'record',\r\n        fields: [\r\n            { name: 'ready', type: 'boolean' },\r\n            { name: 'lap', type: 'int' },\r\n            { name: 'hue', type: 'int' },\r\n            { name: 'angle', type: 'double' },\r\n            { name: 'rotVel', type: 'double' },\r\n            { \r\n                name: 'pos',\r\n                type: {\r\n                    type: 'record',\r\n                    fields: [\r\n                        { name: 'x', type: 'double' },\r\n                        { name: 'y', type: 'double' }\r\n                    ]\r\n                }\r\n            },\r\n            { \r\n                name: 'vel', \r\n                type: {\r\n                    type: 'record',\r\n                    fields: [\r\n                        { name: 'x', type: 'double' },\r\n                        { name: 'y', type: 'double' }\r\n                    ]\r\n                }\r\n            },\r\n            {\r\n                name: 'inputs',\r\n                type: ['null', {\r\n                    type: 'record',\r\n                    fields: [\r\n                        { name: 'left',  type: 'boolean' },\r\n                        { name: 'right', type: 'boolean' },\r\n                        { name: 'up',    type: 'boolean' },\r\n                        { name: 'down',  type: 'boolean' },\r\n                        { name: 'shift', type: 'boolean' },\r\n                        { name: 'enter', type: 'boolean' },\r\n                    ]\r\n                }]\r\n            }\r\n        ]\r\n    }]\r\n};\r\n\r\ncar_schema_list = [];\r\n\r\nfor(let id = 0; id < util.MAX_PLAYERS; id++) {\r\n    let new_schema = util.copyObj(car_schema);\r\n    new_schema.name = \"_\" + id;\r\n\r\n    car_schema_list.push(new_schema);\r\n}\r\n\r\nconst BUNDLE_TYPE = avro.Type.forSchema({\r\n    type: 'record',\r\n    fields: [\r\n        { name: 'tick', type: 'long' },\r\n        {\r\n            name: 'packets', \r\n            type: {\r\n                type: 'record',\r\n                fields: [\r\n                    { name: 'id', default: null, type: ['null', 'int'] },\r\n                    {\r\n                        name: 'dynamic',\r\n                        default: null,\r\n                        type: [ 'null', {\r\n                            type: 'record',\r\n                            fields: [\r\n                                { \r\n                                    name: 'cars', \r\n                                    type: {\r\n                                        type: 'record',\r\n                                        fields: car_schema_list,\r\n                                    }\r\n                                }\r\n                            ]\r\n                        }]\r\n                    },\r\n                    {\r\n                        name: 'static',\r\n                        default: null,\r\n                        type: [ 'null', {\r\n                            type: 'record',\r\n                            fields: [\r\n                                { name: 'scene', type: 'string' },\r\n                                { \r\n                                    name: 'walls', \r\n                                    type: {\r\n                                        type: 'array',\r\n                                        items: [\r\n                                            {\r\n                                                type: 'array', \r\n                                                items: [\r\n                                                    {\r\n                                                        type: 'record',\r\n                                                        fields: [\r\n                                                            {\r\n                                                                name: 'pos',\r\n                                                                type: {\r\n                                                                    type: 'record',\r\n                                                                    fields: [\r\n                                                                        { name: 'x', type: 'double' },\r\n                                                                        { name: 'y', type: 'double' }\r\n                                                                    ]\r\n                                                                }\r\n                                                            },\r\n                                                            {\r\n                                                                name: 'points',\r\n                                                                type: {\r\n                                                                    type: 'array',\r\n                                                                    items: [\r\n                                                                        {\r\n                                                                            type: 'record',\r\n                                                                            fields: [\r\n                                                                                { name: 'x', type: 'double' },\r\n                                                                                { name: 'y', type: 'double' }\r\n                                                                            ]\r\n                                                                        }\r\n                                                                    ]\r\n                                                                }\r\n                                                            }\r\n                                                        ]\r\n                                                    }\r\n                                                ]\r\n                                            }\r\n                                        ]\r\n                                    }\r\n                                },\r\n                            ]\r\n                        }]\r\n                    },\r\n                    {\r\n                        name: 'inputs',\r\n                        default: null,\r\n                        type: ['null', {\r\n                            type: 'record',\r\n                            fields: [\r\n                                { name: 'left',  type: 'boolean' },\r\n                                { name: 'right', type: 'boolean' },\r\n                                { name: 'up',    type: 'boolean' },\r\n                                { name: 'down',  type: 'boolean' },\r\n                                { name: 'shift', type: 'boolean' },\r\n                                { name: 'enter', type: 'boolean' },\r\n                            ]\r\n                        }]\r\n                    },\r\n                    { \r\n                        name: 'ping', \r\n                        default: null, \r\n                        type: ['null', {\r\n                            type: 'record',\r\n                            fields: [\r\n                                { name: 'timestamp', type: ['long'] },\r\n                                { name: 'latency', type: ['double'] },\r\n                            ]\r\n                        }]\r\n                    },\r\n                ]\r\n            }\r\n        },\r\n    ]\r\n});\r\n\r\nlet encode = (data) => {\r\n    if(data.packets.dynamic) {\r\n        var cars = data.packets.dynamic.cars;\r\n        let temp = {};\r\n\r\n        for(const [id, car] of Object.entries(cars))\r\n            temp['_'+id] = car;\r\n\r\n        data.packets.dynamic.cars = temp;\r\n    }\r\n\r\n    const buffer = BUNDLE_TYPE.toBuffer(data);\r\n\r\n    if(cars)\r\n        data.packets.dynamic.cars = cars;\r\n    \r\n    return buffer;\r\n}\r\n\r\nlet decode = (buf) => {\r\n    const buffer = Buffer.from(buf, 'utf8')\r\n    const data = BUNDLE_TYPE.fromBuffer(buffer);\r\n\r\n    if(data.packets.dynamic) {\r\n        let cars = data.packets.dynamic.cars;\r\n\r\n        for(const [id, car] of Object.entries(cars)) {\r\n            delete cars[id];\r\n\r\n            if(car)\r\n                cars[id.substr(1)] = car;\r\n        }\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\n// let vec = new Vec2D(-1, 1);\r\n// let car = new Car(vec, 60);\r\n// let cars = {\r\n//     '2': car,\r\n//     '4': car,\r\n// };\r\n\r\n// let walls = [\r\n//     [[new Vec2D(0, 0), new Vec2D(0, 1), new Vec2D(1, 1), new Vec2D(1, 0)], [new Vec2D(0, 0), new Vec2D(0, -1), new Vec2D(1, -1), new Vec2D(1, 0)]],\r\n//     [[new Vec2D(0, 0), new Vec2D(0, 1), new Vec2D(-1, 1), new Vec2D(-1, 0)], [new Vec2D(0, 0), new Vec2D(0, -1), new Vec2D(-1, -1), new Vec2D(-1, 0)]],\r\n// ];\r\n\r\n// let bundle = {\r\n//     tick: 16000000,\r\n//     packets: {\r\n//         id: 4,\r\n//         dynamic: {\r\n//             cars: cars,\r\n//         },\r\n//         static: {\r\n//             scene: 'lobby',\r\n//             walls: walls,\r\n//         },\r\n//     },\r\n// };\r\n\r\n// const buff = encode(bundle); \r\n\r\n// console.log(buff);\r\n// console.log(decode(buff).packets.dynamic.cars);\r\n// console.log(bundle.packets.dynamic.cars)\r\n\r\nexports.encode = encode;\r\nexports.decode = decode;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/serialize.js?");

/***/ }),

/***/ "./src/shared_modules/util.js":
/*!************************************!*\
  !*** ./src/shared_modules/util.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("this.CANVAS_WIDTH = 480;\r\nthis.CANVAS_HEIGHT = 720;\r\nthis.BUFFER_SIZE = 1024\r\nthis.MAX_PLAYERS = 5;\r\n\r\nthis.getTime = () => {\r\n    let d = new Date();\r\n    let t = d.getTime();\r\n    return t;\r\n}\r\n\r\nfunction interval (duration, fn) {\r\n    var _this = this\r\n    this.baseline = undefined\r\n    \r\n    this.run = function(){\r\n        if(_this.baseline === undefined){\r\n            _this.baseline = new Date().getTime()\r\n        }\r\n        fn()\r\n        var end = new Date().getTime()\r\n        _this.baseline += duration\r\n    \r\n        var nextTick = duration - (end - _this.baseline)\r\n        if(nextTick<0){\r\n            nextTick = 0\r\n        }\r\n        \r\n        _this.timer = setTimeout(function(){\r\n            _this.run(end)\r\n        }, nextTick)\r\n    }\r\n  \r\n    this.stop = function(){\r\n        clearTimeout(_this.timer)\r\n    }\r\n}\r\n\r\nthis.min_missing_id = (clients, min = 0, offset = 0) => {\r\n    let arr = Array.from(clients).sort((a, b) => a.id - b.id);\r\n\r\n    for(var i = 0; i < arr.length - 1; i++) {\r\n        if(arr[i + offset].id != i + min) {\r\n            break;\r\n        }\r\n    }\r\n    return i + min;\r\n}\r\n\r\nthis.getBuffer = (buffer, id) => {\r\n    return buffer[(id + this.BUFFER_SIZE) % this.BUFFER_SIZE];\r\n}\r\n\r\nthis.setBuffer = (buffer, id, data) => {\r\n    buffer[(id + this.BUFFER_SIZE) % this.BUFFER_SIZE] = data;\r\n}\r\n\r\nthis.copyObj = (obj) => {\r\n    return JSON.parse(JSON.stringify(obj));\r\n}\r\n\r\nexports = this;\r\nexports.interval = interval;\n\n//# sourceURL=webpack://js-kart/./src/shared_modules/util.js?");

/***/ }),

/***/ "?1dbe":
/*!************************!*\
  !*** stream (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/stream_(ignored)?");

/***/ }),

/***/ "?5399":
/*!************************!*\
  !*** stream (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/stream_(ignored)?");

/***/ }),

/***/ "?6f86":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/zlib_(ignored)?");

/***/ }),

/***/ "?a0c3":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/fs_(ignored)?");

/***/ }),

/***/ "?613f":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://js-kart/os_(ignored)?");

/***/ }),

/***/ "./node_modules/available-typed-arrays/index.js":
/*!******************************************************!*\
  !*** ./node_modules/available-typed-arrays/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n\n\n//# sourceURL=webpack://js-kart/./node_modules/available-typed-arrays/index.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n\n\n//# sourceURL=webpack://js-kart/./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/client/index.js");
/******/ 	
/******/ })()
;